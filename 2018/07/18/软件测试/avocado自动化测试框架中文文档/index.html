<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="测试,">










<meta name="description" content="关于AvocadoAvocado是一套帮助自动化测试的工具和库。 人们可以将其称为具有益处的测试框架。 本机测试是用Python编写的,它们遵循unitest模式,但任何可执行文件都可以作为测试。">
<meta name="keywords" content="测试">
<meta property="og:type" content="article">
<meta property="og:title" content="avocado自动化测试框架中文文档">
<meta property="og:url" content="http://gaianote.github.io/2018/07/18/软件测试/avocado自动化测试框架中文文档/index.html">
<meta property="og:site_name" content="李云鹏的个人博客">
<meta property="og:description" content="关于AvocadoAvocado是一套帮助自动化测试的工具和库。 人们可以将其称为具有益处的测试框架。 本机测试是用Python编写的,它们遵循unitest模式,但任何可执行文件都可以作为测试。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-10-07T13:38:20.338Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="avocado自动化测试框架中文文档">
<meta name="twitter:description" content="关于AvocadoAvocado是一套帮助自动化测试的工具和库。 人们可以将其称为具有益处的测试框架。 本机测试是用Python编写的,它们遵循unitest模式,但任何可执行文件都可以作为测试。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://gaianote.github.io/2018/07/18/软件测试/avocado自动化测试框架中文文档/">





  <title>avocado自动化测试框架中文文档 | 李云鹏的个人博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">李云鹏的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gaianote.github.io/2018/07/18/软件测试/avocado自动化测试框架中文文档/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李云鹏">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/rem.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李云鹏的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">avocado自动化测试框架中文文档</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-18T09:21:04+00:00">
                2018-07-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv">本文总阅读量
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>次
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="关于Avocado"><a href="#关于Avocado" class="headerlink" title="关于Avocado"></a><a href="https://avocado-framework.readthedocs.io/en/63.0/Introduction.html" target="_blank" rel="noopener">关于Avocado</a></h2><p>Avocado是一套帮助自动化测试的工具和库。</p>
<p>人们可以将其称为具有益处的测试框架。 本机测试是用Python编写的,它们遵循unitest模式,但任何可执行文件都可以作为测试。</p>
<a id="more"></a>
<p>Avocado由以下组成：</p>
<ul>
<li><p>一个允许您执行测试的测试运行器。 这些测试可以用您选择的语言编写,也可以用Python编写并使用可用的库。 在这两种情况下,您都可以获得自动日志和系统信息收集等功能。</p>
</li>
<li><p>帮助您以简洁,富有表现力和强大的方式编写测试的库。 您可以在库和API中找到有关哪些库适用于测试编写者的更多信息。</p>
</li>
<li><p>可以扩展Avocado Framework并为其添加新功能的插件。</p>
</li>
</ul>
<p>Avocado是建立在Autotest积累的经验基础上,同时改善其弱点和缺点。</p>
<p>Avocado尽可能地遵守标准的Python测试技术。 使用Avocado API编写的测试来自unittest类,同时添加了适用于功能和性能测试的其他方法。 测试运行器旨在帮助人们在提供各种系统和日志记录工具的同时运行他们的测试,并且如果您需要更多功能,那么您可以逐步开始使用API功能。</p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a><a href="https://avocado-framework.readthedocs.io/en/63.0/GetStartedGuide.html" target="_blank" rel="noopener">入门</a></h2><p>那些喜欢视频介绍的人,请看看其他资源。 无论哪种方式,使用Avocado的第一步显然是安装它。</p>
<h3 id="安装Avocado"><a href="#安装Avocado" class="headerlink" title="安装Avocado"></a>安装Avocado</h3><p>Avocado主要是用Python编写的,因此标准的Python安装是可行的,而且通常更可取。</p>
<blockquote>
<p>如果您正在寻找特定于虚拟化的测试,请在完成Avocado安装后考虑查看Avocado-VT安装说明。</p>
</blockquote>
<h4 id="使用标准Python工具进行安装"><a href="#使用标准Python工具进行安装" class="headerlink" title="使用标准Python工具进行安装"></a>使用标准Python工具进行安装</h4><p>最简单的安装方法是通过pip。 在大多数可用Python 2.7和pip的POSIX系统上,只需一个命令即可执行安装：</p>
<blockquote>
<p>译者注:虽然python2.7是可用的,但是已经逐渐被淘汰了,因此建议使用python3.6+以及其相对应的pip进行安装</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --user avocado-framework</span><br></pre></td></tr></table></figure>
<p>这将从PyPI存储库中获取Avocado包(可能还有一些依赖项),并尝试将其安装在用户的主目录中(通常在〜/ .local下)。</p>
<blockquote>
<p>如果要执行系统范围的安装,请删除 –user删除。<br>译者:如果希望在命令行启用 avocado 命令的话,安装时不能使用 –user 参数</p>
</blockquote>
<p>如果您想要更多隔离,Avocado也可以安装在Python虚拟环境中。 除了创建和激活虚拟环境本身之外没有其他步骤：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python -m virtualenv /path/to/new/virtual_environment</span><br><span class="line">. /path/to/new/virtual_environment/bin/activate</span><br><span class="line">pip install avocado-framework</span><br></pre></td></tr></table></figure>
<p>请注意,这将安装Avocado核心功能。</p>
<p>许多Avocado功能都作为非核心插件分发,也可作为PyPI上的附加软件包提供。 你应该能够通过<code>pip search avocado-framework-plugin | grep avocado-framework-plugin</code>找到它们。其中一些列在下面：</p>
<ul>
<li><p><a href="https://pypi.python.org/pypi/avocado-framework-plugin-result-html" target="_blank" rel="noopener">avocado-framework-plugin-result-html</a>: HTML报告</p>
</li>
<li><p><a href="https://pypi.python.org/pypi/avocado-framework-plugin-resultsdb" target="_blank" rel="noopener">avocado-framework-plugin-resultsdb</a>: 将job结果传播到Resultsdb</p>
</li>
<li><p><a href="https://pypi.python.org/pypi/avocado-framework-plugin-runner-remote" target="_blank" rel="noopener">avocado-framework-plugin-runner-remote</a>: 用于远程执行的运行器</p>
</li>
<li><p><a href="https://pypi.python.org/pypi/avocado-framework-plugin-runner-vm" target="_blank" rel="noopener">avocado-framework-plugin-runner-vm</a>: 用于libvirt VM执行的运行器</p>
</li>
<li><p><a href="https://pypi.python.org/pypi/avocado-framework-plugin-runner-docker" target="_blank" rel="noopener">avocado-framework-plugin-runner-docker</a>: Docker容器上执行的Runner</p>
</li>
<li><p><a href="https://pypi.python.org/pypi/avocado-framework-plugin-loader-yaml" target="_blank" rel="noopener">avocado-framework-plugin-loader-yaml</a>: 从YAML文件加载测试</p>
</li>
<li><p><a href="https://pypi.python.org/pypi/avocado-framework-plugin-robot" target="_blank" rel="noopener">avocado-framework-plugin-robot</a>: 执行Robot Framework测试</p>
</li>
<li><p><a href="https://pypi.python.org/pypi/avocado-framework-plugin-varianter-yaml-to-mux" target="_blank" rel="noopener">avocado-framework-plugin-varianter-yaml-to-mux</a>: 将YAML文件解析为变量</p>
</li>
</ul>
<h4 id="从包安装"><a href="#从包安装" class="headerlink" title="从包安装"></a>从包安装</h4><p>原文介绍了一些Avocado其它的安装方法,有兴趣可以去<a href="https://avocado-framework.readthedocs.io/en/63.0/GetStartedGuide.html#installing-from-packages" target="_blank" rel="noopener">原址</a>查看</p>
<h3 id="使用Avocado"><a href="#使用Avocado" class="headerlink" title="使用Avocado"></a>使用Avocado</h3><p>您应首先使用测试运行器体验Avocado,即命令行工具,它将方便地运行您的测试并收集其结果。</p>
<h4 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h4><p>为此,请使用<code>run</code>子命令运行Avocado,<code>run</code>后面跟随要进行的测试,它可以是文件的路径,也可以是可识别的名称：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ avocado run /bin/true</span><br><span class="line">JOB ID    : 381b849a62784228d2fd208d929cc49f310412dc</span><br><span class="line">JOB LOG   : $HOME/avocado/job-results/job-2014-08-12T15.39-381b849a/job.log</span><br><span class="line"> (1/1) /bin/true: PASS (0.01 s)</span><br><span class="line">RESULTS    : PASS 1 | ERROR 0 | FAIL 0 | SKIP 0 | WARN 0 | INTERRUPT 0</span><br><span class="line">JOB TIME   : 0.11 s</span><br><span class="line">JOB HTML  : $HOME/avocado/job-results/job-2014-08-12T15.39-381b849a/html/results.html</span><br></pre></td></tr></table></figure>
<p>您可能已经注意到我们使用/ bin / true作为测试,并且根据我们的期望,它通过了！ 这些被称为简单测试,但也有另一种类型的测试,我们称之为仪器测试。 在测试类型中查看更多信息或继续阅读。</p>
<blockquote>
<p>虽然在大多数情况下运行Avocado运行 $ test1 $ test3 …很好,但它可能导致参数与测试名称冲突。 最安全的执行测试的方法是Avocado运行 -  $ argument1  -  $ argument2  -  $ test1 $ test2。 之后的所有内容 - 将被视为位置参数,即测试名称(在Avocado运行的情况下)</p>
</blockquote>
<h4 id="列出测试"><a href="#列出测试" class="headerlink" title="列出测试"></a>列出测试</h4><p>您有两种方法来检测测试文件。 您可以使用–dry-run参数来模拟执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">avocado run /bin/true --dry-run</span><br><span class="line">JOB ID     : 0000000000000000000000000000000000000000</span><br><span class="line">JOB LOG    : /tmp/avocado-dry-runSeWniM/job-2015-10-16T15.46-0000000/job.log</span><br><span class="line"> (1/1) /bin/true: SKIP</span><br><span class="line">RESULTS    : PASS 0 | ERROR 0 | FAIL 0 | SKIP 1 | WARN 0 | INTERRUPT 0</span><br><span class="line">JOB TIME   : 0.10 s</span><br><span class="line">JOB HTML   : /tmp/avocado-dry-runSeWniM/job-2015-10-16T15.46-0000000/html/results.html</span><br></pre></td></tr></table></figure>
<p>它支持所有运行参数,模拟运行甚至列出测试参数。</p>
<p>另一种方法是使用list子命令列出发现的测试如果没有提供参数,Avocado会为每个插件列出“默认”测试。 输出可能如下所示：</p>
<blockquote>
<p>译者: <code>avocado list .</code> 列出当前目录的avocado测试,直接使用<code>avocado list</code>未返回结果。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ avocado list</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/abort.py</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/datadir.py</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/doublefail.py</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/doublefree.py</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/errortest.py</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/failtest.py</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/fiotest.py</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/gdbtest.py</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/gendata.py</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/linuxbuild.py</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/multiplextest.py</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/passtest.py</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/sleeptenmin.py</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/sleeptest.py</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/synctest.py</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/timeouttest.py</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/warntest.py</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/whiteboard.py</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Avocado认为这些Python文件包含INSTRUMENTED测试。</p>
<p>现在让我们列出可执行的shell脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ avocado list | grep ^SIMPLE</span><br><span class="line">SIMPLE       /usr/share/doc/avocado/tests/env_variables.sh</span><br><span class="line">SIMPLE       /usr/share/doc/avocado/tests/output_check.sh</span><br><span class="line">SIMPLE       /usr/share/doc/avocado/tests/simplewarning.sh</span><br><span class="line">SIMPLE       /usr/share/doc/avocado/tests/failtest.sh</span><br><span class="line">SIMPLE       /usr/share/doc/avocado/tests/passtest.sh</span><br></pre></td></tr></table></figure>
<p>这里,如前所述,SIMPLE意味着这些文件是可执行文件,被视为简单测试。 您还可以使用–verbose或-V标志来显示Avocado找到的文件,但不被视为Avocado测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ avocado list examples/gdb-prerun-scripts/ -V</span><br><span class="line">Type       Test                                     Tag(s)</span><br><span class="line">NOT_A_TEST examples/gdb-prerun-scripts/README</span><br><span class="line">NOT_A_TEST examples/gdb-prerun-scripts/pass-sigusr1</span><br><span class="line"></span><br><span class="line">TEST TYPES SUMMARY</span><br><span class="line">==================</span><br><span class="line">SIMPLE: 0</span><br><span class="line">INSTRUMENTED: 0</span><br><span class="line">MISSING: 0</span><br><span class="line">NOT_A_TEST: 2</span><br></pre></td></tr></table></figure>
<p>请注意,详细标志还会添加摘要信息。</p>
<h4 id="写一个简单的测试"><a href="#写一个简单的测试" class="headerlink" title="写一个简单的测试"></a>写一个简单的测试</h4><p>这个用shell脚本编写的简单测试的简单例子</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'#!/bin/bash'</span> &gt; /tmp/simple_test.sh</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'exit 0'</span> &gt;&gt; /tmp/simple_test.sh</span><br><span class="line">$ chmod +x /tmp/simple_test.sh</span><br></pre></td></tr></table></figure>
<p>請注意,該文件具有可執行權限,這是Avocado將其視為簡單測試的要求。 另請注意,腳本以狀態代碼0退出,這表示Avocado成功結果。</p>
<h4 id="运行更复杂的测试工作"><a href="#运行更复杂的测试工作" class="headerlink" title="运行更复杂的测试工作"></a>运行更复杂的测试工作</h4><p>您可以按任意顺序运行任意数量的测试,以及混合和匹配仪器化测试和简单测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ avocado run failtest.py sleeptest.py synctest.py failtest.py synctest.py /tmp/simple_test.sh</span><br><span class="line">JOB ID    : 86911e49b5f2c36caeea41307cee4fecdcdfa121</span><br><span class="line">JOB LOG   : $HOME/avocado/job-results/job-2014-08-12T15.42-86911e49/job.log</span><br><span class="line"> (1/6) failtest.py:FailTest.test: FAIL (0.00 s)</span><br><span class="line"> (2/6) sleeptest.py:SleepTest.test: PASS (1.00 s)</span><br><span class="line"> (3/6) synctest.py:SyncTest.test: PASS (2.43 s)</span><br><span class="line"> (4/6) failtest.py:FailTest.test: FAIL (0.00 s)</span><br><span class="line"> (5/6) synctest.py:SyncTest.test: PASS (2.44 s)</span><br><span class="line"> (6/6) /tmp/simple_test.sh.1: PASS (0.02 s)</span><br><span class="line">RESULTS    : PASS 4 | ERROR 0 | FAIL 2 | SKIP 0 | WARN 0 | INTERRUPT 0</span><br><span class="line">JOB TIME   : 5.98 s</span><br><span class="line">JOB HTML  : $HOME/avocado/job-results/job-2014-08-12T15.42-86911e49/html/results.html</span><br></pre></td></tr></table></figure>
<h4 id="在第一次失败的测试中中断job-failfast"><a href="#在第一次失败的测试中中断job-failfast" class="headerlink" title="在第一次失败的测试中中断job(failfast)"></a>在第一次失败的测试中中断job(failfast)</h4><p>Avocado运行命令具有选项<code>--failfast on</code>以在遇到第一次失败的测试时退出测试,后面的用例不再继续执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ avocado run --failfast on /bin/true /bin/false /bin/true /bin/true</span><br><span class="line">JOB ID     : eaf51b8c7d6be966bdf5562c9611b1ec2db3f68a</span><br><span class="line">JOB LOG    : $HOME/avocado/job-results/job-2016-07-19T09.43-eaf51b8/job.log</span><br><span class="line"> (1/4) /bin/true: PASS (0.01 s)</span><br><span class="line"> (2/4) /bin/false: FAIL (0.01 s)</span><br><span class="line">Interrupting job (failfast).</span><br><span class="line">RESULTS    : PASS 1 | ERROR 0 | FAIL 1 | SKIP 2 | WARN 0 | INTERRUPT 0</span><br><span class="line">JOB TIME   : 0.12 s</span><br><span class="line">JOB HTML   : /home/apahim/avocado/job-results/job-2016-07-19T09.43-eaf51b8/html/results.html</span><br></pre></td></tr></table></figure>
<p>在重新运行<code>--failfast on</code>执行的job时,也可以使用<code>--failfast off</code>强制禁用failfast模式。</p>
<h4 id="忽略缺少的测试引用"><a href="#忽略缺少的测试引用" class="headerlink" title="忽略缺少的测试引用"></a>忽略缺少的测试引用</h4><p>当您提供测试参考列表时,Avocado将尝试将所有测试参考解析为测试。如果无法将一个或多个测试引用解析为测试,则不会创建job。例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ avocado run passtest.py badtest.py</span><br><span class="line">Unable to resolve reference(s) &apos;badtest.py&apos; with plugins(s) &apos;file&apos;, &apos;robot&apos;, &apos;external&apos;, try running &apos;avocado list -V badtest.py&apos; to see the details.</span><br></pre></td></tr></table></figure>
<p>但是如果你无论如何都想要执行这项测试,使用可以解决的测试,你可以使用<code>--ignore-missing-references on</code>。 UI中将显示相同的消息,但将执行这个测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ avocado run passtest.py badtest.py --ignore-missing-references on</span><br><span class="line">Unable to resolve reference(s) &apos;badtest.py&apos; with plugins(s) &apos;file&apos;, &apos;robot&apos;, &apos;external&apos;, try running &apos;avocado list -V badtest.py&apos; to see the details.</span><br><span class="line">JOB ID     : 85927c113074b9defd64ea595d6d1c3fdfc1f58f</span><br><span class="line">JOB LOG    : $HOME/avocado/job-results/job-2017-05-17T10.54-85927c1/job.log</span><br><span class="line"> (1/1) passtest.py:PassTest.test: PASS (0.02 s)</span><br><span class="line">RESULTS    : PASS 1 | ERROR 0 | FAIL 0 | SKIP 0 | WARN 0 | INTERRUPT 0 | CANCEL 0</span><br><span class="line">JOB TIME   : 0.11 s</span><br><span class="line">JOB HTML   : $HOME/avocado/job-results/job-2017-05-17T10.54-85927c1/html/results.html</span><br></pre></td></tr></table></figure>
<h4 id="使用外部运行器运行测试"><a href="#使用外部运行器运行测试" class="headerlink" title="使用外部运行器运行测试"></a>使用外部运行器运行测试</h4><p>在大多数软件项目中使用逐渐增加的测试套件是很常见的。这些通常包括一个定制的,非常具体的测试运行器,它知道如何查找和运行自己的测试</p>
<p>尽管如此,由于各种原因,在Avocado中运行这些测试可能是一个好主意,包括能够以不同的人机和机器可读格式获得结果,收集系统信息以及这些测试(Avocado的sysinfo功能)等等</p>
<p>Avocado 通过其”external runner”功能实现了这一目标。最基本的使用方法是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ avocado run --external-runner=/path/to/external_runner foo bar baz</span><br></pre></td></tr></table></figure>
<p>在此示例中,Avocado将报告测试foo,bar和baz的各个测试结果。实际结果将基于<code>/path/to/external_runner foo</code>,<code>/path/to/external_runner bar</code>和<code>/path/to/external_runner baz</code>的单独执行的返回代码。其中<code>/path/to/external_runner</code>是你的外部解释器的路径。</p>
<p>作为另一种解释该功能如何工作的方法,可以将”external runner”视为某种解释器,并将个体测试视为此解释器识别并能够执行的任何内容。一个UNIX shell,比如<code>/bin/sh</code>可以被认为是一个外部运行器,带有shell代码的文件可以被认为是测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"exit 0"</span> &gt; /tmp/pass</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"exit 1"</span> &gt; /tmp/fail</span><br><span class="line">$ avocado run --external-runner=/bin/sh /tmp/pass /tmp/fail</span><br><span class="line">JOB ID     : 4a2a1d259690cc7b226e33facdde4f628ab30741</span><br><span class="line">JOB LOG    : /home/&lt;user&gt;/avocado/job-results/job-&lt;date&gt;-&lt;shortid&gt;/job.log</span><br><span class="line">(1/2) /tmp/pass: PASS (0.01 s)</span><br><span class="line">(2/2) /tmp/fail: FAIL (0.01 s)</span><br><span class="line">RESULTS    : PASS 1 | ERROR 0 | FAIL 1 | SKIP 0 | WARN 0 | INTERRUPT 0</span><br><span class="line">JOB TIME   : 0.11 s</span><br><span class="line">JOB HTML   : /home/&lt;user&gt;/avocado/job-results/job-&lt;date&gt;-&lt;shortid&gt;/html/results.html</span><br></pre></td></tr></table></figure>
<p>这个例子非常明显,可以通过给/tmp/pass和/tmp/fail “shebangs”(#!/bin/sh)来实现,使它们可执行(chmod+x /tmp/pass /tmp/fail并将它们作为”SIMPLE”测试运行。</p>
<h4 id="但现在考虑以下示例："><a href="#但现在考虑以下示例：" class="headerlink" title="但现在考虑以下示例："></a>但现在考虑以下示例：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ avocado run --external-runner=/bin/curl http://<span class="built_in">local</span>-avocado-server:9405/<span class="built_in">jobs</span>/ \</span><br><span class="line">                                       http://remote-avocado-server:9405/<span class="built_in">jobs</span>/</span><br><span class="line">JOB ID     : 56016a1ffffaba02492fdbd5662ac0b958f51e11</span><br><span class="line">JOB LOG    : /home/&lt;user&gt;/avocado/job-results/job-&lt;date&gt;-&lt;shortid&gt;/job.log</span><br><span class="line">(1/2) http://<span class="built_in">local</span>-avocado-server:9405/<span class="built_in">jobs</span>/: PASS (0.02 s)</span><br><span class="line">(2/2) http://remote-avocado-server:9405/<span class="built_in">jobs</span>/: FAIL (3.02 s)</span><br><span class="line">RESULTS    : PASS 1 | ERROR 0 | FAIL 1 | SKIP 0 | WARN 0 | INTERRUPT 0</span><br><span class="line">JOB TIME   : 3.14 s</span><br><span class="line">JOB HTML   : /home/&lt;user&gt;/avocado/job-results/job-&lt;date&gt;-&lt;shortid&gt;/html/results.html</span><br></pre></td></tr></table></figure>
<p>这有效地使<code>/bin/curl</code>成为”外部测试运行器”,负责尝试获取这些URL,并为每个URL报告PASS或FAIL。</p>
<h3 id="调试测试"><a href="#调试测试" class="headerlink" title="调试测试"></a>调试测试</h3><h4 id="显示测试输出"><a href="#显示测试输出" class="headerlink" title="显示测试输出"></a>显示测试输出</h4><p>在开发新测试时,您经常希望直接查看job日志,而无需切换屏幕或不必“拖尾”job日志。</p>
<p>为了实现它,你可以使用<code>avocado --show test run ...</code> 或者 <code>avocado run --show-job-log</code>选项</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ avocado --show <span class="built_in">test</span> run examples/tests/sleeptest.py</span><br><span class="line">...</span><br><span class="line">Job ID: f9ea1742134e5352dec82335af584d1f151d4b85</span><br><span class="line"></span><br><span class="line">START 1-sleeptest.py:SleepTest.test</span><br><span class="line"></span><br><span class="line">PARAMS (key=timeout, path=*, default=None) =&gt; None</span><br><span class="line">PARAMS (key=sleep_length, path=*, default=1) =&gt; 1</span><br><span class="line">Sleeping <span class="keyword">for</span> 1.00 seconds</span><br><span class="line">PASS 1-sleeptest.py:SleepTest.test</span><br><span class="line"></span><br><span class="line">Test results available <span class="keyword">in</span> <span class="variable">$HOME</span>/avocado/job-results/job-2015-06-02T10.45-f9ea174</span><br></pre></td></tr></table></figure>
<p>如您所见,UI输出被抑制,只显示job日志,这使其成为测试开发和调试的有用功能。</p>
<h4 id="中断测试执行"><a href="#中断测试执行" class="headerlink" title="中断测试执行"></a>中断测试执行</h4><p>要中断job执行,用户可以按<code>ctrl + c</code>,在单次按下后将SIGTERM发送到主测试的进程并等待它完成。如果这没有帮助,用户可以再次按<code>ctrl + c</code>(2s宽限期后),这会非常有效地破坏测试过程并安全地完成job执行,始终提供测试结果。</p>
<p>要暂停测试执行,用户可以使用<code>ctrl + z</code>将SIGSTOP发送到从测试的PID继承的所有进程。我们尽力停止所有进程,但操作不是原子操作,可能无法停止某些新进程。再次按下<code>ctrl + z</code>将SIGCONT发送到测试的PID继承执行的所有进程。请注意,测试执行时间(关于测试超时)仍然在测试进程停止时运行。</p>
<p>Avocado功能也可以中断测试。一个例子是使用GDB调试GDB调试功能。</p>
<p>对于自定义交互,还可以使用其他方法,如pdb或pydevd Avocado开发提示断点。请注意,不能在测试中使用STDIN(除非使用黑暗魔法)。</p>
<h2 id="书写Avocado测试"><a href="#书写Avocado测试" class="headerlink" title="书写Avocado测试"></a><a href="https://avocado-framework.readthedocs.io/en/63.0/WritingTests.html" target="_blank" rel="noopener">书写Avocado测试</a></h2><p>我们将用Python编写Avocado测试,我们将继承avocado.Test。 这使得该测试成为所谓的仪器测试。</p>
<h3 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> avocado <span class="keyword">import</span> Test</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepTest</span><span class="params">(Test)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></span><br><span class="line">        sleep_length = self.params.get(<span class="string">'sleep_length'</span>, default=<span class="number">1</span>)</span><br><span class="line">        self.log.debug(<span class="string">"Sleeping for %.2f seconds"</span>, sleep_length)</span><br><span class="line">        time.sleep(sleep_length)</span><br></pre></td></tr></table></figure>
<p>这是您可以为Avocado编写的最简单的测试,同时仍然可以利用其API功能。</p>
<h4 id="什么是Avocado测试"><a href="#什么是Avocado测试" class="headerlink" title="什么是Avocado测试"></a>什么是Avocado测试</h4><p>从上面的示例中可以看出,Avocado测试是一种从继承自avocado.Test的类开始的测试方法。</p>
<h4 id="多个测试和命名约定"><a href="#多个测试和命名约定" class="headerlink" title="多个测试和命名约定"></a>多个测试和命名约定</h4><p>您可以在一个类中进行多个测试。</p>
<p>为此,只需给出以test开头的方法名称,比如<code>test_foo</code>,<code>test_bar</code>等等。 我们建议您遵循此命名样式,如PEP8函数名称部分中所定义。</p>
<p>对于类名,您可以选择任何您喜欢的名称,但我们也建议它遵循CamelCase约定,也称为CapWords,在类名称下的PEP 8文档中定义。</p>
<h4 id="便利属性"><a href="#便利属性" class="headerlink" title="便利属性"></a>便利属性</h4><ul>
<li>可以通过<code>self.log</code>访问测试的即用型日志机制。 它允许您记录调试,信息,错误和警告消息。</li>
<li>可以通过<code>self.params</code>访问的参数传递系统(和提取系统)。 这与Varianter有关,您可以在Testary参数中找到更多信息。</li>
<li>还有更多(参见avocado.core.test.Test)</li>
</ul>
<p>为了最大限度地减少意外冲突,我们将公共冲突定义为属性,因此如果您看到类似<code>AttributeError: can&#39;t set attribute</code>就不要覆盖这些属性。</p>
<h3 id="测试状态"><a href="#测试状态" class="headerlink" title="测试状态"></a>测试状态</h3><p>Avocado支持最常见的退出状态:</p>
<ul>
<li><code>PASS</code> - 测试通过,没有未经处理的例外情况</li>
<li><code>WARN</code> - PASS的一种变量,用于跟踪最终不会影响测试结果的值得注意的事件。 一个例子可能是dmesg输出中存在的软锁定。 它与测试结果无关,除非测试失败,否则意味着该功能可能按预期工作,但有一些条件可能很好审查。 (某些结果插件不支持此功能并报告PASS)</li>
<li><code>SKIP</code> - 测试的先决条件不满足且测试的主体未被执行(也没有执行setUp()和tearDown)。</li>
<li><code>CANCEL</code> - 在setUp(),测试方法或tearDown()期间某处取消了测试。 执行setUp()和tearDown方法。</li>
<li><code>FAIL</code> - 测试未达到预期结果。 失败指向测试对象中的(可能的)错误,而不是测试脚本本身。 当测试(及其)执行中断时,报告ERROR而不是FAIL。</li>
<li><code>ERROR</code> - 这可能(可能)指向测试本身的一个错误,而不是在被测试的对象中。它通常是由未捕获的异常引起的,这种失败需要彻底探索并且应该导致测试修改以避免这种失败或者 使用self.fail以及描述测试中的对象如何无法执行它的任务。</li>
<li><code>INTERRUPTED</code> - 此结果无法由测试编写者设置,只有在超时或用户在执行此测试时按下<code>CTRL + C</code>时才会出现。</li>
<li>other - 还有其他一些内部测试状态,但你应该不会遇到它们。</li>
</ul>
<p>正如您所看到的那样,如果正确开发了测试,则FAIL是一个整洁的状态。在编写测试时,总要考虑它的<code>setUp</code>应该是什么,<code>test body</code>是什么,并且在测试中预计会出错。为了支持您,Avocado支持以下几种方法：</p>
<h4 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h4><p>设置状态的最简单方法是直接从test中使用<code>self.fail</code>,<code>self.error</code>或<code>self.cancel</code>。</p>
<p>要记录警告,只需写入<code>self.log.warning</code>日志即可。这不会中断测试执行,但会记住条件,如果没有失败,则会将测试报告为<code>WARN</code>。</p>
<h4 id="将错误转化为失败"><a href="#将错误转化为失败" class="headerlink" title="将错误转化为失败"></a>将错误转化为失败</h4><p>Python代码上的错误通常以抛出异常的形式发出信号。当Avocado运行测试时,任何未处理的异常都将被视为测试错误,而不是失败。</p>
<p>尽管如此,依赖库通常会引发自定义(或内置)异常。这些异常通常会导致错误,但如果您确定这是测试对象的奇怪行为,您应该捕获异常并解释self.fail方法中的失败：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    process.run(<span class="string">"stress_my_feature"</span>)</span><br><span class="line"><span class="keyword">except</span> process.CmdError <span class="keyword">as</span> details:</span><br><span class="line">    self.fail(<span class="string">"The stress comamnd failed: %s"</span> % details)</span><br></pre></td></tr></table></figure>
<p>如果你的测试组件有很多执行而你无法在其他情况下得到这个异常然后预期失败,你可以使用<code>fail_on</code>装饰器来简化代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@avocado.fail_on(process.CmdError)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></span><br><span class="line">    process.run(<span class="string">"first cmd"</span>)</span><br><span class="line">    process.run(<span class="string">"second cmd"</span>)</span><br><span class="line">    process.run(<span class="string">"third cmd"</span>)</span><br></pre></td></tr></table></figure>
<p>再次,让您的测试脚本保持最新并区分<code>FAIL</code>和<code>ERROR</code>的区别,将在查看测试结果时节省大量时间。</p>
<h3 id="保存测试生成的-自定义-数据"><a href="#保存测试生成的-自定义-数据" class="headerlink" title="保存测试生成的(自定义)数据"></a>保存测试生成的(自定义)数据</h3><p>每个测试实例都提供一个所谓的<code>whiteboard</code>。它可以通过self.whiteboard访问。这个<code>whiteboard</code>只是一个字符串,在测试结束后会自动保存到测试结果中(在执行过程中没有同步,所以当机器或python严重崩溃时可能不存在,并且应该使用direct io直接输出到关键数据的输出)。如果您选择将二进制数据保存到<code>whiteboard</code>,则您有责任首先对其进行编码(base64是显而易见的选择)。</p>
<p>在之前演示的<code>sleeptest</code>测试的基础上,假设您想要保存<code>sleep length</code>以供其他一些脚本或数据分析工具使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></span><br><span class="line">    sleep_length = self.params.get(<span class="string">'sleep_length'</span>, default=<span class="number">1</span>)</span><br><span class="line">    self.log.debug(<span class="string">"Sleeping for %.2f seconds"</span>, sleep_length)</span><br><span class="line">    time.sleep(sleep_length)</span><br><span class="line">    self.whiteboard = <span class="string">"%.2f"</span> % sleep_length</span><br></pre></td></tr></table></figure>
<p><code>whiteboard</code>可以并且应该由可用的测试结果插件生成的文件公开。 results.json文件已包含每个测试的<code>whiteboard</code>。此外,为方便起见,我们将<code>whiteboard</code>内容的原始副本保存在名为whiteboard的文件中,与result.json文件位于同一级别(也许您希望直接使用基准测试结果与自定义脚本分析特定的基准测试结果)。</p>
<p>如果需要附加多个输出文件,还可以使用<code>self.outputdir</code>,它指向<code>$RESULTS/test-results/$ TEST_ID/data</code>位置,并保留用于任意测试结果数据。</p>
<h3 id="访问测试数据文件"><a href="#访问测试数据文件" class="headerlink" title="访问测试数据文件"></a>访问测试数据文件</h3><p>某些测试可能依赖于测试文件本身外部的数据文件。 Avocado提供了一个测试API,可以很容易地访问这些文件：<code>get_data()</code> 。</p>
<p>对于Avocado测试(即INSTRUMENTED测试),<code>get_data()</code>允许从最多三个源访问测试数据文件：</p>
<ul>
<li><p>文件级数据目录：以测试文件命名但以.data结尾的目录。对于测试文件<code>/home/user/test.py</code>,文件级数据目录是<code>/home/user/test.py.data/</code>。</p>
</li>
<li><p>测试级别数据目录：以测试文件和特定测试名称命名的目录。当同一文件的不同测试部分需要不同的数据文件(具有相同或不同名称)时,这些功能非常有用。考虑到之前的<code>/home/user/test.py</code>示例,并假设它包含两个测试,<code>MyTest.test_foo</code>和<code>MyTest.test_bar</code>,测试级数据目录将是<code>/home/user/test.py.data/MyTest.test_foo/</code>和<code>home/user/test.py.data/MyTest.test_bar/</code></p>
</li>
<li><p>变量级数据目录：如果在测试期间使用变量执行时,也会考虑以变量命名的目录寻找测试数据文件。对于测试文件<code>/home/user/test.py</code>,并测试<code>MyTest.test_foo</code>,带有变量<code>debug-ffff</code>,数据目录路径将是<code>/home/user/test.py.data/MyTest.test_foo/debug-ffff/</code>。</p>
</li>
</ul>
<blockquote>
<p>与INSTRUMENTED测试不同,SIMPLE测试仅定义<code>file</code>和<code>variant</code> 数据目录,因此是最具体的数据目录可能看起来像<code>/bin/echo.data/debug-ffff /</code>。</p>
</blockquote>
<p>Avocado按照定义的顺序查找数据文件<a href="api/core/avocado.core.html＃avocado.core.test.TestData.DATA_SOURCES"><code>DATA_SOURCES</code></a>,这是从最具体的一个到最通用的一个。这意味着,如果是变量正在使用,首先使用variant目录。然后测试尝试测试级别目录,最后是文件级目录。</p>
<p>另外,你可以使用<code>get_data(filename,must_exist = False)</code>来获取可能不存在的文件的预期位置,这在当你打算创建它的情况下很有用。</p>
<blockquote>
<p>运行测试时,您可以使用<code>--log-test-data-directories</code>命令行选项记录将使用的测试数据目录<br>对于特定的测试和执行条件(例如使用或没有变种)。在测试日志中查找“测试数据目录”。</p>
</blockquote>
<blockquote>
<p>以前存在的API<code>avocado.core.test.Test.datadir</code>,用于允许基于测试文件访问数据目录仅限位置。此API已被删除。无论出于何种原因,您仍然只需要根据测试文件位置访问数据目录,可以使用<code>get_data(filename =&#39;&#39;,source =&#39;file&#39;,must_exist = False)</code>。</p>
</blockquote>
<h3 id="访问测试参数"><a href="#访问测试参数" class="headerlink" title="访问测试参数"></a>访问测试参数</h3><p>每个测试都有一组可以访问的参数<code>self.params.get($ name,$ path = None,$ default = None)</code>其中：</p>
<ul>
<li>name - 参数名称(键)</li>
<li>path - 查找此参数的位置(未指定时使用mux-path)</li>
<li>default - 未找到param时返回的内容</li>
</ul>
<p>路径是有点棘手。 Avocado使用树来表示参数。 在简单的场景中,您不必担心,您将在默认情况下找到所有值的路径,但最终你可能想要查询Test parameters来理解细节。</p>
<p>假设您的测试收到以下参数(您将在下一节中学习如何执行它们)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ avocado variants -m examples/tests/sleeptenmin.py.data/sleeptenmin.yaml --variants 2</span><br><span class="line">...</span><br><span class="line">Variant 1:    /run/sleeptenmin/builtin, /run/variants/one_cycle</span><br><span class="line">    /run/sleeptenmin/builtin:sleep_method =&gt; builtin</span><br><span class="line">    /run/variants/one_cycle:sleep_cycles  =&gt; 1</span><br><span class="line">    /run/variants/one_cycle:sleep_length  =&gt; 600</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>在测试中你可以通过以下方式访问这些参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.params.get(<span class="string">"sleep_method"</span>)    <span class="comment"># returns "builtin"</span></span><br><span class="line">self.params.get(<span class="string">"sleep_cycles"</span>, <span class="string">'*'</span>, <span class="number">10</span>)    <span class="comment"># returns 1</span></span><br><span class="line">self.params.get(<span class="string">"sleep_length"</span>, <span class="string">"/*/variants/*"</span>)  <span class="comment"># returns 600</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在可能发生冲突的复杂场景中,该路径很重要,因为当存在多个具有相同键匹配值的值时,Avocado会引发异常。如上所述,您可以通过使用特定路径或通过定义允许指定解析层次结构的自定义mux-path来避免这些路径。 更多细节可以在测试参数中找到。</p>
</blockquote>
<h3 id="运行多个测试变量"><a href="#运行多个测试变量" class="headerlink" title="运行多个测试变量"></a>运行多个测试变量</h3><p>在上一节中,我们描述了如何处理参数。 现在,让我们看看如何生成它们并使用不同的参数执行测试。</p>
<p>变量子系统允许创建多个参数变量,并使用这些参数变量执行测试。此子系统是可插入的,因此您可以使用自定义插件来生成变量。为了简单起见,让我们使用Avocado的初步实施,称为<code>yaml_to_mux</code>。</p>
<p><code>yaml_to_mux</code>插件接受YAML文件。 这些将创建树状结构,将变量存储为参数并使用自定义标记将位置标记为<code>multiplex</code>域。</p>
<p>让我们使用<code>examples/tests/sleeptenmin.py.data/sleeptenmin.yaml</code>文件作为例子：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sleeptenmin:</span> <span class="type">!mux</span></span><br><span class="line"><span class="attr">    builtin:</span></span><br><span class="line"><span class="attr">        sleep_method:</span> <span class="string">builtin</span></span><br><span class="line"><span class="attr">    shell:</span></span><br><span class="line"><span class="attr">        sleep_method:</span> <span class="string">shell</span></span><br><span class="line"><span class="attr">variants:</span> <span class="type">!mux</span></span><br><span class="line"><span class="attr">    one_cycle:</span></span><br><span class="line"><span class="attr">        sleep_cycles:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">        sleep_length:</span> <span class="number">600</span></span><br><span class="line"><span class="attr">    six_cycles:</span></span><br><span class="line"><span class="attr">        sleep_cycles:</span> <span class="number">6</span></span><br><span class="line"><span class="attr">        sleep_length:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">    one_hundred_cycles:</span></span><br><span class="line"><span class="attr">        sleep_cycles:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">        sleep_length:</span> <span class="number">6</span></span><br><span class="line"><span class="attr">    six_hundred_cycles:</span></span><br><span class="line"><span class="attr">        sleep_cycles:</span> <span class="number">600</span></span><br><span class="line"><span class="attr">        sleep_length:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>其中产生以下结构和参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">$ avocado variants -m examples/tests/sleeptenmin.py.data/sleeptenmin.yaml --summary 2 --variants 2</span><br><span class="line">Multiplex tree representation:</span><br><span class="line"> ┗━━ run</span><br><span class="line">      ┣━━ sleeptenmin</span><br><span class="line">      ┃    ╠══ <span class="built_in">builtin</span></span><br><span class="line">      ┃    ║     → sleep_method: <span class="built_in">builtin</span></span><br><span class="line">      ┃    ╚══ shell</span><br><span class="line">      ┃          → sleep_method: shell</span><br><span class="line">      ┗━━ variants</span><br><span class="line">           ╠══ one_cycle</span><br><span class="line">           ║     → sleep_length: 600</span><br><span class="line">           ║     → sleep_cycles: 1</span><br><span class="line">           ╠══ six_cycles</span><br><span class="line">           ║     → sleep_length: 100</span><br><span class="line">           ║     → sleep_cycles: 6</span><br><span class="line">           ╠══ one_hundred_cycles</span><br><span class="line">           ║     → sleep_length: 6</span><br><span class="line">           ║     → sleep_cycles: 100</span><br><span class="line">           ╚══ six_hundred_cycles</span><br><span class="line">                 → sleep_length: 1</span><br><span class="line">                 → sleep_cycles: 600</span><br><span class="line"></span><br><span class="line">Multiplex variants (8):</span><br><span class="line"></span><br><span class="line">Variant <span class="built_in">builtin</span>-one_cycle-f659:    /run/sleeptenmin/<span class="built_in">builtin</span>, /run/variants/one_cycle</span><br><span class="line">    /run/sleeptenmin/<span class="built_in">builtin</span>:sleep_method =&gt; <span class="built_in">builtin</span></span><br><span class="line">    /run/variants/one_cycle:sleep_cycles  =&gt; 1</span><br><span class="line">    /run/variants/one_cycle:sleep_length  =&gt; 600</span><br><span class="line"></span><br><span class="line">Variant <span class="built_in">builtin</span>-six_cycles-723b:    /run/sleeptenmin/<span class="built_in">builtin</span>, /run/variants/six_cycles</span><br><span class="line">    /run/sleeptenmin/<span class="built_in">builtin</span>:sleep_method =&gt; <span class="built_in">builtin</span></span><br><span class="line">    /run/variants/six_cycles:sleep_cycles =&gt; 6</span><br><span class="line">    /run/variants/six_cycles:sleep_length =&gt; 100</span><br><span class="line"></span><br><span class="line">Variant <span class="built_in">builtin</span>-one_hundred_cycles-633a:    /run/sleeptenmin/<span class="built_in">builtin</span>, /run/variants/one_hundred_cycles</span><br><span class="line">    /run/sleeptenmin/<span class="built_in">builtin</span>:sleep_method         =&gt; <span class="built_in">builtin</span></span><br><span class="line">    /run/variants/one_hundred_cycles:sleep_cycles =&gt; 100</span><br><span class="line">    /run/variants/one_hundred_cycles:sleep_length =&gt; 6</span><br><span class="line"></span><br><span class="line">Variant <span class="built_in">builtin</span>-six_hundred_cycles-a570:    /run/sleeptenmin/<span class="built_in">builtin</span>, /run/variants/six_hundred_cycles</span><br><span class="line">    /run/sleeptenmin/<span class="built_in">builtin</span>:sleep_method         =&gt; <span class="built_in">builtin</span></span><br><span class="line">    /run/variants/six_hundred_cycles:sleep_cycles =&gt; 600</span><br><span class="line">    /run/variants/six_hundred_cycles:sleep_length =&gt; 1</span><br><span class="line"></span><br><span class="line">Variant shell-one_cycle-55f5:    /run/sleeptenmin/shell, /run/variants/one_cycle</span><br><span class="line">    /run/sleeptenmin/shell:sleep_method  =&gt; shell</span><br><span class="line">    /run/variants/one_cycle:sleep_cycles =&gt; 1</span><br><span class="line">    /run/variants/one_cycle:sleep_length =&gt; 600</span><br><span class="line"></span><br><span class="line">Variant shell-six_cycles-9e23:    /run/sleeptenmin/shell, /run/variants/six_cycles</span><br><span class="line">    /run/sleeptenmin/shell:sleep_method   =&gt; shell</span><br><span class="line">    /run/variants/six_cycles:sleep_cycles =&gt; 6</span><br><span class="line">    /run/variants/six_cycles:sleep_length =&gt; 100</span><br><span class="line"></span><br><span class="line">Variant shell-one_hundred_cycles-586f:    /run/sleeptenmin/shell, /run/variants/one_hundred_cycles</span><br><span class="line">    /run/sleeptenmin/shell:sleep_method           =&gt; shell</span><br><span class="line">    /run/variants/one_hundred_cycles:sleep_cycles =&gt; 100</span><br><span class="line">    /run/variants/one_hundred_cycles:sleep_length =&gt; 6</span><br><span class="line"></span><br><span class="line">Variant shell-six_hundred_cycles-1e84:    /run/sleeptenmin/shell, /run/variants/six_hundred_cycles</span><br><span class="line">    /run/sleeptenmin/shell:sleep_method           =&gt; shell</span><br><span class="line">    /run/variants/six_hundred_cycles:sleep_cycles =&gt; 600</span><br><span class="line">    /run/variants/six_hundred_cycles:sleep_length =&gt; 1</span><br></pre></td></tr></table></figure>
<p>您可以看到它创建了每个Multiplex域的所有可能变量,这些变量由YAML文件中的！mux标记定义,并在树视图中显示为单行(与具有值的单个节点的双行比较)。 总共它会产生每种测试的8种变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ avocado run --mux-yaml examples/tests/sleeptenmin.py.data/sleeptenmin.yaml -- passtest.py</span><br><span class="line">JOB ID     : cc7ef22654c683b73174af6f97bc385da5a0f02f</span><br><span class="line">JOB LOG    : /home/medic/avocado/job-results/job-2017-01-22T11.26-cc7ef22/job.log</span><br><span class="line"> (1/8) passtest.py:PassTest.test;builtin-one_cycle-f659: PASS (0.01 s)</span><br><span class="line"> (2/8) passtest.py:PassTest.test;builtin-six_cycles-723b: PASS (0.01 s)</span><br><span class="line"> (3/8) passtest.py:PassTest.test;builtin-one_hundred_cycles-633a: PASS (0.01 s)</span><br><span class="line"> (4/8) passtest.py:PassTest.test;builtin-six_hundred_cycles-a570: PASS (0.01 s)</span><br><span class="line"> (5/8) passtest.py:PassTest.test;shell-one_cycle-55f5: PASS (0.01 s)</span><br><span class="line"> (6/8) passtest.py:PassTest.test;shell-six_cycles-9e23: PASS (0.01 s)</span><br><span class="line"> (7/8) passtest.py:PassTest.test;shell-one_hundred_cycles-586f: PASS (0.01 s)</span><br><span class="line"> (8/8) passtest.py:PassTest.test;shell-six_hundred_cycles-1e84: PASS (0.01 s)</span><br><span class="line">RESULTS    : PASS 8 | ERROR 0 | FAIL 0 | SKIP 0 | WARN 0 | INTERRUPT 0</span><br><span class="line">JOB TIME   : 0.16 s</span><br></pre></td></tr></table></figure>
<h3 id="高级日志记录功能"><a href="#高级日志记录功能" class="headerlink" title="高级日志记录功能"></a>高级日志记录功能</h3><p>Avocado在测试运行时提供高级日志记录功能。 这些可以在测试中与标准Python库API结合使用。</p>
<p>一个常见的例子是需要在更长或更复杂的测试中遵循特定的进展。 让我们看一个非常简单的测试示例,但在单个测试中有一个多个明确的阶段：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> avocado <span class="keyword">import</span> Test</span><br><span class="line"></span><br><span class="line">progress_log = logging.getLogger(<span class="string">"progress"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plant</span><span class="params">(Test)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_plant_organic</span><span class="params">(self)</span>:</span></span><br><span class="line">        rows = self.params.get(<span class="string">"rows"</span>, default=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Preparing soil</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(rows):</span><br><span class="line">            progress_log.info(<span class="string">"%s: preparing soil on row %s"</span>,</span><br><span class="line">                              self.name, row)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Letting soil rest</span></span><br><span class="line">        progress_log.info(<span class="string">"%s: letting soil rest before throwing seeds"</span>,</span><br><span class="line">                          self.name)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Throwing seeds</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(rows):</span><br><span class="line">            progress_log.info(<span class="string">"%s: throwing seeds on row %s"</span>,</span><br><span class="line">                              self.name, row)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Let them grow</span></span><br><span class="line">        progress_log.info(<span class="string">"%s: waiting for Avocados to grow"</span>,</span><br><span class="line">                          self.name)</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Harvest them</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(rows):</span><br><span class="line">            progress_log.info(<span class="string">"%s: harvesting organic avocados on row %s"</span>,</span><br><span class="line">                              self.name, row)</span><br></pre></td></tr></table></figure>
<p>从现在开始,您可以要求Avocado显示您的日志记录流,无论是独占还是其他内置流：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ avocado --show app,progress run plant.py</span><br></pre></td></tr></table></figure>
<p>结果应类似于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">JOB ID     : af786f86db530bff26cd6a92c36e99bedcdca95b</span><br><span class="line">JOB LOG    : /home/cleber/avocado/job-results/job-2016-03-18T10.29-af786f8/job.log</span><br><span class="line"> (1/1) plant.py:Plant.test_plant_organic: progress: 1-plant.py:Plant.test_plant_organic: preparing soil on row 0</span><br><span class="line">progress: 1-plant.py:Plant.test_plant_organic: preparing soil on row 1</span><br><span class="line">progress: 1-plant.py:Plant.test_plant_organic: preparing soil on row 2</span><br><span class="line">progress: 1-plant.py:Plant.test_plant_organic: letting soil rest before throwing seeds</span><br><span class="line">-progress: 1-plant.py:Plant.test_plant_organic: throwing seeds on row 0</span><br><span class="line">progress: 1-plant.py:Plant.test_plant_organic: throwing seeds on row 1</span><br><span class="line">progress: 1-plant.py:Plant.test_plant_organic: throwing seeds on row 2</span><br><span class="line">progress: 1-plant.py:Plant.test_plant_organic: waiting for Avocados to grow</span><br><span class="line">\progress: 1-plant.py:Plant.test_plant_organic: harvesting organic avocados on row 0</span><br><span class="line">progress: 1-plant.py:Plant.test_plant_organic: harvesting organic avocados on row 1</span><br><span class="line">progress: 1-plant.py:Plant.test_plant_organic: harvesting organic avocados on row 2</span><br><span class="line">PASS (7.01 s)</span><br><span class="line">RESULTS    : PASS 1 | ERROR 0 | FAIL 0 | SKIP 0 | WARN 0 | INTERRUPT 0</span><br><span class="line">JOB TIME   : 7.11 s</span><br><span class="line">JOB HTML   : /home/cleber/avocado/job-results/job-2016-03-18T10.29-af786f8/html/results.html</span><br></pre></td></tr></table></figure>
<p>自定义<code>progress</code>流与应用程序输出结合在一起,可能适合或可能不适合您的需要或喜好。 如果你为了清楚和持久性,想把<code>progress</code>流将发送到一个单独的文件,你可以像这样运行Avocado：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ avocado run plant.py --store-logging-stream progress</span><br></pre></td></tr></table></figure>
<p>结果是,除了通常生成的所有其他日志文件之外,还会在job结果目录中有另一个名为progress.INFO的日志文件。 在测试运行期间,可以通过以下方式观察进度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ tail -f ~/avocado/job-results/latest/progress.INFO</span><br><span class="line">10:36:59 INFO | 1-plant.py:Plant.test_plant_organic: preparing soil on row 0</span><br><span class="line">10:36:59 INFO | 1-plant.py:Plant.test_plant_organic: preparing soil on row 1</span><br><span class="line">10:36:59 INFO | 1-plant.py:Plant.test_plant_organic: preparing soil on row 2</span><br><span class="line">10:36:59 INFO | 1-plant.py:Plant.test_plant_organic: letting soil rest before throwing seeds</span><br><span class="line">10:37:01 INFO | 1-plant.py:Plant.test_plant_organic: throwing seeds on row 0</span><br><span class="line">10:37:01 INFO | 1-plant.py:Plant.test_plant_organic: throwing seeds on row 1</span><br><span class="line">10:37:01 INFO | 1-plant.py:Plant.test_plant_organic: throwing seeds on row 2</span><br><span class="line">10:37:01 INFO | 1-plant.py:Plant.test_plant_organic: waiting for Avocados to grow</span><br><span class="line">10:37:06 INFO | 1-plant.py:Plant.test_plant_organic: harvesting organic avocados on row 0</span><br><span class="line">10:37:06 INFO | 1-plant.py:Plant.test_plant_organic: harvesting organic avocados on row 1</span><br><span class="line">10:37:06 INFO | 1-plant.py:Plant.test_plant_organic: harvesting organic avocados on row 2</span><br></pre></td></tr></table></figure>
<p>这个非常相似的progress logger,可以跨多个测试方法和多个测试模块使用。在给出的示例中,测试名称用于提供额外的上下文。</p>
<h3 id="unittest-TestCase继承"><a href="#unittest-TestCase继承" class="headerlink" title="unittest.TestCase继承"></a>unittest.TestCase继承</h3><p>由于Avocado测试继承了unittest.TestCase,所以可以使用其父级的所有断言方法。<br>代码示例使用 assertEqual, assertTrue 和 assertIsInstace:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> avocado <span class="keyword">import</span> Test</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomExamples</span><span class="params">(Test)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.log.debug(<span class="string">"Verifying some random math..."</span>)</span><br><span class="line">        four = <span class="number">2</span> * <span class="number">2</span></span><br><span class="line">        four_ = <span class="number">2</span> + <span class="number">2</span></span><br><span class="line">        self.assertEqual(four, four_, <span class="string">"something is very wrong here!"</span>)</span><br><span class="line"></span><br><span class="line">        self.log.debug(<span class="string">"Verifying if a variable is set to True..."</span>)</span><br><span class="line">        variable = <span class="literal">True</span></span><br><span class="line">        self.assertTrue(variable)</span><br><span class="line"></span><br><span class="line">        self.log.debug(<span class="string">"Verifying if this test is an instance of test.Test"</span>)</span><br><span class="line">        self.assertIsInstance(self, test.Test)</span><br></pre></td></tr></table></figure>
<h4 id="在其它单元测试下运行测试脚本"><a href="#在其它单元测试下运行测试脚本" class="headerlink" title="在其它单元测试下运行测试脚本"></a>在其它单元测试下运行测试脚本</h4><p>nose是另一个Python测试框架,它也与unittest兼容。<br>因此,您可以使用nosetest应用程序运行Avocado测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ nosetests examples/tests/sleeptest.py</span><br><span class="line">.</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran 1 test in 1.004s</span><br><span class="line"></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>相反,您也可以使用标准unittest.main()入口点运行Avocado测试。检查下面的代码,以保存为dummy.py：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> avocado <span class="keyword">import</span> Test</span><br><span class="line"><span class="keyword">from</span> unittest <span class="keyword">import</span> main</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dummy</span><span class="params">(Test)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertTrue(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>使用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python dummy.py</span><br><span class="line">.</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran <span class="number">1</span> test <span class="keyword">in</span> <span class="number">0.000</span>s</span><br><span class="line"></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<h3 id="Setup和cleanup方法"><a href="#Setup和cleanup方法" class="headerlink" title="Setup和cleanup方法"></a>Setup和cleanup方法</h3><p>在测试之前或之后执行setUp操作,您可以使用setUp和tearDown方法,tearDown方法总是在安装失败时执行,所以不要忘记在setUp过程中初始化变量。使用示例在下一节运行第三方测试套件中。</p>
<h3 id="运行第三方测试套件"><a href="#运行第三方测试套件" class="headerlink" title="运行第三方测试套件"></a>运行第三方测试套件</h3><p>在测试自动化工作负载中使用第三方开发的测试套件非常常见。通过在Avocado测试模块中封装执行代码,您可以访问框架提供的设施和API。假设你想用C写一个测试套件,它在一个tarball中,解压缩它,编译套件代码,然后执行测试。下面是一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> avocado <span class="keyword">import</span> Test</span><br><span class="line"><span class="keyword">from</span> avocado <span class="keyword">import</span> main</span><br><span class="line"><span class="keyword">from</span> avocado.utils <span class="keyword">import</span> archive</span><br><span class="line"><span class="keyword">from</span> avocado.utils <span class="keyword">import</span> build</span><br><span class="line"><span class="keyword">from</span> avocado.utils <span class="keyword">import</span> process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncTest</span><span class="params">(Test)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Execute the synctest test suite.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Set default params and build the synctest suite.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        sync_tarball = self.params.get(<span class="string">'sync_tarball'</span>,</span><br><span class="line">                                       default=<span class="string">'synctest.tar.bz2'</span>)</span><br><span class="line">        self.sync_length = self.params.get(<span class="string">'sync_length'</span>, default=<span class="number">100</span>)</span><br><span class="line">        self.sync_loop = self.params.get(<span class="string">'sync_loop'</span>, default=<span class="number">10</span>)</span><br><span class="line">        <span class="comment"># Build the synctest suite</span></span><br><span class="line">        self.cwd = os.getcwd()</span><br><span class="line">        tarball_path = self.get_data(sync_tarball)</span><br><span class="line">        archive.extract(tarball_path, self.workdir)</span><br><span class="line">        self.workdir = os.path.join(self.workdir, <span class="string">'synctest'</span>)</span><br><span class="line">        build.make(self.workdir)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Execute synctest with the appropriate params.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        os.chdir(self.workdir)</span><br><span class="line">        cmd = (<span class="string">'./synctest %s %s'</span> %</span><br><span class="line">               (self.sync_length, self.sync_loop))</span><br><span class="line">        process.system(cmd)</span><br><span class="line">        os.chdir(self.cwd)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>这里我们有一个setup方法的例子：这里我们通过<code>avocado.Test.get_data()</code> 得到测试套件代码(tarball)的位置。然后通过<code>avocado.utils.archive.extract()</code>解压缩<br>一个API会解压缩tarball套件,<code>avocado.utils.build.make()</code>会建立则个套件。</p>
<p>在这个例子中,测试方法刚刚进入编译的套件的基本目录,并使用<code>avocado.utils.process.system()</code>和适当的参数执行<code>./synctest</code>命令。</p>
<h3 id="获取资产文件"><a href="#获取资产文件" class="headerlink" title="获取资产文件"></a>获取资产文件</h3><h3 id="测试输出检查和输出记录模式"><a href="#测试输出检查和输出记录模式" class="headerlink" title="测试输出检查和输出记录模式"></a>测试输出检查和输出记录模式</h3><p>在很多情况下,你想变得简单：只需检查给定测试的输出是否匹配预期输出。为了帮助这个常见的用例,Avocado提供了<code>--output-check-record</code>选项</p>
<p>如果启用这个选项,Avocado将会将测试生成的内容保存到标准(POSIX)流,即<code>STDOUT</code> 和 <code>STDERR</code>.根据所选的选项,您可能会记录不同的文件(我们称之为“参考文件”)：</p>
<ul>
<li><code>stdout</code>将生成一个名为<code>stdout.expected</code>的文件,该文件包含来自测试过程标准输出流(文件描述符1)的内容。</li>
<li><code>stderr</code>将生成一个名为<code>stderr.expected</code>的文件,该文件包含来自测试过程标准错误流(文件描述符2)的内容。</li>
<li><code>both</code>将生成一个名为<code>stdout.expected</code>和一个名为<code>stderr.expected</code>的文件</li>
<li><code>combined</code>将生成一个名为<code>output.expected</code>的文件,其中包含测试过程标准输出和错误流(文件描述符1和2)的内容。</li>
<li><code>none</code>将显式禁用测试生成的输出和生成内容的生成参考文件的所有记录</li>
</ul>
<p>参考文件将被记录在第一个(最特定的)测试数据文件夹(访问测试数据文件)中。让我们以测试<code>synctest.py</code>为例。检查Avocado源代码,您可以找到以下参考文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">examples/tests/synctest.py.data/stderr.expected</span><br><span class="line">examples/tests/synctest.py.data/stdout.expected</span><br></pre></td></tr></table></figure>
<p>在这两个文件中,只有stdout.expected有些内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat examples/tests/synctest.py.data/stdout.expected</span><br><span class="line">PAR : waiting</span><br><span class="line">PASS : sync interrupted</span><br></pre></td></tr></table></figure>
<p>这意味着,在之前的测试执行期间,用<code>--output-check-record both</code>进行输出记录,并且仅在stdout流上生成内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ avocado run --output-check-record both synctest.py</span><br><span class="line">JOB ID     : b6306504351b037fa304885c0baa923710f34f4a</span><br><span class="line">JOB LOG    : $JOB_RESULTS_DIR/job-2017-11-26T16.42-b630650/job.log</span><br><span class="line"> (1/1) examples/tests/synctest.py:SyncTest.test: PASS (2.03 s)</span><br><span class="line">RESULTS    : PASS 1 | ERROR 0 | FAIL 0 | SKIP 0 | WARN 0 | INTERRUPT 0 | CANCEL 0</span><br><span class="line">JOB TIME   : 2.26 s</span><br></pre></td></tr></table></figure>
<p>在添加参考文件之后,检查过程是透明的,从某种意义上说,您不需要向test runner提供特殊标志。从这一点开始,在测试(一个带有参考文件记录的一个)完成运行之后,Avocado将检查输出是否与参考文件内容匹配。如果它们不匹配,则测试将以失败状态结束。</p>
<p>当引用文件存在时,你也可以对此测试运行程序禁用自动检查<code>--output-check=off</code>对此测试运行程序。</p>
<p>这个过程还可以也可以在简单测试,也就是返回0 (PASSed) or != 0 (FAILed)的程序或或shell脚本工作的很好。让我们考虑例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat output_record.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line">echo &quot;Hello, world!&quot;</span><br></pre></td></tr></table></figure>
<p>让我们记录下这个的输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ scripts/avocado run output_record.sh --output-check-record all</span><br><span class="line">JOB ID    : 25c4244dda71d0570b7f849319cd71fe1722be8b</span><br><span class="line">JOB LOG   : $HOME/avocado/job-results/job-2014-09-25T20.49-25c4244/job.log</span><br><span class="line"> (1/1) output_record.sh: PASS (0.01 s)</span><br><span class="line">RESULTS    : PASS 1 | ERROR 0 | FAIL 0 | SKIP 0 | WARN 0 | INTERRUPT 0</span><br><span class="line">JOB TIME   : 0.11 s</span><br></pre></td></tr></table></figure>
<p>完成此操作后,您会注意到测试数据目录出现在我们的shell脚本的同一个级别,包含2个文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls output_record.sh.data/</span><br><span class="line">stderr.expected  stdout.expected</span><br></pre></td></tr></table></figure>
<p>让我们看看它们中的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat output_record.sh.data/stdout.expected</span><br><span class="line">Hello, world!</span><br><span class="line">$ cat output_record.sh.data/stderr.expected</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>现在,每次测试运行时,程序都会自动对比记录的预期文件,我们不需要做任何其他操作。让我们看看如果把STDUT.期望的文件内容改为Hello,avocado 会发生什么呢？：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ scripts/avocado run output_record.sh</span><br><span class="line">JOB ID    : f0521e524face93019d7cb99c5765aedd933cb2e</span><br><span class="line">JOB LOG   : $HOME/avocado/job-results/job-2014-09-25T20.52-f0521e5/job.log</span><br><span class="line"> (1/1) output_record.sh: FAIL (0.02 s)</span><br><span class="line">RESULTS    : PASS 0 | ERROR 0 | FAIL 1 | SKIP 0 | WARN 0 | INTERRUPT 0</span><br><span class="line">JOB TIME   : 0.12 s</span><br></pre></td></tr></table></figure>
<p>确认失败的原因：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ cat $HOME/avocado/job-results/latest/job.log</span><br><span class="line">    2017-10-16 14:23:02,567 test             L0381 INFO | START 1-output_record.sh</span><br><span class="line">    2017-10-16 14:23:02,568 test             L0402 DEBUG| Test metadata:</span><br><span class="line">    2017-10-16 14:23:02,568 test             L0403 DEBUG|   filename: $HOME/output_record.sh</span><br><span class="line">    2017-10-16 14:23:02,596 process          L0389 INFO | Running &apos;$HOME/output_record.sh&apos;</span><br><span class="line">    2017-10-16 14:23:02,603 process          L0499 INFO | Command &apos;$HOME/output_record.sh&apos; finished with 0 after 0.00131011009216s</span><br><span class="line">    2017-10-16 14:23:02,602 process          L0479 DEBUG| [stdout] Hello, world!</span><br><span class="line">    2017-10-16 14:23:02,603 test             L1084 INFO | Exit status: 0</span><br><span class="line">    2017-10-16 14:23:02,604 test             L1085 INFO | Duration: 0.00131011009216</span><br><span class="line">    2017-10-16 14:23:02,604 test             L0274 DEBUG| DATA (filename=stdout.expected) =&gt; $HOME/output_record.sh.data/stdout.expected (found at file source dir)</span><br><span class="line">    2017-10-16 14:23:02,605 test             L0740 DEBUG| Stdout Diff:</span><br><span class="line">    2017-10-16 14:23:02,605 test             L0742 DEBUG| --- $HOME/output_record.sh.data/stdout.expected</span><br><span class="line">    2017-10-16 14:23:02,605 test             L0742 DEBUG| +++ $HOME/avocado/job-results/job-2017-10-16T14.23-8cba866/test-results/1-output_record.sh/stdout</span><br><span class="line">    2017-10-16 14:23:02,605 test             L0742 DEBUG| @@ -1 +1 @@</span><br><span class="line">    2017-10-16 14:23:02,605 test             L0742 DEBUG| -Hello, Avocado!</span><br><span class="line">    2017-10-16 14:23:02,605 test             L0742 DEBUG| +Hello, world!</span><br><span class="line">    2017-10-16 14:23:02,606 stacktrace       L0041 ERROR|</span><br><span class="line">    2017-10-16 14:23:02,606 stacktrace       L0044 ERROR| Reproduced traceback from: $HOME/git/avocado/avocado/core/test.py:872</span><br><span class="line">    2017-10-16 14:23:02,606 stacktrace       L0047 ERROR| Traceback (most recent call last):</span><br><span class="line">    2017-10-16 14:23:02,606 stacktrace       L0047 ERROR|   File &quot;$HOME/git/avocado/avocado/core/test.py&quot;, line 743, in _check_reference_stdout</span><br><span class="line">    2017-10-16 14:23:02,606 stacktrace       L0047 ERROR|     self.fail(&apos;Actual test sdtout differs from expected one&apos;)</span><br><span class="line">    2017-10-16 14:23:02,606 stacktrace       L0047 ERROR|   File &quot;$HOME//git/avocado/avocado/core/test.py&quot;, line 983, in fail</span><br><span class="line">    2017-10-16 14:23:02,607 stacktrace       L0047 ERROR|     raise exceptions.TestFail(message)</span><br><span class="line">    2017-10-16 14:23:02,607 stacktrace       L0047 ERROR| TestFail: Actual test sdtout differs from expected one</span><br><span class="line">    2017-10-16 14:23:02,607 stacktrace       L0048 ERROR|</span><br><span class="line">    2017-10-16 14:23:02,607 test             L0274 DEBUG| DATA (filename=stderr.expected) =&gt; $HOME//output_record.sh.data/stderr.expected (found at file source dir)</span><br><span class="line">    2017-10-16 14:23:02,608 test             L0965 ERROR| FAIL 1-output_record.sh -&gt; TestFail: Actual test sdtout differs from expected one</span><br></pre></td></tr></table></figure>
<p>正如预期的那样,测试失败了,因为我们改变了它的期望,因此记录了一个统一的差异。统一的差异也存在于文件<code>stdout.diff</code> 和 <code>stderr.diff</code>中,存在于测试结果目录中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat $HOME/avocado/job-results/latest/test-results/1-output_record.sh/stdout.diff</span><br><span class="line">--- $HOME/output_record.sh.data/stdout.expected</span><br><span class="line">+++ $HOME/avocado/job-results/job-2017-10-16T14.23-8cba866/test-results/1-output_record.sh/stdout</span><br><span class="line">@@ -1 +1 @@</span><br><span class="line">-Hello, Avocado!</span><br><span class="line">+Hello, world!</span><br></pre></td></tr></table></figure>
<blockquote>
<p>目前,stdout和stder都以文本方式存储。根据当前区域设置无法解码的数据将根据 <a href="https://docs.python.org/3/library/codecs.html#codecs.replace_errors" target="_blank" rel="noopener">https://docs.python.org/3/library/codecs.html#codecs.replace_errors</a> 替换</p>
</blockquote>
<h3 id="在本机Avocado模块中测试日志-stdout和stderr"><a href="#在本机Avocado模块中测试日志-stdout和stderr" class="headerlink" title="在本机Avocado模块中测试日志,stdout和stderr"></a>在本机Avocado模块中测试日志,stdout和stderr</h3><p>如果需要,可以直接从原生测试范围写入预期的stdout和stderr文件。区分以下实体是很重要的：</p>
<ul>
<li>The test logs</li>
<li>The test expected stdout 期待的标准输出</li>
<li>The test expected stderr 期待的标准错误</li>
</ul>
<p>第一个是用于调试和输出信息的目的。另外,写入<code>self.log.warning</code>会导致测试被标记为dirty,当一切顺利时,测试以警告结束。这意味着测试通过了,但是在警告日志中描述了非相关的意外情况。</p>
<p>您可以使用<code>avocado.test.log</code>类属性中的方法将一些日志记录到测试日志中。考虑这个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">output_test</span><span class="params">(Test)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.log.info(<span class="string">'This goes to the log and it is only informational'</span>)</span><br><span class="line">        self.log.warn(<span class="string">'Oh, something unexpected, non-critical happened, '</span></span><br><span class="line">                      <span class="string">'but we can continue.'</span>)</span><br><span class="line">        self.log.error(<span class="string">'Describe the error here and don\'t forget to raise '</span></span><br><span class="line">                       <span class="string">'an exception yourself. Writing to self.log.error '</span></span><br><span class="line">                       <span class="string">'won\'t do that for you.'</span>)</span><br><span class="line">        self.log.debug(<span class="string">'Everybody look, I had a good lunch today...'</span>)</span><br></pre></td></tr></table></figure>
<p>如果您需要直接写入测试stdout和stderr流,Avocado使两个预先配置的日志记录器可用于此目的,名为<code>avocado.test.stdout</code>和<code>avocado.test.stderr</code>。可以使用Python的标准日志API来对它们进行写入。例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">output_test</span><span class="params">(Test)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></span><br><span class="line">        stdout = logging.getLogger(<span class="string">'avocado.test.stdout'</span>)</span><br><span class="line">        stdout.info(<span class="string">'Informational line that will go to stdout'</span>)</span><br><span class="line">        ...</span><br><span class="line">        stderr = logging.getLogger(<span class="string">'avocado.test.stderr'</span>)</span><br><span class="line">        stderr.info(<span class="string">'Informational line that will go to stderr'</span>)</span><br></pre></td></tr></table></figure>
<p>Avocado将自动保存测试在STDUT中生成的任何东西到stdout文件中,在测试结果目录中找到。这同样适用于测试在STDRR上生成的任何东西,也就是说,它将被保存到同一个位置的stderr文件中。</p>
<p>此外,当使用runner的输出记录特性,即<code>--output-check-record</code>参数值stdout, stderr或者all时,所有给这些记录器的所有内容都将保存到文<code>stdout.expected</code>和<code>stderr.expected</code>在测试数据目录中(与<code>job/test results</code>不同)。</p>
<h3 id="设置测试超时"><a href="#设置测试超时" class="headerlink" title="设置测试超时"></a>设置测试超时</h3><p>有时您的测试套件/测试可能会被永久卡住,这可能会影响测试网格。您可以解释这种可能性,并为测试设置超时参数。测试超时可以通过测试参数来设置,如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sleep_length: 5</span><br><span class="line">timeout: 3</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ avocado run sleeptest.py --mux-yaml /tmp/sleeptest-example.yaml</span><br><span class="line">JOB ID     : c78464bde9072a0b5601157989a99f0ba32a288e</span><br><span class="line">JOB LOG    : $HOME/avocado/job-results/job-2016-11-02T11.13-c78464b/job.log</span><br><span class="line"> (1/1) sleeptest.py:SleepTest.test: INTERRUPTED (3.04 s)</span><br><span class="line">RESULTS    : PASS 0 | ERROR 0 | FAIL 0 | SKIP 0 | WARN 0 | INTERRUPT 1</span><br><span class="line">JOB TIME   : 3.14 s</span><br><span class="line">JOB HTML   : $HOME/avocado/job-results/job-2016-11-02T11.13-c78464b/html/results.html</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$ cat $HOME/avocado/job-results/job-2016-11-02T11.13-c78464b/job.log</span><br><span class="line">2016-11-02 11:13:01,133 job              L0384 INFO | Multiplex tree representation:</span><br><span class="line">2016-11-02 11:13:01,133 job              L0386 INFO |  \-- run</span><br><span class="line">2016-11-02 11:13:01,133 job              L0386 INFO |         -&gt; sleep_length: 5</span><br><span class="line">2016-11-02 11:13:01,133 job              L0386 INFO |         -&gt; timeout: 3</span><br><span class="line">2016-11-02 11:13:01,133 job              L0387 INFO |</span><br><span class="line">2016-11-02 11:13:01,134 job              L0391 INFO | Temporary dir: /var/tmp/avocado_PqDEyC</span><br><span class="line">2016-11-02 11:13:01,134 job              L0392 INFO |</span><br><span class="line">2016-11-02 11:13:01,134 job              L0399 INFO | Variant 1:    /run</span><br><span class="line">2016-11-02 11:13:01,134 job              L0402 INFO |</span><br><span class="line">2016-11-02 11:13:01,134 job              L0311 INFO | Job ID: c78464bde9072a0b5601157989a99f0ba32a288e</span><br><span class="line">2016-11-02 11:13:01,134 job              L0314 INFO |</span><br><span class="line">2016-11-02 11:13:01,345 sysinfo          L0107 DEBUG| Not logging /proc/pci (file does not exist)</span><br><span class="line">2016-11-02 11:13:01,351 sysinfo          L0105 DEBUG| Not logging /proc/slabinfo (lack of permissions)</span><br><span class="line">2016-11-02 11:13:01,355 sysinfo          L0107 DEBUG| Not logging /sys/kernel/debug/sched_features (file does not exist)</span><br><span class="line">2016-11-02 11:13:01,388 sysinfo          L0388 INFO | Commands configured by file: /etc/avocado/sysinfo/commands</span><br><span class="line">2016-11-02 11:13:01,388 sysinfo          L0399 INFO | Files configured by file: /etc/avocado/sysinfo/files</span><br><span class="line">2016-11-02 11:13:01,388 sysinfo          L0419 INFO | Profilers configured by file: /etc/avocado/sysinfo/profilers</span><br><span class="line">2016-11-02 11:13:01,388 sysinfo          L0427 INFO | Profiler disabled</span><br><span class="line">2016-11-02 11:13:01,394 multiplexer      L0166 DEBUG| PARAMS (key=timeout, path=*, default=None) =&gt; 3</span><br><span class="line">2016-11-02 11:13:01,395 test             L0216 INFO | START 1-sleeptest.py:SleepTest.test</span><br><span class="line">2016-11-02 11:13:01,396 multiplexer      L0166 DEBUG| PARAMS (key=sleep_length, path=*, default=1) =&gt; 5</span><br><span class="line">2016-11-02 11:13:01,396 sleeptest        L0022 DEBUG| Sleeping for 5.00 seconds</span><br><span class="line">2016-11-02 11:13:04,411 stacktrace       L0038 ERROR|</span><br><span class="line">2016-11-02 11:13:04,412 stacktrace       L0041 ERROR| Reproduced traceback from: $HOME/src/avocado/avocado/core/test.py:454</span><br><span class="line">2016-11-02 11:13:04,412 stacktrace       L0044 ERROR| Traceback (most recent call last):</span><br><span class="line">2016-11-02 11:13:04,413 stacktrace       L0044 ERROR|   File &quot;/usr/share/doc/avocado/tests/sleeptest.py&quot;, line 23, in test</span><br><span class="line">2016-11-02 11:13:04,413 stacktrace       L0044 ERROR|     time.sleep(sleep_length)</span><br><span class="line">2016-11-02 11:13:04,413 stacktrace       L0044 ERROR|   File &quot;$HOME/src/avocado/avocado/core/runner.py&quot;, line 293, in sigterm_handler</span><br><span class="line">2016-11-02 11:13:04,413 stacktrace       L0044 ERROR|     raise SystemExit(&quot;Test interrupted by SIGTERM&quot;)</span><br><span class="line">2016-11-02 11:13:04,414 stacktrace       L0044 ERROR| SystemExit: Test interrupted by SIGTERM</span><br><span class="line">2016-11-02 11:13:04,414 stacktrace       L0045 ERROR|</span><br><span class="line">2016-11-02 11:13:04,414 test             L0459 DEBUG| Local variables:</span><br><span class="line">2016-11-02 11:13:04,440 test             L0462 DEBUG|  -&gt; self &lt;class &apos;sleeptest.SleepTest&apos;&gt;: 1-sleeptest.py:SleepTest.test</span><br><span class="line">2016-11-02 11:13:04,440 test             L0462 DEBUG|  -&gt; sleep_length &lt;type &apos;int&apos;&gt;: 5</span><br><span class="line">2016-11-02 11:13:04,440 test             L0592 ERROR| ERROR 1-sleeptest.py:SleepTest.test -&gt; TestError: SystemExit(&apos;Test interrupted by SIGTERM&apos;,): Test interrupted by SIGTERM</span><br></pre></td></tr></table></figure>
<p>YAML文件定义了一个测试参数超时,它在运行程序结束之前,通过发送一个类<code>:signal.SIGTERM</code>到测试,raise错误<code>avocado.core.exceptions.TestTimeoutError</code>,从而提高了测试速度。</p>
<h3 id="跳过测试"><a href="#跳过测试" class="headerlink" title="跳过测试"></a>跳过测试</h3><p>要在Avocado中跳过测试,必须使用Avocado跳过装饰器中的一种：</p>
<ul>
<li><a href="mailto:`@avocado.skip" target="_blank" rel="noopener">`@avocado.skip</a>(reason)`: 跳过测试.</li>
<li><a href="mailto:`@avocado.skipIf" target="_blank" rel="noopener">`@avocado.skipIf</a>(condition, reason)<code>: 跳过测试如果条件为</code>True`.</li>
<li><a href="mailto:`@avocado.skipUnless" target="_blank" rel="noopener">`@avocado.skipUnless</a>(condition, reason)<code>: 跳过测试如果条件为</code>False`</li>
</ul>
<p>这些装饰器可以同时使用<code>setup</code>方法和<code>Test*()</code>方法中使用。测试如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> avocado</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span><span class="params">(avocado.Test)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @avocado.skipIf(1 == 1, 'Skipping on True condition.')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @avocado.skip("Don't want this test now.")</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @avocado.skipUnless(1 == 1, 'Skipping on False condition.')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test3</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>将产生以下结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ avocado run  test_skip_decorators.py</span><br><span class="line">JOB ID     : <span class="number">59</span>c815f6a42269daeaf1e5b93e52269fb8a78119</span><br><span class="line">JOB LOG    : $HOME/avocado/job-results/job<span class="number">-2017</span><span class="number">-02</span><span class="number">-03</span>T17<span class="number">.41</span><span class="number">-59</span>c815f/job.log</span><br><span class="line"> (<span class="number">1</span>/<span class="number">3</span>) test_skip_decorators.py:MyTest.test1: SKIP</span><br><span class="line"> (<span class="number">2</span>/<span class="number">3</span>) test_skip_decorators.py:MyTest.test2: SKIP</span><br><span class="line"> (<span class="number">3</span>/<span class="number">3</span>) test_skip_decorators.py:MyTest.test3: PASS (<span class="number">0.02</span> s)</span><br><span class="line">RESULTS    : PASS <span class="number">1</span> | ERROR <span class="number">0</span> | FAIL <span class="number">0</span> | SKIP <span class="number">2</span> | WARN <span class="number">0</span> | INTERRUPT <span class="number">0</span></span><br><span class="line">JOB TIME   : <span class="number">0.13</span> s</span><br><span class="line">JOB HTML   : $HOME/avocado/job-results/job<span class="number">-2017</span><span class="number">-02</span><span class="number">-03</span>T17<span class="number">.41</span><span class="number">-59</span>c815f/html/results.html</span><br></pre></td></tr></table></figure>
<p>注意,由于提供的条件不是false,所以没有跳过Test3。</p>
<p>使用跳过装饰器,实际上没有执行任何操作。我们将跳过<code>setup</code>方法、测试方法和<code>teardown</code>方法。</p>
<blockquote>
<p>任何skip装饰器都不能在teardown方法上使用,否则会出现错误,状态吗为<code>ERROR</code></p>
</blockquote>
<h3 id="取消测试"><a href="#取消测试" class="headerlink" title="取消测试"></a>取消测试</h3><p>您可以在测试的任何阶段(<code>setup()</code>、测试方法或<code>teardown</code>)中调用<code>self.cancel()</code>取消测试。测试将以取消状态结束,并且不会使job以非0状态退出。例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> avocado <span class="keyword">import</span> Test</span><br><span class="line"><span class="keyword">from</span> avocado <span class="keyword">import</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> avocado.utils.process <span class="keyword">import</span> run</span><br><span class="line"><span class="keyword">from</span> avocado.utils.software_manager <span class="keyword">import</span> SoftwareManager</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CancelTest</span><span class="params">(Test)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Example tests that cancel the current test from inside the test.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        sm = SoftwareManager()</span><br><span class="line">        self.pkgs = sm.list_all(software_components=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_iperf</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'iperf-2.0.8-6.fc25.x86_64'</span> <span class="keyword">not</span> <span class="keyword">in</span> self.pkgs:</span><br><span class="line">            self.cancel(<span class="string">'iperf is not installed or wrong version'</span>)</span><br><span class="line">        self.assertIn(<span class="string">'pthreads'</span>,</span><br><span class="line">                      run(<span class="string">'iperf -v'</span>, ignore_status=<span class="literal">True</span>).stderr)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_gcc</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'gcc-6.3.1-1.fc25.x86_64'</span> <span class="keyword">not</span> <span class="keyword">in</span> self.pkgs:</span><br><span class="line">            self.cancel(<span class="string">'gcc is not installed or wrong version'</span>)</span><br><span class="line">        self.assertIn(<span class="string">'enable-gnu-indirect-function'</span>,</span><br><span class="line">                      run(<span class="string">'gcc -v'</span>, ignore_status=<span class="literal">True</span>).stderr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>在缺少IPRF包但系统安装在正确版本中的系统中,结果将是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JOB ID     : 39c1f120830b9769b42f5f70b6b7bad0b1b1f09f</span><br><span class="line">JOB LOG    : $HOME/avocado/job-results/job-2017-03-10T16.22-39c1f12/job.log</span><br><span class="line"> (1/2) /home/apahim/avocado/tests/test_cancel.py:CancelTest.test_iperf: CANCEL (1.15 s)</span><br><span class="line"> (2/2) /home/apahim/avocado/tests/test_cancel.py:CancelTest.test_gcc: PASS (1.13 s)</span><br><span class="line">RESULTS    : PASS 1 | ERROR 0 | FAIL 0 | SKIP 0 | WARN 0 | INTERRUPT 0 | CANCEL 1</span><br><span class="line">JOB TIME   : 2.38 s</span><br><span class="line">JOB HTML   : $HOME/avocado/job-results/job-2017-03-10T16.22-39c1f12/html/results.html</span><br></pre></td></tr></table></figure>
<p>注意,使用<code>self.cancel()</code>将从该点取消其余的测试,但是<code>teardown()</code>仍将被执行。</p>
<p>根据您所提到的结果格式,取消状态被映射到相应格式的有效状态。见下表：</p>
<table>
<thead>
<tr>
<th>Format</th>
<th>Corresponding Status</th>
</tr>
</thead>
<tbody>
<tr>
<td>json</td>
<td>cancel</td>
</tr>
<tr>
<td>xunit</td>
<td>skipped</td>
</tr>
<tr>
<td>tap</td>
<td>ok</td>
</tr>
<tr>
<td>html</td>
<td>CANCEL (warning)</td>
</tr>
</tbody>
</table>
<h3 id="Docstring指令"><a href="#Docstring指令" class="headerlink" title="Docstring指令"></a>Docstring指令</h3><p>一些Avododo特性,通常只适用于仪器化测试,依赖于在测试类的DoScord中设置指令。DOXString指令由标记(<code>:avocado:</code>)组成,接着是自定义内容本身,如<code>:avocado: directive</code>。</p>
<p>这与DoScript指令类似,例如<code>:param my_param: description</code>对于大多数Python开发人员来说,这应该不是一个意外。</p>
<p>Avocado使用这些DOSCRON指令(而不是真正的Python代码)的原因是,在寻找测试时进行的检查不涉及代码的任何执行。</p>
<p>有关DoScript格式的有效性的详细解释,请参阅我们关于DOSCSHIPE指令规则的章节。</p>
<p>现在让我们继续使用一些DoScript指令示例。</p>
<h4 id="显式启用或禁用测试"><a href="#显式启用或禁用测试" class="headerlink" title="显式启用或禁用测试"></a>显式启用或禁用测试</h4><p>如果您的测试是直接从<code>avocado.Test</code>继承的类中的一个方法,那么avocado会像预期的那样找到它。</p>
<p>现在,可能需要更复杂的测试,使用更先进的Python特性,例如继承。对于那些不直接从<code>avocado.Test</code>中继承的测试,Avocado可能需要你的帮助,因为Avocado只使用静态分析来检查文件。</p>
<p>例如,假设您定义了一个新的测试类,该类继承了avocado基础测试类,即<code>avocado.Test</code>,并将其放入<code>mylibrary.py</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> avocado <span class="keyword">import</span> Test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyOwnDerivedTest</span><span class="params">(Test)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, methodName=<span class="string">'test'</span>, name=None, params=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 base_logdir=None, job=None, runner_queue=None)</span>:</span></span><br><span class="line">        super(MyOwnDerivedTest, self).__init__(methodName, name, params,</span><br><span class="line">                                               base_logdir, job,</span><br><span class="line">                                               runner_queue)</span><br><span class="line">        self.log(<span class="string">'Derived class example'</span>)</span><br></pre></td></tr></table></figure>
<p>然后在<code>mytest.py</code>中使用该派生类实现实际测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mylibrary</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span><span class="params">(mylibrary.MyOwnDerivedTest)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.log(<span class="string">'Testing something important'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.log(<span class="string">'Testing something even more important'</span>)</span><br></pre></td></tr></table></figure>
<p>如果您试图列出该文件中的测试,这将是您将得到的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">scripts/avocado list mytest.py -V</span><br><span class="line">Type       Test      Tag(s)</span><br><span class="line">NOT_A_TEST mytest.py</span><br><span class="line"></span><br><span class="line">TEST TYPES SUMMARY</span><br><span class="line">==================</span><br><span class="line">ACCESS_DENIED: 0</span><br><span class="line">BROKEN_SYMLINK: 0</span><br><span class="line">EXTERNAL: 0</span><br><span class="line">FILTERED: 0</span><br><span class="line">INSTRUMENTED: 0</span><br><span class="line">MISSING: 0</span><br><span class="line">NOT_A_TEST: 1</span><br><span class="line">SIMPLE: 0</span><br><span class="line">VT: 0</span><br></pre></td></tr></table></figure>
<p>你需要通过添加一个docstring指令来给Avocado一点帮助。docstring指令是：<code>:avocado: enable</code>。它告诉Avocado安全测试检测代码,将其视为Avocado试验,而不管检测代码对它的看法如何。让我们看看效果如何。添加docstring,如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mylibrary</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span><span class="params">(mylibrary.MyOwnDerivedTest)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :avocado: enable</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.log(<span class="string">'Testing something important'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.log(<span class="string">'Testing something even more important'</span>)</span><br></pre></td></tr></table></figure>
<p>再次尝试列出该文件中的测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">scripts/avocado list mytest.py -V</span><br><span class="line">Type         Test                   Tag(s)</span><br><span class="line">INSTRUMENTED mytest.py:MyTest.test1</span><br><span class="line">INSTRUMENTED mytest.py:MyTest.test2</span><br><span class="line"></span><br><span class="line">TEST TYPES SUMMARY</span><br><span class="line">==================</span><br><span class="line">ACCESS_DENIED: 0</span><br><span class="line">BROKEN_SYMLINK: 0</span><br><span class="line">EXTERNAL: 0</span><br><span class="line">FILTERED: 0</span><br><span class="line">INSTRUMENTED: 2</span><br><span class="line">MISSING: 0</span><br><span class="line">NOT_A_TEST: 0</span><br><span class="line">SIMPLE: 0</span><br><span class="line">VT: 0</span><br></pre></td></tr></table></figure>
<p>您还可以使用：<code>avocado:disable</code>的docstring指令,相反的工作方式：将被一个Avocado测试强制视为非avocado测试。</p>
<p><code>:avocado: disable</code>指令首先被Avocado评估,这意味着,如果<code>:avocado: disable</code> 和 <code>:avocado: enable</code>同时出现的话,测试将不会被列出。</p>
<h4 id="递归发现测试"><a href="#递归发现测试" class="headerlink" title="递归发现测试"></a>递归发现测试</h4><p>除了<code>:avocado: disable</code> 和 <code>:avocado: enable</code>指令,Avocado还支持<code>:avocado: recursive</code></p>
<h4 id="分类测试"><a href="#分类测试" class="headerlink" title="分类测试"></a>分类测试</h4><h3 id="Python-unittest兼容性限制和警告"><a href="#Python-unittest兼容性限制和警告" class="headerlink" title="Python unittest兼容性限制和警告"></a>Python unittest兼容性限制和警告</h3><h3 id="测试的环境变量"><a href="#测试的环境变量" class="headerlink" title="测试的环境变量"></a>测试的环境变量</h3><p>Avocado将一些信息(包括测试参数)作为环境变量导出到正在运行的测试中。</p>
<p>虽然这些变量可用于所有测试,但它们通常对SIMPLE测试更有意义。 原因是SIMPLE测试无法直接使用Avocado API。 INSTRUMENTED测试通常会有更强大的方法来访问相同的信息。</p>
<ul>
<li><code>AVOCADO_VERSION</code>: Avocado测试运行器的版本</li>
<li><code>VOCADO_TEST_BASEDIR</code>:Avocado测试的基本目录</li>
<li><code>AVOCADO_TEST_WORKDIR</code>:测试的工作目录</li>
<li><code>AVOCADO_TESTS_COMMON_TMPDIR</code>:teststmpdir插件创建的临时目录。该目录在同一个Job中的整个测试中是持久的</li>
<li><code>AVOCADO_TEST_LOGDIR</code>：日志目录</li>
<li><code>AVOCADO_TEST_LOGFILE</code>: 测试的日志文件</li>
<li><code>AVOCADO_TEST_OUTPUTDIR</code>:测试的输出目录</li>
<li><code>AVOCADO_TEST_SYSINFODIR</code>：系统信息目录</li>
<li><code>***</code>: 来自-mux-yaml的所有变量<blockquote>
<p><code>AVOCADO_TEST_SRCDIR</code>存在于早期版本中,但在版本60.0上已弃用,在版本62.0上已删除。请改用<code>AVOCADO_TEST_WORKDIR</code>。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><code>AVOCADO_TEST_DATADIR</code>存在于早期版本中,但在版本60.0上已弃用,在版本62.0上已删除。现在,测试数据文件(和目录)已动态评估,不可用作环境变量</p>
</blockquote>
<h3 id="SIMPLE测试BASH扩展"><a href="#SIMPLE测试BASH扩展" class="headerlink" title="SIMPLE测试BASH扩展"></a>SIMPLE测试BASH扩展</h3><p>用shell编写的SIMPLE测试可以使用一些Avocado实用程序。 在shell代码中,检查库是否可用,例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVOCADO_SHELL_EXTENSIONS_DIR=$(avocado exec-path 2&gt;/dev/null)</span><br></pre></td></tr></table></figure>
<p>如果可用,将包含这些实用程序的目录注入shell使用的PATH,使这些实用程序易于访问：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ $? == 0 ]; then</span><br><span class="line">  PATH=$AVOCADO_SHELL_EXTENSIONS_DIR:$PATH</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>有关实用程序的完整列表,请查看目录返回通过<code>avocado exec-path</code>(如果有的话)。 另外,示例测试<code>examples/tests/ simplewarning.sh</code>可以提供进一步的灵感。</p>
<blockquote>
<p>这些扩展可以作为单独的包提供。 对于RPM包,请查找bash子包。</p>
</blockquote>
<h3 id="简单的测试状态"><a href="#简单的测试状态" class="headerlink" title="简单的测试状态"></a>简单的测试状态</h3><p>通过SIMPLE测试,Avocado会检查测试的退出代码,以确定测试是否已通过或已失败。</p>
<p>如果您的测试以退出代码0退出,但您仍希望在某些条件下设置不同的测试状态,则Avocado可以在测试输出中搜索给定的正则表达式,并在此基础上将状态设置为WARN或SKIP。</p>
<p>要使用该功能,您必须在配置文件中设置正确的密钥。 例如,当测试输出类似：’11：08：24 Test Skipped’：所示的行时,将测试状态设置为SKIP</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[simpletests.output]</span><br><span class="line">skip_regex = ^\d\d:\d\d:\d\d Test Skipped$</span><br></pre></td></tr></table></figure>
<p>该配置将使Avocado在stdout和stderr上搜索Python正则表达式。 如果您只想限制其中一个搜索,那么该配置还有另一个键：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[simpletests.output]</span><br><span class="line">skip_regex = ^\d\d:\d\d:\d\d Test Skipped$</span><br><span class="line">skip_location = stderr</span><br></pre></td></tr></table></figure>
<p>WARN状态存在相同的设置。 例如,如果要在测试输出以字符串WARNING开头的行时将测试状态设置为WARN,则配置文件将如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[simpletests.output]</span><br><span class="line">skip_regex = ^\d\d:\d\d:\d\d Test Skipped$</span><br><span class="line">skip_location = stderr</span><br><span class="line">warn_regex = ^WARNING:</span><br><span class="line">warn_location = all</span><br></pre></td></tr></table></figure>
<h3 id="本文小节"><a href="#本文小节" class="headerlink" title="本文小节"></a>本文小节</h3><p>我们建议您查看一下中的示例测试<code>examples/tests</code>目录,这个目录包含一些样本以从中获取灵感。。 除了包含示例之外,该目录也被使用Avocado自测套件可对Avocado进行功能测试。<br>也可以查看<a href="https://github.com/avocado-framework-tests" target="_blank" rel="noopener">https://github.com/avocado-framework-tests</a>,它允许人们分享他们的基本系统测试,以从中获取灵感。</p>
<h2 id="结果格式化"><a href="#结果格式化" class="headerlink" title="结果格式化"></a><a href="https://avocado-framework.readthedocs.io/en/63.0/ResultFormats.html" target="_blank" rel="noopener">结果格式化</a></h2><p>测试脚本必须提供各种方法来清晰地将结果传达给相关方,无论是人还是机器。</p>
<blockquote>
<p>有几个可选的结果插件,你可以在Result Plugins中找到它们。</p>
</blockquote>
<h3 id="人类可读结果"><a href="#人类可读结果" class="headerlink" title="人类可读结果"></a>人类可读结果</h3><p>Avocado有两种不同的结果格式,供人类使用：</p>
<ul>
<li>默认UI,它在命令行上显示基于文本UI的实况测试执行结果。</li>
<li>HTML报告,它是在测试任务完成后生成的。</li>
</ul>
<p>Avocado的命令行界面</p>
<p>定期运行Avocado将以生动的方式呈现测试结果,也就是说,工作和测试结果不断更新：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ avocado run sleeptest.py failtest.py synctest.py</span><br><span class="line">JOB ID    : 5ffe479262ea9025f2e4e84c4e92055b5c79bdc9</span><br><span class="line">JOB LOG   : $HOME/avocado/job-results/job-2014-08-12T15.57-5ffe4792/job.log</span><br><span class="line"> (1/3) sleeptest.py:SleepTest.test: PASS (1.01 s)</span><br><span class="line"> (2/3) failtest.py:FailTest.test: FAIL (0.00 s)</span><br><span class="line"> (3/3) synctest.py:SyncTest.test: PASS (1.98 s)</span><br><span class="line">RESULTS    : PASS 1 | ERROR 1 | FAIL 1 | SKIP 0 | WARN 0 | INTERRUPT 0</span><br><span class="line">JOB TIME   : 3.27 s</span><br><span class="line">JOB HTML  : $HOME/avocado/job-results/job-2014-08-12T15.57-5ffe4792/html/results.html</span><br></pre></td></tr></table></figure>
<p>最重要的是要记住,程序不需要分析人的输出来确定测试工作运行的情况。</p>
<h3 id="机器可读结果"><a href="#机器可读结果" class="headerlink" title="机器可读结果"></a>机器可读结果</h3><p>另一种类型的结果是那些被其他应用程序解析的结果。测试社区中存在若干标准,Avocado在理论上可以支持几乎所有的结果标准。</p>
<p>非常好,Avocado支持一些机器可读的结果。它们总是生成并存储在结果目录中。$Type文件,但是您也可以要求不同的位置。</p>
<h4 id="xunit"><a href="#xunit" class="headerlink" title="xunit"></a>xunit</h4><p>Avocado默认的机器可读输出是xunit</p>
<p>xunit是以结构化形式包含测试结果的XML格式,并由其他测试自动化项目(Jenkins)使用。如果你想让Avocado在runner的标准输出中生成xunit作为输出,可以简单地使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ avocado run sleeptest.py failtest.py synctest.py --xunit -</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;testsuite name=&quot;avocado&quot; tests=&quot;3&quot; errors=&quot;0&quot; failures=&quot;1&quot; skipped=&quot;0&quot; time=&quot;3.5769162178&quot; timestamp=&quot;2016-05-04 14:46:52.803365&quot;&gt;</span><br><span class="line">        &lt;testcase classname=&quot;SleepTest&quot; name=&quot;1-sleeptest.py:SleepTest.test&quot; time=&quot;1.00204920769&quot;/&gt;</span><br><span class="line">        &lt;testcase classname=&quot;FailTest&quot; name=&quot;2-failtest.py:FailTest.test&quot; time=&quot;0.00120401382446&quot;&gt;</span><br><span class="line">                &lt;failure type=&quot;TestFail&quot; message=&quot;This test is supposed to fail&quot;&gt;&lt;![CDATA[Traceback (most recent call last):</span><br><span class="line">  File &quot;/home/medic/Work/Projekty/avocado/avocado/avocado/core/test.py&quot;, line 490, in _run_avocado</span><br><span class="line">    raise test_exception</span><br><span class="line">TestFail: This test is supposed to fail</span><br><span class="line">]]&gt;&lt;/failure&gt;</span><br><span class="line">                &lt;system-out&gt;&lt;![CDATA[14:46:53 ERROR|</span><br><span class="line">14:46:53 ERROR| Reproduced traceback from: /home/medic/Work/Projekty/avocado/avocado/avocado/core/test.py:435</span><br><span class="line">14:46:53 ERROR| Traceback (most recent call last):</span><br><span class="line">14:46:53 ERROR|   File &quot;/home/medic/Work/Projekty/avocado/avocado/examples/tests/failtest.py&quot;, line 17, in test</span><br><span class="line">14:46:53 ERROR|     self.fail(&apos;This test is supposed to fail&apos;)</span><br><span class="line">14:46:53 ERROR|   File &quot;/home/medic/Work/Projekty/avocado/avocado/avocado/core/test.py&quot;, line 585, in fail</span><br><span class="line">14:46:53 ERROR|     raise exceptions.TestFail(message)</span><br><span class="line">14:46:53 ERROR| TestFail: This test is supposed to fail</span><br><span class="line">14:46:53 ERROR|</span><br><span class="line">14:46:53 ERROR| FAIL 2-failtest.py:FailTest.test -&gt; TestFail: This test is supposed to fail</span><br><span class="line">14:46:53 INFO |</span><br><span class="line">]]&gt;&lt;/system-out&gt;</span><br><span class="line">        &lt;/testcase&gt;</span><br><span class="line">        &lt;testcase classname=&quot;SyncTest&quot; name=&quot;3-synctest.py:SyncTest.test&quot; time=&quot;2.57366299629&quot;/&gt;</span><br><span class="line">&lt;/testsuite&gt;</span><br></pre></td></tr></table></figure>
<p>最后的<code>-</code>是xunit的选项,表示xunit应该转到标准输出</p>
<p>如果你的测试产生了很长的输出,你可以用 –xunit-max-test-log-chars 来限制嵌入字符的数量。如果日志文件中的输出较长,则只从最大值开始附加到最大测试日志字符,另一半从内容的结尾开始。</p>
<h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>JSON是一种广泛使用的数据交换格式,JSON avocado插件使用类似于xunit使用方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">$ avocado run sleeptest.py failtest.py synctest.py --json -</span><br><span class="line">&#123;</span><br><span class="line">    &quot;cancel&quot;: 0,</span><br><span class="line">    &quot;debuglog&quot;: &quot;/home/cleber/avocado/job-results/job-2016-08-09T13.53-10715c4/job.log&quot;,</span><br><span class="line">    &quot;errors&quot;: 0,</span><br><span class="line">    &quot;failures&quot;: 1,</span><br><span class="line">    &quot;job_id&quot;: &quot;10715c4645d2d2b57889d7a4317fcd01451b600e&quot;,</span><br><span class="line">    &quot;pass&quot;: 2,</span><br><span class="line">    &quot;skip&quot;: 0,</span><br><span class="line">    &quot;tests&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;end&quot;: 1470761623.176954,</span><br><span class="line">            &quot;fail_reason&quot;: &quot;None&quot;,</span><br><span class="line">            &quot;logdir&quot;: &quot;/home/cleber/avocado/job-results/job-2016-08-09T13.53-10715c4/test-results/1-sleeptest.py:SleepTest.test&quot;,</span><br><span class="line">            &quot;logfile&quot;: &quot;/home/cleber/avocado/job-results/job-2016-08-09T13.53-10715c4/test-results/1-sleeptest.py:SleepTest.test/debug.log&quot;,</span><br><span class="line">            &quot;start&quot;: 1470761622.174918,</span><br><span class="line">            &quot;status&quot;: &quot;PASS&quot;,</span><br><span class="line">            &quot;id&quot;: &quot;1-sleeptest.py:SleepTest.test&quot;,</span><br><span class="line">            &quot;time&quot;: 1.0020360946655273,</span><br><span class="line">            &quot;whiteboard&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;end&quot;: 1470761623.193472,</span><br><span class="line">            &quot;fail_reason&quot;: &quot;This test is supposed to fail&quot;,</span><br><span class="line">            &quot;logdir&quot;: &quot;/home/cleber/avocado/job-results/job-2016-08-09T13.53-10715c4/test-results/2-failtest.py:FailTest.test&quot;,</span><br><span class="line">            &quot;logfile&quot;: &quot;/home/cleber/avocado/job-results/job-2016-08-09T13.53-10715c4/test-results/2-failtest.py:FailTest.test/debug.log&quot;,</span><br><span class="line">            &quot;start&quot;: 1470761623.192334,</span><br><span class="line">            &quot;status&quot;: &quot;FAIL&quot;,</span><br><span class="line">            &quot;id&quot;: &quot;2-failtest.py:FailTest.test&quot;,</span><br><span class="line">            &quot;time&quot;: 0.0011379718780517578,</span><br><span class="line">            &quot;whiteboard&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;end&quot;: 1470761625.656061,</span><br><span class="line">            &quot;fail_reason&quot;: &quot;None&quot;,</span><br><span class="line">            &quot;logdir&quot;: &quot;/home/cleber/avocado/job-results/job-2016-08-09T13.53-10715c4/test-results/3-synctest.py:SyncTest.test&quot;,</span><br><span class="line">            &quot;logfile&quot;: &quot;/home/cleber/avocado/job-results/job-2016-08-09T13.53-10715c4/test-results/3-synctest.py:SyncTest.test/debug.log&quot;,</span><br><span class="line">            &quot;start&quot;: 1470761623.208165,</span><br><span class="line">            &quot;status&quot;: &quot;PASS&quot;,</span><br><span class="line">            &quot;id&quot;: &quot;3-synctest.py:SyncTest.test&quot;,</span><br><span class="line">            &quot;time&quot;: 2.4478960037231445,</span><br><span class="line">            &quot;whiteboard&quot;: &quot;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;time&quot;: 3.4510700702667236,</span><br><span class="line">    &quot;total&quot;: 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请记住,没有AvocadoJSON结果格式的文档标准。这意味着它可能会逐渐增加,以适应更新的Avocado特性。适当的工作解析JSON构成的结果将不会破坏与应用程序的向后兼容性。</p>
<h4 id="TAP"><a href="#TAP" class="headerlink" title="TAP"></a>TAP</h4><p>提供当前在V12版本的基本TAP(测试任何协议)结果。不像大多数现有Avocado机器可读的输出,这一个是流线型(每个测试结果)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ avocado run sleeptest.py --tap -</span><br><span class="line">1..1</span><br><span class="line"># debug.log of sleeptest.py:SleepTest.test:</span><br><span class="line">#   12:04:38 DEBUG| PARAMS (key=sleep_length, path=*, default=1) =&gt; 1</span><br><span class="line">#   12:04:38 DEBUG| Sleeping for 1.00 seconds</span><br><span class="line">#   12:04:39 INFO | PASS 1-sleeptest.py:SleepTest.test</span><br><span class="line">#   12:04:39 INFO |</span><br><span class="line">ok 1 sleeptest.py:SleepTest.test</span><br></pre></td></tr></table></figure>
<blockquote>
<p>译者 debug.log不会显示在控制台,需要到debug.log中去查看<br>cat ~/avocado/job-results/latest/test-results/1-sleeptest.py_SleepTest.test/debug.log</p>
</blockquote>
<h4 id="Silent-result"><a href="#Silent-result" class="headerlink" title="Silent result"></a>Silent result</h4><p>此结果禁用所有stdout日志记录(同时将错误消息打印到stderr)。然后,可以使用返回代码来了解结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ avocado --silent run failtest.py</span><br><span class="line">$ echo $?</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>在实践中,这通常会被脚本用来运行avocado,并检查其结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">...</span><br><span class="line">$ avocado --silent run /path/to/my/test.py</span><br><span class="line">if [ $? == 0 ]; then</span><br><span class="line">   echo &quot;great success!&quot;</span><br><span class="line">elif</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>
<p>关于退出代码中的退出代码的更多细节部分。</p>
<h3 id="一次获得多个结果"><a href="#一次获得多个结果" class="headerlink" title="一次获得多个结果"></a>一次获得多个结果</h3><p>只要只有一个使用标准输出,就可以同时拥有多个结果格式。例如,使用xunit结果输出到stdout并将json结果输出到文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ avocado run sleeptest.py synctest.py --xunit - --json /tmp/result.json</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;testsuite name=&quot;avocado&quot; tests=&quot;2&quot; errors=&quot;0&quot; failures=&quot;0&quot; skipped=&quot;0&quot; time=&quot;3.64848303795&quot; timestamp=&quot;2016-05-04 17:26:05.645665&quot;&gt;</span><br><span class="line">        &lt;testcase classname=&quot;SleepTest&quot; name=&quot;1-sleeptest.py:SleepTest.test&quot; time=&quot;1.00270605087&quot;/&gt;</span><br><span class="line">        &lt;testcase classname=&quot;SyncTest&quot; name=&quot;2-synctest.py:SyncTest.test&quot; time=&quot;2.64577698708&quot;/&gt;</span><br><span class="line">&lt;/testsuite&gt;</span><br><span class="line"></span><br><span class="line">$ cat /tmp/result.json</span><br><span class="line">&#123;</span><br><span class="line">     &quot;debuglog&quot;: &quot;/home/cleber/avocado/job-results/job-2016-08-09T13.55-1a94ad6/job.log&quot;,</span><br><span class="line">     &quot;errors&quot;: 0,</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是如果没有传递给程序的 -json 项,您将无法做到这一点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ avocado run sleeptest.py synctest.py --xunit - --json -</span><br><span class="line">Options --json --xunit are trying to use stdout simultaneously</span><br><span class="line">Please set at least one of them to a file to avoid conflicts</span><br></pre></td></tr></table></figure>
<p>这基本上是你需要遵循唯一,理智的的规则。</p>
<h3 id="退出码"><a href="#退出码" class="headerlink" title="退出码"></a>退出码</h3><p>Avocado退出代码试图代表在执行过程中可能发生的不同事情。这意味着退出代码作为一个单独的退出代码可以是和代码组合在一起。最后的退出代码可以取消绑定,这样用户就可以对工作发生的事情有一个很好的了解。</p>
<p>示例如下:</p>
<ul>
<li><code>AVOCADO_ALL_OK (0)</code></li>
<li><code>AVOCADO_TESTS_FAIL (1)</code></li>
<li><code>AVOCADO_JOB_FAIL (2)</code></li>
<li><code>AVOCADO_FAIL (4)</code></li>
<li><code>AVOCADO_JOB_INTERRUPTED (8)</code></li>
</ul>
<p>举个例子,如果一个job以退出代码9结束,它意味着我们至少有一个测试失败了,而且我们在某个时候有一个job中断,这可能是由于job超时或CTRL+C造成的。</p>
<h3 id="实现其他结果格式"><a href="#实现其他结果格式" class="headerlink" title="实现其他结果格式"></a>实现其他结果格式</h3><p>如果你想实现一种新的机器或人类可读的输出格式,你可以参考<code>avocado.plugins.xunit</code>并使用它作为起点。</p>
<p>f你的结果是一次生成的,基于完整的工作结果,你应该创建一个继承<code>avocado.core.plugin_interfaces.Result</code>接口的新类。并实现<code>avocado.core.plugin_interfaces.Result.render()</code>方法。</p>
<p>但是,如果您的结果实现是在测试之前/期间/测试之后输出信息,就要看一看<code>avocado.core.plugin_interfaces.ResultEvents</code>. 它将要求您实现对job和测试执行中的每个定义的事件执行操作(写入文件/流)的方法。</p>
<p>你可以看看插件系统,了解更多关于如何编写插件的信息,这些插件将激活和执行新的结果格式。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a><a href="https://avocado-framework.readthedocs.io/en/63.0/Configuration.html" target="_blank" rel="noopener">配置</a></h2><p>关于如何使用户喜欢使用他们的系统,Avocado有一些基于训练,合理的(我们希望)猜测的默认行为。</p>
<p>当然,不同的人会有不同的需求和/或不喜欢我们的默认值,这就是为什么可以用配置系统来帮助这些案例的原因。</p>
<p>Avocado配置文件格式是基于(非正式)INI文件的“规范”,它由Python的配置分析器实现。分段组成,格式简单明了,包含多个键和值。以一个基本的Avocado配置文件为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[datadir.paths]</span><br><span class="line">base_dir = /var/lib/avocado</span><br><span class="line">test_dir = /usr/share/doc/avocado/tests</span><br><span class="line">data_dir = /var/lib/avocado/data</span><br><span class="line">logs_dir = ~/avocado/job-results</span><br></pre></td></tr></table></figure>
<p>datadir.paths部分包含多个键,它们都与测试工具使用的目录相关。<code>base_dir</code>是其他重要Avocado目录的基础目录,如日志、数据和测试目录。您还可以通过变量<code>test_dir</code>、<code>data_dir</code>和<code>logs_dir</code>选择设置其他重要目录。您可以通过简单编辑可用的配置文件来实现这一点。</p>
<h3 id="配置文件解析顺序"><a href="#配置文件解析顺序" class="headerlink" title="配置文件解析顺序"></a>配置文件解析顺序</h3><p>Avocado开始解析它所称的系统范围配置文件<code>/etc/avocado/avocado.conf</code>,该文件被传输到全系统目录中的所有Avocado用户.然后,它将验证是否存在一个本地用户配置文件,该文件通常位于<code>~/.config/avocado/avocado.conf</code>.解析的顺序很重要,所以首先系统范围的文件被解析,然后用户配置文件最后被解析,这样用户可以随意重写值。还有另一个目录将被额外配置文件扫描,<code>/etc/avocado/conf.d</code>.该目录可能包含插件配置文件,以及系统管理员/Avocado开发人员可能判断需要放置的额外附加配置文件。</p>
<p>请注意,对于基本目录,如果您选择了不能被Avocado正确使用的目录(一些目录需要读访问、其他读取和写入访问),Avocado将回落到一些默认值。因此,如果您的普通权限用户想将日志写入到<code>/root/avocado/logs</code>,Avocado将不能使用该目录,因为它无法将文件写入该位置。默认情况下,将选择一个新的位置<code>~/avocado/job-results</code>。</p>
<p>本节中描述的文件顺序仅在Avocado安装在系统中才有效。对于使用Git仓库(通常是Avocado开发人员)的Avocado来说,并没有安装在系统中,请记住Avocado将读取Git仓库中存在的配置文件,并且将忽略系统范围配置文件。执行<code>avocado config</code>会让你之道哪些config文件正在实际使用。</p>
<h3 id="插件配置文件"><a href="#插件配置文件" class="headerlink" title="插件配置文件"></a>插件配置文件</h3><p>插件也可以通过配置文件来配置。为了不干扰主Avocado配置文件,如果希望的话,这些插件可以安装附加配置文件<code>/etc/avocado/conf.d/[pluginname].conf</code>这将在系统范围配置文件之后进行解析。用户也可以在本地配置文件级别上重写这些值。思考假想插件<code>salad</code>的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[salad.core]</span><br><span class="line">base = ceasar</span><br><span class="line">dressing = ceasar</span><br></pre></td></tr></table></figure>
<p>如果需要,可以通过在本地配置文件中简单地添加[salad.core]新部分来更改配置文件中的<code>dressing</code>,并在其中设置不同的值。</p>
<h3 id="解析顺序重述"><a href="#解析顺序重述" class="headerlink" title="解析顺序重述"></a>解析顺序重述</h3><p>因此,文件解析顺序为：</p>
<ul>
<li><code>/etc/avocado/avocado.conf</code></li>
<li><code>/etc/avocado/conf.d/*.conf</code></li>
<li><code>~/.config/avocado/avocado.conf</code></li>
</ul>
<p>按此顺序,意味着您在本地配置文件上设置的内容可以覆盖系统范围文件中定义的内容。</p>
<blockquote>
<p>请注意,如果Avocado从Git 仓库中运行,这些文件将被忽略,并被配置树文件取代。这通常只会影响开发Avocado的人,如果你有疑问,<code>avocado config</code>会告诉你确切的文件在任何特定的情况下都被使用。</p>
</blockquote>
<h3 id="测试中使用的值的优先顺序"><a href="#测试中使用的值的优先顺序" class="headerlink" title="测试中使用的值的优先顺序"></a>测试中使用的值的优先顺序</h3><p>由于可以使用配置系统来改变测试中使用的行为和值(例如,对测试程序的思考路径),所以我们建立了以下变量优先级顺序(从最小优先级到大多数)：</p>
<ul>
<li>缺省值(来自库或测试代码)</li>
<li>全局配置文件</li>
<li>本地(用户)配置文件</li>
<li>命令行开关</li>
<li>试验参数</li>
</ul>
<p>因此,最不重要的值来自库或测试代码默认值,一直到测试参数系统。</p>
<h3 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件"></a>配置插件</h3><p>一个配置插件被提供给希望快速查看在Avocado配置的所有部分中定义的用户,在所有文件以正确的解析顺序解析之后。例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ avocado config</span><br><span class="line">Config files read (in order):</span><br><span class="line">    /etc/avocado/avocado.conf</span><br><span class="line">    $HOME/.config/avocado/avocado.conf</span><br><span class="line"></span><br><span class="line">    Section.Key     Value</span><br><span class="line">    runner.base_dir /var/lib/avocado</span><br><span class="line">    runner.test_dir /usr/share/doc/avocado/tests</span><br><span class="line">    runner.data_dir /var/lib/avocado/data</span><br><span class="line">    runner.logs_dir ~/avocado/job-results</span><br></pre></td></tr></table></figure>
<p>该命令还显示了解析配置文件的顺序,让您更好地了解正在发生的事情。关键术语在<code>git config --list output</code>得到启发。</p>
<h3 id="Avocado数据目录"><a href="#Avocado数据目录" class="headerlink" title="Avocado数据目录"></a>Avocado数据目录</h3><p>当运行测试时,我们往往希望：</p>
<ul>
<li>定位测试</li>
<li>将日志写入给定位置</li>
<li>抓取对测试有用的文件,例如ISO文件或VM磁盘映像</li>
</ul>
<p>Avocado拥有一个专门用于寻找这些路径的模块,以避免人们在以前的测试框架中不得不做的繁琐的路径操作。</p>
<p>如果要列出所有有关测试的目录,可以使用Avocado<code>avocado config --datadir</code>命令列出这些目录。执行它会给你一个类似于下面看到的输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ avocado config --datadir</span><br><span class="line">Config files read (in order):</span><br><span class="line">    /etc/avocado/avocado.conf</span><br><span class="line">    $HOME/.config/avocado/avocado.conf</span><br><span class="line"></span><br><span class="line">Avocado replaces config dirs that can&apos;t be accessed</span><br><span class="line">with sensible defaults. Please edit your local config</span><br><span class="line">file to customize values</span><br><span class="line"></span><br><span class="line">Avocado Data Directories:</span><br><span class="line">    base  $HOME/avocado</span><br><span class="line">    tests $HOME/Code/avocado/examples/tests</span><br><span class="line">    data  $HOME/avocado/data</span><br><span class="line">    logs  $HOME/avocado/job-results</span><br></pre></td></tr></table></figure>
<p>注意,虽然Avocado将尽最大努力使用配置文件中提供的配置值,如果它不能将值写入所提供的位置,它将回落到(我们希望)合理的默认值,并且我们在命令的输出中通知用户。相关的API文档和每个数据目录的含义都是在<code>avocado.core.data_dir</code>中,所以强烈建议您查看一下。</p>
<p>您可以通过将它们设置在Avocado配置文件中来设置首选数据文件夹。这里的重要数据文件夹的唯一例外是AvocadoTMP DIR,用来放置测试所使用的临时文件。该目录将在正常情况下<code>/var/tmp/avocado_XXXXX</code>,(XXXXX实际上是一个随机字符串)安全地创建在<code>/var/tmp/</code>上,除非用户有$TMPDIR环境变量集,因为这是UNIX程序中惯用的。</p>
<p>文档的下一部分说明了如何查看和设置修改Avocado实用工具和插件的行为的配置值。</p>
<h2 id="测试发现"><a href="#测试发现" class="headerlink" title="测试发现"></a><a href="https://avocado-framework.readthedocs.io/en/63.0/Loaders.html" target="_blank" rel="noopener">测试发现</a></h2><p>在本节中,您可以了解测试是如何被发现的以及如何影响这个过程。</p>
<h3 id="测试loader的顺序"><a href="#测试loader的顺序" class="headerlink" title="测试loader的顺序"></a>测试loader的顺序</h3><p>Avocado支持不同类型的测试.从简单的测试开始,它是简单的可执行文件,然后是unitest-like测试,称为INSTRUMENTED,如avocado-vt的,它使用复杂的矩阵测试配置文件不直接映射到现有的文件。给定装载器的数量,从命令行上的测试名称到执行的测试的映射可能并不总是唯一的。另外,有些人可能总是(或给定的运行)希望只执行单个类型的测试。</p>
<p>为了调整这种行为,你可以在avocado设置(<code>/etc/avocado/</code>)中调整<code>plugins.loaders</code>,或暂时使用<code>--loaders</code>(Avocado运行选项)选项。</p>
<p>此选项允许您指定可用的测试加载器的顺序和一些参数。您可以指定<code>loader_name(file)</code>、 <code>loader_name + TEST_TYPE (file.SIMPLE)</code>,并且对于某些loaders,甚至附加的参数也会通过<code>: (external:/bin/echo -e</code>,您也可以提供<code>@DEFAULT</code>,它将所有剩余的未使用的loaders注入到该位置。</p>
<p><code>--loaders</code> 如何影响生成的测试(手动收集,因为其中一些会导致错误)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ avocado run passtest.py boot this_does_not_exist /bin/echo</span><br><span class="line">    &gt; INSTRUMENTED passtest.py:PassTest.test</span><br><span class="line">    &gt; VT           io-github-autotest-qemu.boot</span><br><span class="line">    &gt; MISSING      this_does_not_exist</span><br><span class="line">    &gt; SIMPLE       /bin/echo</span><br><span class="line">$ avocado run passtest.py boot this_does_not_exist /bin/echo --loaders @DEFAULT &quot;external:/bin/echo -e&quot;</span><br><span class="line">    &gt; INSTRUMENTED passtest.py:PassTest.test</span><br><span class="line">    &gt; VT           io-github-autotest-qemu.boot</span><br><span class="line">    &gt; EXTERNAL     this_does_not_exist</span><br><span class="line">    &gt; SIMPLE       /bin/echo</span><br><span class="line">$ avocado run passtest.py boot this_does_not_exist /bin/echo --loaders file.SIMPLE file.INSTRUMENTED @DEFAULT external.EXTERNAL:/bin/echo</span><br><span class="line">    &gt; INSTRUMENTED passtest.py:PassTest.test</span><br><span class="line">    &gt; VT           io-github-autotest-qemu.boot</span><br><span class="line">    &gt; EXTERNAL     this_does_not_exist</span><br><span class="line">    &gt; SIMPLE       /bin/echo</span><br></pre></td></tr></table></figure>
<h3 id="使用参数运行简单测试"><a href="#使用参数运行简单测试" class="headerlink" title="使用参数运行简单测试"></a>使用参数运行简单测试</h3><p>这个过去通过运行<code>avocado run &quot;test arg1 arg2&quot;</code>提供了现有的支持,但是它的确是很混乱并且已经被删除。但它仍然可以通过使用shell来实现,甚至可以将正常测试和参数化的测试结合起来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avocado run --loaders file external:/bin/sh -- existing_file.py &quot;&apos;/bin/echo something&apos;&quot; nonexisting-file</span><br></pre></td></tr></table></figure>
<p>这将运行3个测试,第一个测试是由existing_file.py定义的正常测试(很可能是一个仪器化测试)。然后我们将通过<code>/bin/sh -c &#39;/bin/echo something&#39;</code>执行<code>/bin/echo someting</code>。最后一个将是<code>nonexisting-file</code>,它将执行<code>/bin/sh -c nonexisting-file</code>,这很可能会失败的。</p>
<p>请注意,您负责引用测试ID(请参阅”‘/bin/echo something’”示例)。</p>
<h3 id="通过标签过滤测试"><a href="#通过标签过滤测试" class="headerlink" title="通过标签过滤测试"></a>通过标签过滤测试</h3><p>Avocado允许测试提供标签,可以用来创建测试类别。使用标签集,用户可以选择由测试解析器(也称为测试加载器)找到的测试的子集。有关测试标记的更多信息,请访问 <a href="https://avocado-framework.readthedocs.io/en/63.0/WritingTests.html#categorizing-tests" target="_blank" rel="noopener">WritingTests.html#categorizing-tests</a>。</p>
<h3 id="测试引用-Test-References"><a href="#测试引用-Test-References" class="headerlink" title="测试引用 Test References"></a>测试引用 Test References</h3><p>测试引用是一个字符串,可以通过Avocado测试解析器解析为(解释为)一个或多个测试。</p>
<p>每个解析器(a.k.a加载器)可以不同地处理测试引用。例如,外部加载器将使用测试引用作为外部命令的参数,而文件加载器将期望文件路径。</p>
<p>如果不指定要使用的加载器,则所有可用的加载器将用于解析所提供的测试引用。一个接一个地,测试引用将由第一个加载程序解决,该第一个加载程序能够从该引用中创建测试列表。</p>
<p>下面你可以找到一些具体的内置Avocado装载机的细节。对于通过插件(VT, Robot…)引入Avocado的装载机,请参阅相应的加载 loader/plugin 文档。</p>
<h4 id="文件加载器"><a href="#文件加载器" class="headerlink" title="文件加载器"></a>文件加载器</h4><p>对于文件加载器,加载器负责发现 INSTRUMENTED, PyUNITTEST(经典Python UNITTEST)和SIMPLE测试。</p>
<p>如果文件对应于 INSTRUMENTED 或 PyUNITTEST,可以通过在测试引用后面添加<code>：</code>,来筛选测试ID,<code>：</code>后面是正则表达式。</p>
<p>例如,如果您想列出所有在gdbtest.py文件中存在的测试,可以使用下面的列表命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ avocado list /usr/share/doc/avocado/tests/gdbtest.py</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/gdbtest.py:GdbTest.test_start_exit</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/gdbtest.py:GdbTest.test_existing_commands_raw</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/gdbtest.py:GdbTest.test_existing_commands</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/gdbtest.py:GdbTest.test_load_set_breakpoint_run_exit_raw</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/gdbtest.py:GdbTest.test_load_set_breakpoint_run_exit</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/gdbtest.py:GdbTest.test_generate_core</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/gdbtest.py:GdbTest.test_set_multiple_break</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/gdbtest.py:GdbTest.test_disconnect_raw</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/gdbtest.py:GdbTest.test_disconnect</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/gdbtest.py:GdbTest.test_remote_exec</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/gdbtest.py:GdbTest.test_stream_messages</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/gdbtest.py:GdbTest.test_connect_multiple_clients</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/gdbtest.py:GdbTest.test_server_exit</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/gdbtest.py:GdbTest.test_multiple_servers</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/gdbtest.py:GdbTest.test_interactive</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/gdbtest.py:GdbTest.test_interactive_args</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/gdbtest.py:GdbTest.test_exit_status</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/gdbtest.py:GdbTest.test_server_stderr</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/gdbtest.py:GdbTest.test_server_stdout</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/gdbtest.py:GdbTest.test_interactive_stdout</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/gdbtest.py:GdbTest.test_remote</span><br></pre></td></tr></table></figure>
<p>若要筛选结果,只列出在测试方法名称中具有test_interactive的测试,则可以执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ avocado list /usr/share/doc/avocado/tests/gdbtest.py:test_interactive</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/gdbtest.py:GdbTest.test_interactive</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/gdbtest.py:GdbTest.test_interactive_args</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/gdbtest.py:GdbTest.test_interactive_stdout</span><br></pre></td></tr></table></figure>
<p><code>：</code>之后的字符串是正则表达式,三个测试被过滤进去。您可以操作正则表达式,使其具有确切名称的测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ avocado list /usr/share/doc/avocado/tests/gdbtest.py:test_interactive$</span><br><span class="line">INSTRUMENTED /usr/share/doc/avocado/tests/gdbtest.py:GdbTest.test_interactive</span><br></pre></td></tr></table></figure>
<p>一旦测试引用提供了预期的结果,您就可以用Run子命令替换列表子命令来执行测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ avocado run /usr/share/doc/avocado/tests/gdbtest.py:GdbTest.test_[le].*raw</span><br><span class="line">JOB ID     : 333912fb02698ed5339a400b832795a80757b8af</span><br><span class="line">JOB LOG    : $HOME/avocado/job-results/job-2017-06-14T14.54-333912f/job.log</span><br><span class="line"> (1/2) /usr/share/doc/avocado/tests/gdbtest.py:GdbTest.test_existing_commands_raw: PASS (0.59 s)</span><br><span class="line"> (2/2) /usr/share/doc/avocado/tests/gdbtest.py:GdbTest.test_load_set_breakpoint_run_exit_raw: PASS (0.42 s)</span><br><span class="line">RESULTS    : PASS 2 | ERROR 0 | FAIL 0 | SKIP 0 | WARN 0 | INTERRUPT 0 | CANCEL 0</span><br><span class="line">JOB TIME   : 1.15 s</span><br><span class="line">JOB HTML   : $HOME/avocado/job-results/job-2017-06-14T14.54-333912f/html/results.html</span><br></pre></td></tr></table></figure>
<blockquote>
<p>特别是在使用正则表达式时,建议单独用引号包裹测试引用,以避免损坏它们。在这种情况下,上述示例的命令将是：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avocado run &quot;/usr/share/doc/avocado/tests/gdbtest.py:GdbTest.test_[le].*raw&quot;</span><br></pre></td></tr></table></figure>
<h4 id="外部加载器"><a href="#外部加载器" class="headerlink" title="外部加载器"></a>外部加载器</h4><p>使用External Loader, Avocado 会考虑它,External<br>Runner 将会就位,所以Avocado不会真的去解析这个引用. 相反,Avocaddo将把引用作为参数传递给这个External Runner. 示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ avocado run 20</span><br><span class="line">Unable to resolve reference(s) &apos;20&apos; with plugins(s) &apos;file&apos;, &apos;robot&apos;,</span><br><span class="line">&apos;vt&apos;, &apos;external&apos;, try running &apos;avocado list -V 20&apos; to see the details.</span><br></pre></td></tr></table></figure>
<p>在上面的命令中,没有加载程序可以将<code>20</code>解析为一个测试.但是在上面的命令中台添加一个 External Runner <code>/bin/sleep</code> 将会使 Avocado 执行 <code>/bin/sleep 20</code> 并且检查它返回的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ avocado run 20 --loaders external:/bin/sleep</span><br><span class="line">JOB ID     : 42215ece2894134fb9379ee564aa00f1d1d6cb91</span><br><span class="line">JOB LOG    : $HOME/avocado/job-results/job-2017-06-19T11.17-42215ec/job.log</span><br><span class="line"> (1/1) 20: PASS (20.03 s)</span><br><span class="line">RESULTS    : PASS 1 | ERROR 0 | FAIL 0 | SKIP 0 | WARN 0 | INTERRUPT 0 | CANCEL 0</span><br><span class="line">JOB TIME   : 20.13 s</span><br><span class="line">JOB HTML   : $HOME/avocado/job-results/job-2017-06-19T11.17-42215ec/html/results.html</span><br></pre></td></tr></table></figure>
<p>将测试引用放在命令行的末尾, 在一个 – 之后更安全. 这将避免争论与测试引用冲突。在这种情况下,之后的所有内容都将被视为位置参数。考虑以上语法, 上个例子的命令是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avocado run --loaders external:/bin/sleep -- 20</span><br></pre></td></tr></table></figure>
<h2 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a><a href="https://avocado-framework.readthedocs.io/en/63.0/LoggingSystem.html" target="_blank" rel="noopener">日志系统</a></h2><p>本节介绍日志系统在Avocado和Avocado试验中的应用。</p>
<h3 id="调整UI"><a href="#调整UI" class="headerlink" title="调整UI"></a>调整UI</h3><p>Avocado使用Python的日志系统来生成UI并存储测试输出。该系统非常灵活,允许您通过内置流集或直接使用流名称来调整输出到您的需求。要调整它们,可以使用 <code>avocado -–show STREAM[:LEVEL][,STREAM[:LEVEL],…] run ...</code>。具有描述的内置流(随后是相关联的Python流列表)：</p>
<p>app:    基于文本的UI (avocado.app)<br>test:   执行测试的输出 (avocado.test, “”)<br>debug:  用于调试avocado的附加消息 (avocado.app.debug)<br>remote: Fabric/paramiko 调试消息,用于分析远程执行 (avocado.fabric, paramiko)<br>early:  在日志记录系统设置之前进行早期日志记录。它包括测试输出和由使用的库产生的大量输出 (“”, avocado.test)</p>
<p>另外,您可以指定“全部”或“否”来启用/禁用所有预定义流,还可以提供自定义Python日志流,并将它们传递到标准输出。</p>
<h3 id="存储自定义日志"><a href="#存储自定义日志" class="headerlink" title="存储自定义日志"></a>存储自定义日志</h3><p>当您运行测试时,您还可以通过<code>avocado run –store-logging-stream [STREAM[:LEVEL] [STREAM[:LEVEL] …]]</code>将自定义日志流存储到结果目录中,它将在测试结果目录中生成每一个(唯一的)条目的<code>$STREAM.$LEVEL</code>文件。</p>
<blockquote>
<p>必须指定分离的日志流。在这个函数中不能使用内置流。</p>
</blockquote>
<blockquote>
<p>目前,自定义流仅存储在每个job中,而不是针对每个单独的测试。</p>
</blockquote>
<h3 id="分页器"><a href="#分页器" class="headerlink" title="分页器"></a>分页器</h3><p>一些子命令(列表,插件,…)支持”paginator”,在兼容的终端上,基本上将有色输出管道设置为较少,以简化生成的输出的浏览。可以通过–paginator {on|off}.禁用它。</p>
<h2 id="sysinfo收集"><a href="#sysinfo收集" class="headerlink" title="sysinfo收集"></a><a href="https://avocado-framework.readthedocs.io/en/63.0/Sysinfo.html" target="_blank" rel="noopener">sysinfo收集</a></h2><p>Avocado附带一个sysinfo插件,它自动收集每个系统的系统信息,甚至在测试之间。当我们想知道是什么导致测试失败是这是非常有用的。这个系统是可配置的,但是我们为您提供了一组明智的默认值。</p>
<p>在 Avocado 默认配置 <code>/etc/avocado/avocado.conf</code>有一节<code>sysinfo.collect</code>您可以在其中启用/禁用sysinfo集合以及配置基本环境。在<code>sysinfo.collectibles</code>节中,您可以定义在何处寻找sysinfo 集合之前/期间执行哪些命令/任务的基本路径。Avocado支持三种类型的任务：</p>
<ul>
<li>command: 用新行分隔的命令列表,在job/test之前和之后执行命令(单执行命令)。可以通过在[sysinfo.collect]中设置commands_timeout为正数来为每个执行命令所执行的超时。</li>
<li>file: 使用新行分隔的文件列表,表示要复制的文件</li>
<li>profilers: 文件具有新的行分隔的命令列表,在job/test之前执行并在job/test结束时被杀死(类似命令)</li>
</ul>
<p>此外,这个插件试图通过<code>journalctl</code>跟踪系统日志,如果可用的话。</p>
<p>默认情况下,每个job都会收集这些数据,但也可以通过在<code>sysinfo.collect</code>节中设置<code>per_test = True</code>在每个test中运行它们。</p>
<p>如果需要的话,也可以在命令行上通过<code>--sysinfo on|off</code>来启用/禁用sysinfo。</p>
<p>job执行后,您可以在<code>$RESULTS/test-results/$TEST/sysinfo</code>的<code>$RESULTS/sysinfo</code>找到所收集的信息,它被分类为前、后和概要文件夹,文件名是安全地执行命令或文件名。当您启用HTML结果插件时,还可以在HTML结果中看到sysinfo。</p>
<blockquote>
<p>如果使用源代码的Avocado,则需要手动放置<code>commands/files/profilers</code>到<code>/etc/avocado/sysinfo</code>或者调整<code>$AVOCADO_SRC/etc/avocado/avocado.conf</code>的路径</p>
</blockquote>
<blockquote>
<p>译者: 使用pip 安装的配置文件在诸如<code>/usr/lib/python3.6/site-packages/avocado/etc/avocado/avocado.conf</code>路径中,真实路径可以使用<code>avocado config</code>命令进行查询</p>
</blockquote>
<h2 id="测试参数"><a href="#测试参数" class="headerlink" title="测试参数"></a><a href="https://avocado-framework.readthedocs.io/en/63.0/TestParameters.html" target="_blank" rel="noopener">测试参数</a></h2><p>本节详细介绍了哪些测试参数以及整个变体机制在Avocado中的工作原理。 如果您对基础知识感兴趣,请参阅Yaml_to_mux插件中的示例访问测试参数或实际视图。</p>
<p>Avocado允许将参数传递给测试,这有效地导致每个测试的几种不同变体。 这些参数在(test)的<code>self.params</code>中可用,并且是<code>avocado.core.varianter.AvocadoParams</code>类型。</p>
<p><code>self.params</code>的数据由<code>avocado.core.varianter.Varianter</code>提供,它会询问所有已注册的插件的变体,或者在没有定义变体时使用默认值。</p>
<p>params处理如何工作的总体情况是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">    +-----------+</span><br><span class="line">    |           |  // Test使用variant来生成AvocadoParams</span><br><span class="line">    |   Test    |</span><br><span class="line">    |           |</span><br><span class="line">    +-----^-----+</span><br><span class="line">          |  // 将单个变量传递给测试</span><br><span class="line">          |</span><br><span class="line">    +-----------+</span><br><span class="line">    |  Runner   |  // 迭代测试和变量来运行所有</span><br><span class="line">    +-----^-----+  // 由“--execution-order”指定的所需组合</span><br><span class="line">          |</span><br><span class="line">          |</span><br><span class="line">+-------------------+     提供变量      +-----------------------+</span><br><span class="line">|                   |&lt;-----------------|                       |</span><br><span class="line">| Varianter API     |                  | Varianter plugins API |</span><br><span class="line">|                   |-----------------&gt;|                       |</span><br><span class="line">+-------------------+    更新默认值     +-----------------------+</span><br><span class="line">          ^                                ^</span><br><span class="line">          |                                |</span><br><span class="line">          |  // 默认参数注入                |  // 调用所有插件</span><br><span class="line">+--------------------------------------+   |  // 轮流</span><br><span class="line">| +--------------+ +-----------------+ |   |</span><br><span class="line">| | avocado-virt | | other providers | |   |</span><br><span class="line">| +--------------+ +-----------------+ |   |</span><br><span class="line">+--------------------------------------+   |</span><br><span class="line">                                           |</span><br><span class="line">              +----------------------------+-----+</span><br><span class="line">              |                                  |</span><br><span class="line">              |                                  |</span><br><span class="line">              v                                  v</span><br><span class="line">    +--------------------+           +-------------------------+</span><br><span class="line">    | yaml_to_mux plugin |           | Other variant plugin(s) |</span><br><span class="line">    +-----^--------------+           +-------------------------+</span><br><span class="line">          |</span><br><span class="line">          |  // yaml 被解析为 MuxTree,</span><br><span class="line">          |  // multiplexed and yields variants</span><br><span class="line">    +---------------------------------+</span><br><span class="line">    | +------------+ +--------------+ |</span><br><span class="line">    | | --mux-yaml | | --mux-inject | |</span><br><span class="line">    | +------------+ +--------------+ |</span><br><span class="line">    +---------------------------------+</span><br></pre></td></tr></table></figure>
<p>我们来介绍一下基本的关键词。</p>
<h3 id="TreeNode"><a href="#TreeNode" class="headerlink" title="TreeNode"></a>TreeNode</h3><p><code>avocado.core.tree.TreeNode</code></p>
<p>节点对象是否允许使用parent-&gt; multiple_children关系创建树状结构并存储参数。 它还可以报告它的环境,这是从根到此节点收集的一组参数。 这用于测试,而不是传递完整树,只传递叶节点,它们的环境代表树的所有值</p>
<h3 id="AvocadoParams"><a href="#AvocadoParams" class="headerlink" title="AvocadoParams"></a>AvocadoParams</h3><p><code>avocado.core.varianter.AvocadoParams</code></p>
<p>在每个(instrumented)Avocado测试中存在params的“数据库”。 它是在avocado.core.test.Test的<strong>init</strong>期间,从变量中生成的。 它接受TreeNode对象列表; 测试名称<code>avocado.core.test.TestID</code>(用于记录目的)和默认路径列表(参数路径)。</p>
<p>在测试中,它允许使用以下方法查询数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.params.get($name, $path=None, $default=None)</span><br></pre></td></tr></table></figure>
<ul>
<li>name - 参数名称(键)</li>
<li>path - 查找此参数的位置(未指定时使用mux-path)</li>
<li>default - 找不到param时返回的内容(默认值)</li>
</ul>
<p>每个变量都定义了一个层次结构,该层次结构会被保留,因此AvocadoParams跟随它以返回最合适的值或在出错时引发异常。</p>
<h3 id="参数路径-Parameter-Paths"><a href="#参数路径-Parameter-Paths" class="headerlink" title="参数路径 Parameter Paths"></a>参数路径 Parameter Paths</h3><p>由于测试参数在树中组织,因此可以在多个位置具有相同的变量。 当它们从同一个TreeNode生成时,它不是问题,但是当它们是不同的值时,无法区分应报告的内容。 一种方法是在询问参数时使用特定路径,但有时候,通常在组合上游和下游变体时,我们希望首先得到我们的值,然后在找不到它们时回退到上游值。</p>
<p>例如,假设我们在<code>/upstream/sleeptest</code>中有上游值,并且在<code>/downstream/sleeptest</code>中也有值。 如果我们使用路径”<em>“询问值,则会引发异常,因为程序无法区分是否需要来自”/downstream”或”/upstream”的值。 我们可以将参数路径设置为[“/downstream/</em>“,”/upstream/<em>“]以使所有相对调用(以</em>开头的路径)首先查看/downstream中的节点,如果未找到则查看/ upstream。</p>
<h3 id="Variant"><a href="#Variant" class="headerlink" title="Variant"></a>Variant</h3><p>Variant是由Varianter_s生成的一组参数,并由测试运行员作为“params”参数传递给测试。 最简单的变体是<code>None</code>,它仍然会生成一个空的<code>AvocadoParams</code>。 此外,变量也可以是元组(列表,路径)或只是带有参数的<code>avocado.core.tree.TreeNode</code>列表。</p>
<h3 id="Dumping-Loading-Variants"><a href="#Dumping-Loading-Variants" class="headerlink" title="Dumping/Loading Variants"></a>Dumping/Loading Variants</h3><p>根据参数的数量,生成变量可能非常耗费计算量。 由于变量是作为作业执行的一部分生成的,因此计算密集型任务将由被测系统执行,从而导致这些系统上可能不需要的CPU负载。</p>
<p>为了避免这种情况,您可以获取由变量计算生成的生成的JSON序列化变体文件,并将该文件加载到将执行作业的系统上。</p>
<p>有两种方法可以获取JSON序列化变体文件：</p>
<ul>
<li>使用avocado variants命令的–json-variants-dump选项：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ avocado variants --mux-yaml examples/yaml_to_mux/hw/hw.yaml --json-variants-dump variants.json</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$ file variants.json</span><br><span class="line">variants.json: ASCII text, with very long lines, with no line terminators</span><br></pre></td></tr></table></figure>
<ul>
<li>执行Avocado作业后获取自动生成的JSON序列化变体文件：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> avocado run passtest.py --mux-yaml examples/yaml_to_mux/hw/hw.yaml</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$ file $HOME/avocado/job-results/latest/jobdata/variants.json</span><br><span class="line">$HOME/avocado/job-results/latest/jobdata/variants.json: ASCII text, with very long lines, with no line terminators</span><br></pre></td></tr></table></figure>
<p>获得variants.json文件后,可以将其加载到将要执行作业的系统上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ avocado run passtest.py --json-variants-load variants.json</span><br><span class="line">JOB ID     : f2022736b5b89d7f4cf62353d3fb4d7e3a06f075</span><br><span class="line">JOB LOG    : $HOME/avocado/job-results/job-2018-02-09T14.39-f202273/job.log</span><br><span class="line"> (1/6) passtest.py:PassTest.test;intel-scsi-56d0: PASS (0.04 s)</span><br><span class="line"> (2/6) passtest.py:PassTest.test;intel-virtio-3d4e: PASS (0.02 s)</span><br><span class="line"> (3/6) passtest.py:PassTest.test;amd-scsi-fa43: PASS (0.02 s)</span><br><span class="line"> (4/6) passtest.py:PassTest.test;amd-virtio-a59a: PASS (0.02 s)</span><br><span class="line"> (5/6) passtest.py:PassTest.test;arm-scsi-1c14: PASS (0.03 s)</span><br><span class="line"> (6/6) passtest.py:PassTest.test;arm-virtio-5ce1: PASS (0.04 s)</span><br><span class="line">RESULTS    : PASS 6 | ERROR 0 | FAIL 0 | SKIP 0 | WARN 0 | INTERRUPT 0 | CANCEL 0</span><br><span class="line">JOB TIME   : 0.51 s</span><br><span class="line">JOB HTML   : $HOME/avocado/job-results/job-2018-02-09T14.39-f202273/results.html</span><br></pre></td></tr></table></figure>
<h3 id="Varianter"><a href="#Varianter" class="headerlink" title="Varianter"></a>Varianter</h3><p><code>avocado.core.varianter.Varianter</code>是一个内部对象,用于与Avocado中的变体机制进行交互。 它的生命周期是两个阶段的复合。 首先,它允许核心/插件注入默认值,然后对其进行解析,只允许查询值,变体数量等。</p>
<p>avocado run passtest.py -m example.yaml的示例工作流程是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">avocado run passtest.py -m example.yaml</span><br><span class="line">  |</span><br><span class="line">  + parser.finish -&gt; Varianter.__init__  // dispatcher initializes all plugins</span><br><span class="line">  |</span><br><span class="line">  + $PLUGIN -&gt; args.default_avocado_params.add_default_param  // could be used to insert default values</span><br><span class="line">  |</span><br><span class="line">  + job.run_tests -&gt; Varianter.is_parsed</span><br><span class="line">  |</span><br><span class="line">  + job.run_tests -&gt; Varianter.parse</span><br><span class="line">  |                     // processes default params</span><br><span class="line">  |                     // initializes the plugins</span><br><span class="line">  |                     // updates the default values</span><br><span class="line">  |</span><br><span class="line">  + job._log_variants -&gt; Varianter.to_str  // prints the human readable representation to log</span><br><span class="line">  |</span><br><span class="line">  + runner.run_suite -&gt; Varianter.get_number_of_tests</span><br><span class="line">  |</span><br><span class="line">  + runner._iter_variants -&gt; Varianter.itertests  // Yields variants</span><br></pre></td></tr></table></figure>
<p>为了允许强制更新Varianter,它支持ignore_new_data,可用于忽略新数据。 Job Replay使用它将当前运行的Varianter替换为从重放作业加载的Varianter。 ignore_new_data的工作流程可能如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">avocado run --replay latest -m example.yaml</span><br><span class="line">  |</span><br><span class="line">  + $PLUGIN -&gt; args.default_avocado_params.add_default_param  // could be used to insert default values</span><br><span class="line">  |</span><br><span class="line">  + replay.run -&gt; Varianter.is_parsed</span><br><span class="line">  |</span><br><span class="line">  + replay.run  // Varianter object is replaced with the replay job&apos;s one</span><br><span class="line">  |             // Varianter.ignore_new_data is set</span><br><span class="line">  |</span><br><span class="line">  + $PLUGIN -&gt; args.default_avocado_params.add_default_param  // is ignored as new data are not accepted</span><br><span class="line">  |</span><br><span class="line">  + job.run_tests -&gt; Varianter.is_parsed</span><br><span class="line">  |</span><br><span class="line">  + job._log_variants -&gt; Varianter.to_str</span><br><span class="line">  |</span><br><span class="line">  + runner.run_suite -&gt; Varianter.get_number_of_tests</span><br><span class="line">  |</span><br><span class="line">  + runner._iter_variants -&gt; Varianter.itertests</span><br></pre></td></tr></table></figure>
<p>Varianter本身只能使用Default params生成一个空变量,但是它会调用所有Varianter插件,如果它们中的任何一个报告变量,它会生成它们而不是默认变量。</p>
<h3 id="Default-params"><a href="#Default-params" class="headerlink" title="Default params"></a>Default params</h3><p>Default params是一种在Varianter或Varianter插件中指定默认值的机制。 它们的目的通常是定义依赖于系统的值,这些值不应影响测试的结果。 一个例子是qemu二进制位置,它可能因主机而异,但最终它们应该导致qemu在测试中可执行。 因此,Default params不会影响测试的variant-id(至少不会影响官方的Varianter插件)。</p>
<p>可以通过从args获取default_avocado_params并使用以下命令从plugin/core设置这些参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default_avocado_params.add_default_parma(self, name, key, value, path=None)</span><br></pre></td></tr></table></figure>
<p>name - 注入数据的插件的名称(尚未用于任何内容,但我们计划允许白/黑列表)<br>key - 参数的名称<br>value - 参数的值<br>path - 此参数的位置。 当路径尚不存在时,它是由TreeNode创建的。</p>
<h3 id="Varianter-plugins"><a href="#Varianter-plugins" class="headerlink" title="Varianter plugins"></a>Varianter plugins</h3><p><code>avocado.core.plugin_interfaces.Varianter</code> 一个插件接口,可用于构建自定义插件,Varianter使用它来获取测试变体。 有关灵感,请参阅avocado_varianter_yaml_to_mux.YamlToMux这是一个可选的varianter插件。 有关此插件的详细信息,请访问Yaml_to_mux插件。</p>
<h3 id="Multiplexer"><a href="#Multiplexer" class="headerlink" title="Multiplexer"></a>Multiplexer</h3><p>avocado.core.mux</p>
<p>Multiplexer或简称Mux是一个抽象概念,它是树状参数结构背后的基本思想,支持产生所有可能的变体。 在创建自定义插件时可以使用基本构建块的核心实现。 在avocado_varianter_yaml_to_mux中有一个使用此概念的插件的演示版本,它添加了一个解析器,然后使用此多路复用器概念来定义一个avocado插件,以便从yaml(或json)文件生成变体。</p>
<h4 id="Multiplexer-concept"><a href="#Multiplexer-concept" class="headerlink" title="Multiplexer concept"></a>Multiplexer concept</h4><p>如前所述,这是构建块的内核实现,旨在基于定义了Multiplex域的树来编写Varianter插件。 可用的块是：</p>
<ul>
<li>MuxTree - 表示树的一部分并处理多路复用的对象,这意味着从树状对象生成所有可能的变体。</li>
<li>MuxPlugin - 构建Varianter插件的基类</li>
<li>MuxTreeNode - 从TreeNode继承并添加对控制标志(MuxTreeNode.ctrl)和Multiplex域(MuxTreeNode.multiplex)的支持。</li>
</ul>
<h3 id="Multiplex-domains"><a href="#Multiplex-domains" class="headerlink" title="Multiplex domains"></a>Multiplex domains</h3><p>带变量的默认AvocadoParams树可能如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Multiplex tree representation:</span><br><span class="line"> ┣━━ paths</span><br><span class="line"> ┃     → tmp: /var/tmp</span><br><span class="line"> ┃     → qemu: /usr/libexec/qemu-kvm</span><br><span class="line"> ┗━━ environ</span><br><span class="line">     → debug: False</span><br></pre></td></tr></table></figure>
<p>多路复用器想要产生类似的结构,但也能够定义不仅一个变体,而是定义所有可能的组合,然后将切片报告为变体。 我们使用术语Multiplex域来定义此节点的子节点不仅仅是不同的路径,但它们是不同的值,我们一次只需要一个。 在表示中,我们使用双线来可视地区分正常关系和多路关系。 让我们稍微修改一下我们的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Multiplex tree representation:</span><br><span class="line"> ┣━━ paths</span><br><span class="line"> ┃     → tmp: /var/tmp</span><br><span class="line"> ┃     → qemu: /usr/libexec/qemu-kvm</span><br><span class="line"> ┗━━ environ</span><br><span class="line">      ╠══ production</span><br><span class="line">      ║     → debug: False</span><br><span class="line">      ╚══ debug</span><br><span class="line">            → debug: True</span><br></pre></td></tr></table></figure>
<p>不同之处在于environ现在是一个多重节点,它的子节点将一次产生一个,产生两个变体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Variant 1:</span><br><span class="line"> ┣━━ paths</span><br><span class="line"> ┃     → tmp: /var/tmp</span><br><span class="line"> ┃     → qemu: /usr/libexec/qemu-kvm</span><br><span class="line"> ┗━━ environ</span><br><span class="line">      ┗━━ production</span><br><span class="line">            → debug: False</span><br><span class="line">Variant 2:</span><br><span class="line"> ┣━━ paths</span><br><span class="line"> ┃     → tmp: /var/tmp</span><br><span class="line"> ┃     → qemu: /usr/libexec/qemu-kvm</span><br><span class="line"> ┗━━ environ</span><br><span class="line">      ┗━━ debug</span><br><span class="line">            → debug: False</span><br></pre></td></tr></table></figure>
<p>请注意,Multiplex仅与直接子项有关,因此变体中的叶数可能不同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Multiplex tree representation:</span><br><span class="line"> ┣━━ paths</span><br><span class="line"> ┃     → tmp: /var/tmp</span><br><span class="line"> ┃     → qemu: /usr/libexec/qemu-kvm</span><br><span class="line"> ┗━━ environ</span><br><span class="line">      ╠══ production</span><br><span class="line">      ║     → debug: False</span><br><span class="line">      ╚══ debug</span><br><span class="line">           ┣━━ system</span><br><span class="line">           ┃     → debug: False</span><br><span class="line">           ┗━━ program</span><br><span class="line">                 → debug: True</span><br></pre></td></tr></table></figure>
<p>使用/ paths和/ paths,/ environ / debug / system和/ environ / debug / program生成一个带/ paths和/ environ / production的变体和其他变体。</p>
<p>如前所述,权力不是产生一种变体,而是定义具有所有可能变体的巨大情景。 通过使用具有多重域的树结构,您可以避免从Jenkin的稀疏矩阵作业中可能知道的大多数丑陋过滤器。 为了比较,我们来看看Avocado中的相同例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Multiplex tree representation:</span><br><span class="line"> ┗━━ os</span><br><span class="line">      ┣━━ distro</span><br><span class="line">      ┃    ┗━━ redhat</span><br><span class="line">      ┃         ╠══ fedora</span><br><span class="line">      ┃         ║    ┣━━ version</span><br><span class="line">      ┃         ║    ┃    ╠══ 20</span><br><span class="line">      ┃         ║    ┃    ╚══ 21</span><br><span class="line">      ┃         ║    ┗━━ flavor</span><br><span class="line">      ┃         ║         ╠══ workstation</span><br><span class="line">      ┃         ║         ╚══ cloud</span><br><span class="line">      ┃         ╚══ rhel</span><br><span class="line">      ┃              ╠══ 5</span><br><span class="line">      ┃              ╚══ 6</span><br><span class="line">      ┗━━ arch</span><br><span class="line">           ╠══ i386</span><br><span class="line">           ╚══ x86_64</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Variant 1:    /os/distro/redhat/fedora/version/20, /os/distro/redhat/fedora/flavor/workstation, /os/arch/i386</span><br><span class="line">Variant 2:    /os/distro/redhat/fedora/version/20, /os/distro/redhat/fedora/flavor/workstation, /os/arch/x86_64</span><br><span class="line">Variant 3:    /os/distro/redhat/fedora/version/20, /os/distro/redhat/fedora/flavor/cloud, /os/arch/i386</span><br><span class="line">Variant 4:    /os/distro/redhat/fedora/version/20, /os/distro/redhat/fedora/flavor/cloud, /os/arch/x86_64</span><br><span class="line">Variant 5:    /os/distro/redhat/fedora/version/21, /os/distro/redhat/fedora/flavor/workstation, /os/arch/i386</span><br><span class="line">Variant 6:    /os/distro/redhat/fedora/version/21, /os/distro/redhat/fedora/flavor/workstation, /os/arch/x86_64</span><br><span class="line">Variant 7:    /os/distro/redhat/fedora/version/21, /os/distro/redhat/fedora/flavor/cloud, /os/arch/i386</span><br><span class="line">Variant 8:    /os/distro/redhat/fedora/version/21, /os/distro/redhat/fedora/flavor/cloud, /os/arch/x86_64</span><br><span class="line">Variant 9:    /os/distro/redhat/rhel/5, /os/arch/i386</span><br><span class="line">Variant 10:    /os/distro/redhat/rhel/5, /os/arch/x86_64</span><br><span class="line">Variant 11:    /os/distro/redhat/rhel/6, /os/arch/i386</span><br><span class="line">Variant 12:    /os/distro/redhat/rhel/6, /os/arch/x86_64</span><br></pre></td></tr></table></figure>
<p>与Jenkin的稀疏矩阵对比：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">os_version = fedora20 fedora21 rhel5 rhel6</span><br><span class="line">os_flavor = none workstation cloud</span><br><span class="line">arch = i386 x86_64</span><br><span class="line"></span><br><span class="line">filter = ((os_version == &quot;rhel5&quot;).implies(os_flavor == &quot;none&quot;) &amp;&amp;</span><br><span class="line">          (os_version == &quot;rhel6&quot;).implies(os_flavor == &quot;none&quot;)) &amp;&amp;</span><br><span class="line">         !(os_version == &quot;fedora20&quot; &amp;&amp; os_flavor == &quot;none&quot;) &amp;&amp;</span><br><span class="line">         !(os_version == &quot;fedora21&quot; &amp;&amp; os_flavor == &quot;none&quot;)</span><br></pre></td></tr></table></figure>
<p>这仍然是一个相对简单的例子,但它随着内部依赖性而急剧增长。</p>
<h3 id="MuxPlugin"><a href="#MuxPlugin" class="headerlink" title="MuxPlugin"></a>MuxPlugin</h3><p>定义avocado.core.plugin_interfaces.Varianter所需的完整接口。 插件编写者应该从这个MuxPlugin继承,然后从Varianter继承并调用：</p>
<p><code>self.initialize_mux(root, paths, debug)</code></p>
<ul>
<li>root - 是params树的根(类似TreeNode节点的复合体)</li>
<li>paths - 是测试中使用的所有变体的参数路径</li>
<li>debug - 是否使用调试模式(要求传递的树是TreeNodeDebug类节点的复合,它存储变量/值/环境的来源作为列表用途的值,并且<strong>NOT</strong>用于测试执行。</li>
</ul>
<h3 id="MuxTree"><a href="#MuxTree" class="headerlink" title="MuxTree"></a>MuxTree</h3><p>这是努力工作的核心功能。 当在搜索叶节点时到达另一个multiplex时,它遍历树并记住所有叶节点或使用MuxTree列表。</p>
<p>当它被要求报告变体时,它组合了每个记忆项目的一个变体(叶子节点始终保持不变,但MuxTree圈出它的值),递归地产生不同多重域的所有可能变体。</p>
<h2 id="工作重演"><a href="#工作重演" class="headerlink" title="工作重演"></a><a href="https://avocado-framework.readthedocs.io/en/63.0/Replay.html" target="_blank" rel="noopener">工作重演</a></h2><p>为了使用相同的数据再现给定的job,我们可以使用<code>--replay</code>选项执行<code>run</code>命令,从原始job中得知hash id以实现重演.hash id可以只是一部分,只要所提供的部分对应于原始job id,并且它也足够独特。或者,代替jo<br>b id,您可以使用最新的字符串,Avocado将重演最新执行的job。</p>
<p>让我们来看一个例子。首先,用两个测试引用运行一个简单的job：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ avocado run /bin/true /bin/false</span><br><span class="line">JOB ID     : 825b860b0c2f6ec48953c638432e3e323f8d7cad</span><br><span class="line">JOB LOG    : $HOME/avocado/job-results/job-2016-01-11T16.14-825b860/job.log</span><br><span class="line"> (1/2) /bin/true: PASS (0.01 s)</span><br><span class="line"> (2/2) /bin/false: FAIL (0.01 s)</span><br><span class="line">RESULTS    : PASS 1 | ERROR 0 | FAIL 1 | SKIP 0 | WARN 0 | INTERRUPT 0</span><br><span class="line">JOB TIME   : 0.12 s</span><br><span class="line">JOB HTML   : $HOME/avocado/job-results/job-2016-01-11T16.14-825b860/html/results.html</span><br></pre></td></tr></table></figure>
<p>现在我们可以重新运行这个job：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ avocado run --replay 825b86</span><br><span class="line">JOB ID     : 55a0d10132c02b8cc87deb2b480bfd8abbd956c3</span><br><span class="line">SRC JOB ID : 825b860b0c2f6ec48953c638432e3e323f8d7cad</span><br><span class="line">JOB LOG    : $HOME/avocado/job-results/job-2016-01-11T16.18-55a0d10/job.log</span><br><span class="line"> (1/2) /bin/true: PASS (0.01 s)</span><br><span class="line"> (2/2) /bin/false: FAIL (0.01 s)</span><br><span class="line">RESULTS    : PASS 1 | ERROR 0 | FAIL 1 | SKIP 0 | WARN 0 | INTERRUPT 0</span><br><span class="line">JOB TIME   : 0.11 s</span><br><span class="line">JOB HTML   : $HOME/avocado/job-results/job-2016-01-11T16.18-55a0d10/html/results.html</span><br></pre></td></tr></table></figure>
<p>回放功能将检索原始测试引用、变量和配置。让我们看看另一个例子,现在使用mux YAML文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ avocado run /bin/true /bin/false --mux-yaml mux-environment.yaml</span><br><span class="line">JOB ID     : bd6aa3b852d4290637b5e771b371537541043d1d</span><br><span class="line">JOB LOG    : $HOME/avocado/job-results/job-2016-01-11T21.56-bd6aa3b/job.log</span><br><span class="line"> (1/4) /bin/true;first-c49a: PASS (0.01 s)</span><br><span class="line"> (2/4) /bin/true;second-f05f: PASS (0.01 s)</span><br><span class="line"> (3/4) /bin/false;first-c49a: FAIL (0.04 s)</span><br><span class="line"> (4/4) /bin/false;second-f05f: FAIL (0.04 s)</span><br><span class="line">RESULTS    : PASS 2 | ERROR 0 | FAIL 2 | SKIP 0 | WARN 0 | INTERRUPT 0</span><br><span class="line">JOB TIME   : 0.19 s</span><br><span class="line">JOB HTML   : $HOME/avocado/job-results/job-2016-01-11T21.56-bd6aa3b/html/results.html</span><br></pre></td></tr></table></figure>
<p>我们可以使用<code>$ avocado run --replay latest</code>重新运行job,或者忽略变量运行job</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ avocado run --replay bd6aa3b --replay-ignore variants</span><br><span class="line">Ignoring variants from source job with --replay-ignore.</span><br><span class="line">JOB ID     : d5a46186ee0fb4645e3f7758814003d76c980bf9</span><br><span class="line">SRC JOB ID : bd6aa3b852d4290637b5e771b371537541043d1d</span><br><span class="line">JOB LOG    : $HOME/avocado/job-results/job-2016-01-11T22.01-d5a4618/job.log</span><br><span class="line"> (1/2) /bin/true: PASS (0.01 s)</span><br><span class="line"> (2/2) /bin/false: FAIL (0.01 s)</span><br><span class="line">RESULTS    : PASS 1 | ERROR 0 | FAIL 1 | SKIP 0 | WARN 0 | INTERRUPT 0</span><br><span class="line">JOB TIME   : 0.12 s</span><br><span class="line">JOB HTML   : $HOME/avocado/job-results/job-2016-01-11T22.01-d5a4618/html/results.html</span><br></pre></td></tr></table></figure>
<p>此外,可以只重演给定结果的变体,使用<code>--replay-test-status</code>选项,查看以下示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ avocado run --replay bd6aa3b --replay-test-status FAIL</span><br><span class="line">JOB ID     : 2e1dc41af6ed64895f3bb45e3820c5cc62a9b6eb</span><br><span class="line">SRC JOB ID : bd6aa3b852d4290637b5e771b371537541043d1d</span><br><span class="line">JOB LOG    : $HOME/avocado/job-results/job-2016-01-12T00.38-2e1dc41/job.log</span><br><span class="line"> (1/4) /bin/true;first-c49a: SKIP</span><br><span class="line"> (2/4) /bin/true;second-f05f: SKIP</span><br><span class="line"> (3/4) /bin/false;first-c49a: FAIL (0.03 s)</span><br><span class="line"> (4/4) /bin/false;second-f05f: FAIL (0.04 s)</span><br><span class="line">RESULTS    : PASS 0 | ERROR 0 | FAIL 24 | SKIP 24 | WARN 0 | INTERRUPT 0</span><br><span class="line">JOB TIME   : 0.29 s</span><br><span class="line">JOB HTML   : $HOME/avocado/job-results/job-2016-01-12T00.38-2e1dc41/html/results.html</span><br></pre></td></tr></table></figure>
<p>其中一个特殊的例子是<code>--replay-test-status INTERRUPTED</code>或<code>--replay-resume</code>,它跳过所执行的测试,只执行取消测试后取消或未执行的测试。这个特性即使在系统崩溃等严重中断时也可以工作。</p>
<p>在重演用<code>--failfast on</code>选项执行的job时,可以使用<code>--failfast off</code>禁用<code>failfast</code> 选项重演job。</p>
<p>为了能够重演job,Avocado将job数据记录在同一个job结果目录中,在一个名为<code>replay</code>的子目录内。如果给定的job有一个非默认路径来记录日志,当重播时间到来时,我们需要通知日志在何处。见下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ avocado run /bin/true --job-results-dir /tmp/avocado_results/</span><br><span class="line">JOB ID     : f1b1c870ad892eac6064a5332f1bbe38cda0aaf3</span><br><span class="line">JOB LOG    : /tmp/avocado_results/job-2016-01-11T22.10-f1b1c87/job.log</span><br><span class="line"> (1/1) /bin/true: PASS (0.01 s)</span><br><span class="line">RESULTS    : PASS 1 | ERROR 0 | FAIL 0 | SKIP 0 | WARN 0 | INTERRUPT 0</span><br><span class="line">JOB TIME   : 0.11 s</span><br><span class="line">JOB HTML   : /tmp/avocado_results/job-2016-01-11T22.10-f1b1c87/html/results.html</span><br></pre></td></tr></table></figure>
<p>试图重演这项job,但失败了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ avocado run --replay f1b1</span><br><span class="line">can&apos;t find job results directory in &apos;$HOME/avocado/job-results&apos;</span><br></pre></td></tr></table></figure>
<p>在这种情况下,我们必须通知工作结果目录位于何处：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ avocado run --replay f1b1 --replay-data-dir /tmp/avocado_results</span><br><span class="line">JOB ID     : 19c76abb29f29fe410a9a3f4f4b66387570edffa</span><br><span class="line">SRC JOB ID : f1b1c870ad892eac6064a5332f1bbe38cda0aaf3</span><br><span class="line">JOB LOG    : $HOME/avocado/job-results/job-2016-01-11T22.15-19c76ab/job.log</span><br><span class="line"> (1/1) /bin/true: PASS (0.01 s)</span><br><span class="line">RESULTS    : PASS 1 | ERROR 0 | FAIL 0 | SKIP 0 | WARN 0 | INTERRUPT 0</span><br><span class="line">JOB TIME   : 0.11 s</span><br><span class="line">JOB HTML   : $HOME/avocado/job-results/job-2016-01-11T22.15-19c76ab/html/results.html</span><br></pre></td></tr></table></figure>
<h2 id="工作差异"><a href="#工作差异" class="headerlink" title="工作差异"></a><a href="https://avocado-framework.readthedocs.io/en/63.0/Diff.html" target="_blank" rel="noopener">工作差异</a></h2><p>Avocadodiff插件允许用户轻松地比较两个给定的job的几个方面。基本用法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ avocado diff 7025aaba 384b949c</span><br><span class="line">--- 7025aaba9c2ab8b4bba2e33b64db3824810bb5df</span><br><span class="line">+++ 384b949c991b8ab324ce67c9d9ba761fd07672ff</span><br><span class="line">@@ -1,15 +1,15 @@</span><br><span class="line"></span><br><span class="line"> COMMAND LINE</span><br><span class="line">-/usr/bin/avocado run sleeptest.py</span><br><span class="line">+/usr/bin/avocado run passtest.py</span><br><span class="line"></span><br><span class="line"> TOTAL TIME</span><br><span class="line">-1.00 s</span><br><span class="line">+0.00 s</span><br><span class="line"></span><br><span class="line"> TEST RESULTS</span><br><span class="line">-1-sleeptest.py:SleepTest.test: PASS</span><br><span class="line">+1-passtest.py:PassTest.test: PASS</span><br><span class="line"></span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>
<p>Avocado Diff可以比较和创建一个统一的差异：</p>
<ul>
<li>命令行</li>
<li>工作时间</li>
<li>变量和参数</li>
<li>测试结果</li>
<li>配置</li>
<li>sysinfo前后</li>
</ul>
<p>结果中只包含不同内容的部分。还可以使用<code>--diff-filter</code>启用/禁用这些部分。请参阅<code>avocado diff --help</code>更多信息。</p>
<p>可以通过jobs ID、结果目录或<code>latest</code>来标识job。示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ avocado diff ~/avocado/job-results/job-2016-08-03T15.56-4b3cb5b/ latest</span><br><span class="line">--- 4b3cb5bbbb2435c91c7b557eebc09997d4a0f544</span><br><span class="line">+++ 57e5bbb3991718b216d787848171b446f60b3262</span><br><span class="line">@@ -1,9 +1,9 @@</span><br><span class="line"></span><br><span class="line"> COMMAND LINE</span><br><span class="line">-/usr/bin/avocado run perfmon.py</span><br><span class="line">+/usr/bin/avocado run passtest.py</span><br><span class="line"></span><br><span class="line"> TOTAL TIME</span><br><span class="line">-11.91 s</span><br><span class="line">+0.00 s</span><br><span class="line"></span><br><span class="line"> TEST RESULTS</span><br><span class="line">-1-test.py:Perfmon.test: FAIL</span><br><span class="line">+1-examples/tests/passtest.py:PassTest.test: PASS</span><br></pre></td></tr></table></figure>
<p>与统一的差异,你也可以生成HTML(选项 <code>--html</code>)差异文件,并可选地,打开它在您的首选浏览器(选项 <code>--open browser</code>)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ avocado diff 7025aaba 384b949c --html /tmp/myjobdiff.html</span><br><span class="line">/tmp/myjobdiff.html</span><br></pre></td></tr></table></figure>
<p>如果在没有<code>--html</code>的情况下使用 <code>--open browser</code>,我们将创建一个临时HTML文件。</p>
<p>对于那些希望使用自定义DIFF工具而不是Avocado DIFF工具的人,我们提供了<code>--create-reports</code>选项,因此我们创建了两个具有相关内容的临时文件。打印文件名,用户可以复制/粘贴到自定义DIFF工具命令行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ avocado diff 7025aaba 384b949c --create-reports</span><br><span class="line">/var/tmp/avocado_diff_7025aab_zQJjJh.txt /var/tmp/avocado_diff_384b949_AcWq02.txt</span><br><span class="line"></span><br><span class="line">$ diff -u /var/tmp/avocado_diff_7025aab_zQJjJh.txt /var/tmp/avocado_diff_384b949_AcWq02.txt</span><br><span class="line">--- /var/tmp/avocado_diff_7025aab_zQJjJh.txt    2016-08-10 21:48:43.547776715 +0200</span><br><span class="line">+++ /var/tmp/avocado_diff_384b949_AcWq02.txt    2016-08-10 21:48:43.547776715 +0200</span><br><span class="line">@@ -1,250 +1,19 @@</span><br><span class="line"></span><br><span class="line"> COMMAND LINE</span><br><span class="line"> ============</span><br><span class="line">-/usr/bin/avocado run sleeptest.py</span><br><span class="line">+/usr/bin/avocado run passtest.py</span><br><span class="line"></span><br><span class="line"> TOTAL TIME</span><br><span class="line"> ==========</span><br><span class="line">-1.00 s</span><br><span class="line">+0.00 s</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="远程运行测试"><a href="#远程运行测试" class="headerlink" title="远程运行测试"></a><a href="https://avocado-framework.readthedocs.io/en/63.0/RunningTestsRemotely.html" target="_blank" rel="noopener">远程运行测试</a></h2><h2 id="Avocado子类"><a href="#Avocado子类" class="headerlink" title="Avocado子类"></a><a href="https://avocado-framework.readthedocs.io/en/63.0/SubclassingAvocado.html" target="_blank" rel="noopener">Avocado子类</a></h2><p>使用子类来扩展Avocado测试类的特性是非常直接的,它可能构成了一个非常有用的办法,在项目存储库中托管一些共享/递归代码。</p>
<p>在本文档中,我们提出了一个项目组织,允许您创建和安装所谓的子框架。</p>
<p>让我们举个例子,一个叫做Apricot Framework的项目。这里是提议的文件系统结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">~/git/apricot (master)$ tree</span><br><span class="line">.</span><br><span class="line">├── apricot</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   └── test.py</span><br><span class="line">├── README.rst</span><br><span class="line">├── setup.py</span><br><span class="line">├── tests</span><br><span class="line">│   └── test_example.py</span><br><span class="line">└── VERSION</span><br></pre></td></tr></table></figure>
<p>在SETUP.PY中,将Avocado框架包指定为依赖项是很重要的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from setuptools import setup, find_packages</span><br><span class="line"></span><br><span class="line">setup(name=&apos;apricot&apos;,</span><br><span class="line">      description=&apos;Apricot - Avocado SubFramwork&apos;,</span><br><span class="line">      version=open(&quot;VERSION&quot;, &quot;r&quot;).read().strip(),</span><br><span class="line">      author=&apos;Apricot Developers&apos;,</span><br><span class="line">      author_email=&apos;apricot-devel@example.com&apos;,</span><br><span class="line">      packages=[&apos;apricot&apos;],</span><br><span class="line">      include_package_data=True,</span><br><span class="line">      install_requires=[&apos;avocado-framework&apos;]</span><br><span class="line">      )</span><br></pre></td></tr></table></figure>
<p>VERSION: 你希望的文件版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.0</span><br></pre></td></tr></table></figure>
<p><code>apricot/__init__.py</code>:使您的新测试类在您的模块根目录中可用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__all__ = [&apos;ApricotTest&apos;]</span><br><span class="line"></span><br><span class="line">from apricot.test import ApricotTest</span><br></pre></td></tr></table></figure>
<p><code>apricot/test.py</code>,在这里,您将基本上扩展Avocado测试类与您自己的方法和程序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> avocado <span class="keyword">import</span> Test</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApricotTest</span><span class="params">(Test)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.log.info(<span class="string">"setUp() executed from Apricot"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">some_useful_method</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p><code>tests/test_example.py</code>:这就是测试的样子。这里最重要的一项是使用<code>:avocado: recursive</code>递归,所以Avocado测试加载器将能够识别您的测试类作为Avocado测试类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> apricot <span class="keyword">import</span> ApricotTest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span><span class="params">(ApricotTest)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :avocado: recursive</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertTrue(self.some_useful_method())</span><br></pre></td></tr></table></figure>
<p>非侵入的安装你的模块:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">~/git/apricot (master)$ python setup.py develop --user</span><br><span class="line">running develop</span><br><span class="line">running egg_info</span><br><span class="line">writing requirements to apricot.egg-info/requires.txt</span><br><span class="line">writing apricot.egg-info/PKG-INFO</span><br><span class="line">writing top-level names to apricot.egg-info/top_level.txt</span><br><span class="line">writing dependency_links to apricot.egg-info/dependency_links.txt</span><br><span class="line">reading manifest file &apos;apricot.egg-info/SOURCES.txt&apos;</span><br><span class="line">writing manifest file &apos;apricot.egg-info/SOURCES.txt&apos;</span><br><span class="line">running build_ext</span><br><span class="line">Creating /home/apahim/.local/lib/python2.7/site-packages/apricot.egg-link (link to .)</span><br><span class="line">apricot 1.0 is already the active version in easy-install.pth</span><br><span class="line"></span><br><span class="line">Installed /home/apahim/git/apricot</span><br><span class="line">Processing dependencies for apricot==1.0</span><br><span class="line">Searching for avocado-framework==55.0</span><br><span class="line">Best match: avocado-framework 55.0</span><br><span class="line">avocado-framework 55.0 is already the active version in easy-install.pth</span><br><span class="line"></span><br><span class="line">Using /home/apahim/git/avocado</span><br><span class="line">Searching for stevedore==1.25.0</span><br><span class="line">Best match: stevedore 1.25.0</span><br><span class="line">Adding stevedore 1.25.0 to easy-install.pth file</span><br><span class="line"></span><br><span class="line">Using /usr/lib/python2.7/site-packages</span><br><span class="line">Searching for six==1.10.0</span><br><span class="line">Best match: six 1.10.0</span><br><span class="line">Adding six 1.10.0 to easy-install.pth file</span><br><span class="line"></span><br><span class="line">Using /usr/lib/python2.7/site-packages</span><br><span class="line">Searching for pbr==3.1.1</span><br><span class="line">Best match: pbr 3.1.1</span><br><span class="line">Adding pbr 3.1.1 to easy-install.pth file</span><br><span class="line">Installing pbr script to /home/apahim/.local/bin</span><br><span class="line"></span><br><span class="line">Using /usr/lib/python2.7/site-packages</span><br><span class="line">Finished processing dependencies for apricot==1.0</span><br></pre></td></tr></table></figure>
<p>然后运行你的测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">~/git/apricot$ avocado run tests/test_example.py</span><br><span class="line">JOB ID     : 02c663eb77e0ae6ce67462a398da6972791793bf</span><br><span class="line">JOB LOG    : $HOME/avocado/job-results/job-2017-11-16T12.44-02c663e/job.log</span><br><span class="line"> (1/1) tests/test_example.py:MyTest.test: PASS (0.03 s)</span><br><span class="line">RESULTS    : PASS 1 | ERROR 0 | FAIL 0 | SKIP 0 | WARN 0 | INTERRUPT 0 | CANCEL 0</span><br><span class="line">JOB TIME   : 0.95 s</span><br><span class="line">JOB HTML   : $HOME/avocado/job-results/job-2017-11-16T12.44-02c663e/results.html</span><br></pre></td></tr></table></figure>
<h2 id="使用GDB-Debugging"><a href="#使用GDB-Debugging" class="headerlink" title="使用GDB Debugging"></a><a href="https://avocado-framework.readthedocs.io/en/63.0/DebuggingWithGDB.html" target="_blank" rel="noopener">使用GDB Debugging</a></h2><h2 id="通过测试运行可执行包"><a href="#通过测试运行可执行包" class="headerlink" title="通过测试运行可执行包"></a><a href="https://avocado-framework.readthedocs.io/en/63.0/WrapProcess.html" target="_blank" rel="noopener">通过测试运行可执行包</a></h2><p>Avocado允许可执行文件的测试以易懂的方式运行。用户指定一个脚本(“包装器”),用于运行由测试调用的实际程序。</p>
<p>如果测试脚本被正确实现,它不应该干扰测试行为。也就是说,包装器应该避免改变原始可执行文件的返回状态、标准输出和标准错误消息。</p>
<p>用户可以指定要封装哪个程序(具有类似shell的Glob),或者如果省略了,将应用于测试调用的所有程序的全局包装器。</p>
<p>这个特性是作为插件实现的,它将–wraper添加到Avocado运行命令中。</p>
<p>作为包装器以易懂的方式运行strace的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">exec strace -ff -o $AVOCADO_TEST_LOGDIR/strace.log -- $@</span><br></pre></td></tr></table></figure>
<p>让所有程序由test.py开始,用<code>~/bin/my-wrapper.sh</code>包装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scripts/avocado run --wrapper ~/bin/my-wrapper.sh tests/test.py</span><br></pre></td></tr></table></figure>
<p>只有我的<code>my-binary</code>文件用<code>~/bin/my-wrapper.sh</code>包装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scripts/avocado run --wrapper ~/bin/my-wrapper.sh:*my-binary tests/test.py</span><br></pre></td></tr></table></figure>
<h3 id="警示"><a href="#警示" class="headerlink" title="警示"></a>警示</h3><ul>
<li>不可能用GDB(–gdb-run-bin)进行调试,同时使用包装器(-包装器)。这两个选项是互斥的。</li>
<li>只能设置一个(全局)包装器。如果需要两个包装器中存在的功能,则必须将这些组合成单个包装器脚本。</li>
<li>只有使用<code>avocado.utils.process</code>(以及使用它的其他API模块:avocado.utils.build)运行的可执行文件)才会受到此特性的影响。</li>
</ul>
<h2 id="插件系统"><a href="#插件系统" class="headerlink" title="插件系统"></a><a href="https://avocado-framework.readthedocs.io/en/63.0/Plugins.html" target="_blank" rel="noopener">插件系统</a></h2><h2 id="Utilities"><a href="#Utilities" class="headerlink" title="Utilities"></a><a href="https://avocado-framework.readthedocs.io/en/63.0/utils/index.html" target="_blank" rel="noopener">Utilities</a></h2><h2 id="可选插件"><a href="#可选插件" class="headerlink" title="可选插件"></a><a href="https://avocado-framework.readthedocs.io/en/63.0/optional_plugins/index.html" target="_blank" rel="noopener">可选插件</a></h2><h2 id="参考指南"><a href="#参考指南" class="headerlink" title="参考指南"></a><a href="https://avocado-framework.readthedocs.io/en/63.0/ReferenceGuide.html" target="_blank" rel="noopener">参考指南</a></h2><h2 id="贡献与社区指南"><a href="#贡献与社区指南" class="headerlink" title="贡献与社区指南"></a><a href="https://avocado-framework.readthedocs.io/en/63.0/ContributionGuide.html" target="_blank" rel="noopener">贡献与社区指南</a></h2><h2 id="Avocado发展要点"><a href="#Avocado发展要点" class="headerlink" title="Avocado发展要点"></a><a href="https://avocado-framework.readthedocs.io/en/63.0/DevelopmentTips.html" target="_blank" rel="noopener">Avocado发展要点</a></h2><h2 id="释放avocado"><a href="#释放avocado" class="headerlink" title="释放avocado"></a><a href="https://avocado-framework.readthedocs.io/en/63.0/MaintenanceGuide.html" target="_blank" rel="noopener">释放avocado</a></h2><h2 id="其它资源"><a href="#其它资源" class="headerlink" title="其它资源"></a><a href="https://avocado-framework.readthedocs.io/en/63.0/OtherResources.html" target="_blank" rel="noopener">其它资源</a></h2><h2 id="测试API文档"><a href="#测试API文档" class="headerlink" title="测试API文档"></a><a href="https://avocado-framework.readthedocs.io/en/63.0/api/test/avocado.html" target="_blank" rel="noopener">测试API文档</a></h2><p>这是用户在编写测试时应该使用并且可以依赖的最小API集。</p>
<h3 id="avocado-main"><a href="#avocado-main" class="headerlink" title="avocado.main"></a><code>avocado.main</code></h3><p><code>avocado.core.job.TestProgram</code>的别名</p>
<h3 id="class-avocado-Test-methodName-39-test-39-name-None-params-None-base-logdir-None-job-None-runner-queue-None"><a href="#class-avocado-Test-methodName-39-test-39-name-None-params-None-base-logdir-None-job-None-runner-queue-None" class="headerlink" title="class avocado.Test(methodName=&#39;test&#39;, name=None, params=None, base_logdir=None, job=None, runner_queue=None)"></a><code>class avocado.Test(methodName=&#39;test&#39;, name=None, params=None, base_logdir=None, job=None, runner_queue=None)</code></h3><p>测试类的基本实现。</p>
<p>你将继承自己编写自己的测试。 通常,您需要在自己的测试中实现<code>setUp()</code>,<code>test*()</code>和<code>tearDown()</code>方法。</p>
<p>初始化测试。</p>
<p>参数：</p>
<ul>
<li><code>methodName</code> - 要运行的主方法的名称。 为了与原始unittest类兼容,您不应该设置它。</li>
<li><code>name(avocado.core.test.TestID)</code> - 测试名称的漂亮名称。 对于使用AvocadoAPI编写的常规测试,不应设置此项。 这保留给内部Avocado使用,例如将随机可执行文件作为测试运行时。</li>
<li><code>base_logdir</code> - 测试日志应该到达的目录。 如果提供None,则使用<code>avocado.data_dir.create_job_logs_dir()</code>。</li>
<li><code>job</code> - 此测试所属的工作。</li>
</ul>
<h4 id="basedir"><a href="#basedir" class="headerlink" title="basedir"></a><code>basedir</code></h4><p>此测试(由文件支持)所在的目录</p>
<h4 id="cache-dirs"><a href="#cache-dirs" class="headerlink" title="cache_dirs"></a><code>cache_dirs</code></h4><p>返回配置文件中设置的缓存目录列表。</p>
<h4 id="cancel-message-None"><a href="#cancel-message-None" class="headerlink" title="cancel(message=None)"></a><code>cancel(message=None)</code></h4><p>取消测试。</p>
<p>期望从测试方法调用此方法,而不是其他任何地方,因为根据定义,我们只能取消当前正在执行的测试。 如果在测试方法之外调用此方法,avocado会将测试状态标记为ERROR,并指示您在错误消息中修复测试。</p>
<p>参数：message(str) - 将记录在日志中的可选消息</p>
<h4 id="error-message-None"><a href="#error-message-None" class="headerlink" title="error(message=None)"></a><code>error(message=None)</code></h4><p>使当前正在运行的测试状态为错误。</p>
<p>调用此方法后,将终止测试并将其状态设置为ERROR。</p>
<p>参数：message(str) - 将记录在日志中的可选消息</p>
<h4 id="fail-message-None"><a href="#fail-message-None" class="headerlink" title="fail(message=None)"></a>fail(message=None)</h4><h4 id="fail-class"><a href="#fail-class" class="headerlink" title="fail_class"></a>fail_class</h4><h4 id="fail-reason"><a href="#fail-reason" class="headerlink" title="fail_reason"></a>fail_reason</h4><h4 id="fetch-asset-name-asset-hash-None-algorithm-None-locations-None-expire-None"><a href="#fetch-asset-name-asset-hash-None-algorithm-None-locations-None-expire-None" class="headerlink" title="fetch_asset(name,asset_hash = None,algorithm = None,locations = None,expire = None)"></a>fetch_asset(name,asset_hash = None,algorithm = None,locations = None,expire = None)</h4><p>方法o调用utils.asset以获取和支持散列检查,缓存和多个位置的资产文件。</p>
<p>参数：<br>    name - 资产文件名或URL<br>    asset_hash - 资产哈希(可选)<br>    algorithm - 哈希算法(可选,默认为avocado.utils.asset.DEFAULT_HASH_ALGORITHM)<br>    locations - 可从中获取资产的URL列表(可选)<br>    expire  - 资产到期的时间<br>raise： EnvironmentError - 无法获取资产时<br>EnvironmentError - 无法获取资产时<br>返回：资产文件本地路径</p>
<h4 id="filename"><a href="#filename" class="headerlink" title="filename"></a>filename</h4><p>返回包含当前测试的文件(路径)的名称</p>
<h4 id="get-state"><a href="#get-state" class="headerlink" title="get_state()"></a>get_state()</h4><p>序列化表示测试状态的选定属性</p>
<p>返回：包含相关测试状态数据的字典<br>返回类型：字典</p>
<h4 id="job"><a href="#job" class="headerlink" title="job"></a>job</h4><p>这项测试与之相关的工作</p>
<h4 id="log"><a href="#log" class="headerlink" title="log"></a>log</h4><p>增强的测试日志</p>
<h4 id="logdir"><a href="#logdir" class="headerlink" title="logdir"></a>logdir</h4><p>此测试的日志目录的路径</p>
<h4 id="logfile"><a href="#logfile" class="headerlink" title="logfile"></a>logfile</h4><p>此测试的主要debug.log文件的路径</p>
<h4 id="name"><a href="#name" class="headerlink" title="name"></a>name</h4><p>返回测试ID,其中包含测试名称</p>
<p>返回类型：TestID</p>
<h4 id="outputdir"><a href="#outputdir" class="headerlink" title="outputdir"></a>outputdir</h4><p>可用于测试编写者将文件附加到结果的目录</p>
<h4 id="params"><a href="#params" class="headerlink" title="params"></a>params</h4><p>此测试的参数(AvocadoParam实例)</p>
<h4 id="report-state"><a href="#report-state" class="headerlink" title="report_state()"></a>report_state()</h4><p>将当前测试状态发送到测试运行程序进程</p>
<h4 id="run-avocado"><a href="#run-avocado" class="headerlink" title="run_avocado()"></a>run_avocado()</h4><p>包装run方法,用于在Avocado跑步者内执行。</p>
<p>结果：未使用的参数,与unittest.TestCase的兼容性。</p>
<h4 id="runner-queue"><a href="#runner-queue" class="headerlink" title="runner_queue"></a>runner_queue</h4><p>测试和测试运行器之间的通信通道</p>
<h4 id="running"><a href="#running" class="headerlink" title="running"></a>running</h4><p>此测试目前是否正在执行</p>
<h4 id="set-runner-queue-runner-queue"><a href="#set-runner-queue-runner-queue" class="headerlink" title="set_runner_queue(runner_queue)"></a>set_runner_queue(runner_queue)</h4><p>覆盖runner_queue</p>
<h4 id="status"><a href="#status" class="headerlink" title="status"></a>status</h4><p>此测试的结果状态</p>
<h4 id="teststmpdir"><a href="#teststmpdir" class="headerlink" title="teststmpdir"></a>teststmpdir</h4><p>返回临时目录的路径,该路径对于给定作业中的所有测试保持不变。</p>
<h4 id="time-elapsed-1"><a href="#time-elapsed-1" class="headerlink" title="time_elapsed = -1"></a>time_elapsed = -1</h4><p>测试执行的持续时间(总是从time_end - time_start重新计算</p>
<h4 id="time-end-1"><a href="#time-end-1" class="headerlink" title="time_end = -1"></a>time_end = -1</h4><p>(unix)测试完成的时间(可能会被迫测试)</p>
<h4 id="time-start-1"><a href="#time-start-1" class="headerlink" title="time_start = -1"></a>time_start = -1</h4><p>(unix)测试开始的时间(可以强制进行测试)</p>
<h4 id="timeout-None"><a href="#timeout-None" class="headerlink" title="timeout = None"></a><code>timeout = None</code></h4><p>测试超时(params的超时优先)</p>
<h4 id="traceback"><a href="#traceback" class="headerlink" title="traceback"></a><code>traceback</code></h4><h4 id="whiteboard"><a href="#whiteboard" class="headerlink" title="whiteboard="></a><code>whiteboard=</code></h4><p>测试结束时将存储在<code>$logdir/whiteboard</code>位置的任意字符串。</p>
<h4 id="workdir"><a href="#workdir" class="headerlink" title="workdir"></a><code>workdir</code></h4><p>此属性返回在整个测试执行期间存在的可写目录,但在测试完成后将清除该目录。</p>
<p>它可以用于解压缩源代码压缩包,构建软件等任务。</p>
<h3 id="avocado-fail-on-exceptions-None"><a href="#avocado-fail-on-exceptions-None" class="headerlink" title="avocado.fail_on(exceptions=None)"></a>avocado.fail_on(exceptions=None)</h3><p>当装饰函数产生指定类型的异常时,测试失败。</p>
<p>(例如,我们的方法可能会在测试软件失败时引发IndexError。我们可以尝试/捕获它或使用此装饰器代替)</p>
<p>参数：exceptions - 假定为测试失败的元组或单个异常[Exception]<br>注意：self.error和self.cancel行为保持不变<br>注意：为了允许简单使用,参数“exception”不能是可调用的</p>
<h3 id="avocado-skip-message-None"><a href="#avocado-skip-message-None" class="headerlink" title="avocado.skip(message=None)"></a>avocado.skip(message=None)</h3><p>跳过测试装饰器</p>
<h3 id="avocado-skipIf-condition-message-None"><a href="#avocado-skipIf-condition-message-None" class="headerlink" title="avocado.skipIf(condition, message=None)"></a>avocado.skipIf(condition, message=None)</h3><p>如果条件为True,装饰器将跳过测试。</p>
<h3 id="avocado-skipUnless-condition-message-None"><a href="#avocado-skipUnless-condition-message-None" class="headerlink" title="avocado.skipUnless(condition, message=None)"></a><code>avocado.skipUnless(condition, message=None)</code></h3><p>如果条件为False,装饰器将跳过测试。</p>
<h3 id="exception-avocado-TestError"><a href="#exception-avocado-TestError" class="headerlink" title="exception avocado.TestError"></a><code>exception avocado.TestError</code></h3><p>基础：avocado.core.exceptions.TestBaseException</p>
<p>表示测试未完全执行且发生错误。</p>
<p>如果测试部分执行并且由于设置,配置或其他致命情况而无法完成,则会出现这种异常。</p>
<p><code>status =&#39;ERROR&#39;</code></p>
<h3 id="exception-avocado-TestFail"><a href="#exception-avocado-TestFail" class="headerlink" title="exception avocado.TestFail"></a>exception avocado.TestFail</h3><p>基础：avocado.core.exceptions.TestBaseException,exceptions.AssertionError</p>
<p>表示测试失败。</p>
<p>TestFail继承自AssertionError,以保持与vanilla python单元测试的兼容性(它们只考虑从AssertionError派生的失败)。</p>
<p><code>status =&#39;FAIL&#39;</code></p>
<h3 id="exception-avocado-TestCancel"><a href="#exception-avocado-TestCancel" class="headerlink" title="exception avocado.TestCancel"></a><code>exception avocado.TestCancel</code></h3><p>基础：avocado.core.exceptions.TestBaseException</p>
<p>表示测试已取消。</p>
<p>使用cancel()测试方法时应该抛出。</p>
<p><code>status = &#39;CANCEL&#39;</code></p>
<h2 id="Utilities-APIs"><a href="#Utilities-APIs" class="headerlink" title="Utilities APIs"></a><a href="https://avocado-framework.readthedocs.io/en/63.0/api/utils/avocado.utils.html" target="_blank" rel="noopener">Utilities APIs</a></h2><p>这是一组实用程序API,Avocado为测试编写者提供了附加值。</p>
<p>它假设是通用的,没有任何Avocado知识,可以在不同的项目中重复使用。</p>
<blockquote>
<p>在当前版本中,存在Avocado日志记录流的隐藏知识。 有关此问题的更多信息,请访问<a href="https://trello.com/c/4QyUgWsW/720-get-rid-of-avocado-test-loggers-from-avocado-utils" target="_blank" rel="noopener">https://trello.com/c/4QyUgWsW/720-get-rid-of-avocado-test-loggers-from-avocado-utils</a></p>
</blockquote>
<blockquote>
<p>译者：此章节为翻译,详情请查看原文档</p>
</blockquote>
<h3 id="Subpackages"><a href="#Subpackages" class="headerlink" title="Subpackages"></a>Subpackages</h3><h3 id="Submodules"><a href="#Submodules" class="headerlink" title="Submodules"></a>Submodules</h3><h3 id="avocado-utils-archive-module"><a href="#avocado-utils-archive-module" class="headerlink" title="avocado.utils.archive module"></a>avocado.utils.archive module</h3><h3 id="avocado-utils-asset-module"><a href="#avocado-utils-asset-module" class="headerlink" title="avocado.utils.asset module"></a>avocado.utils.asset module</h3><h3 id="avocado-utils-astring-module"><a href="#avocado-utils-astring-module" class="headerlink" title="avocado.utils.astring module"></a>avocado.utils.astring module</h3><h3 id="avocado-utils-aurl-module"><a href="#avocado-utils-aurl-module" class="headerlink" title="avocado.utils.aurl module"></a>avocado.utils.aurl module</h3><h3 id="avocado-utils-build-module"><a href="#avocado-utils-build-module" class="headerlink" title="avocado.utils.build module"></a>avocado.utils.build module</h3><h3 id="avocado-utils-cpu-module"><a href="#avocado-utils-cpu-module" class="headerlink" title="avocado.utils.cpu module"></a>avocado.utils.cpu module</h3><h3 id="avocado-utils-crypto-module"><a href="#avocado-utils-crypto-module" class="headerlink" title="avocado.utils.crypto module"></a>avocado.utils.crypto module</h3><h3 id="avocado-utils-data-factory-module"><a href="#avocado-utils-data-factory-module" class="headerlink" title="avocado.utils.data_factory module"></a>avocado.utils.data_factory module</h3><h3 id="avocado-utils-data-structures-module"><a href="#avocado-utils-data-structures-module" class="headerlink" title="avocado.utils.data_structures module"></a>avocado.utils.data_structures module</h3><h3 id="avocado-utils-debug-module"><a href="#avocado-utils-debug-module" class="headerlink" title="avocado.utils.debug module"></a>avocado.utils.debug module</h3><h3 id="avocado-utils-disk-module"><a href="#avocado-utils-disk-module" class="headerlink" title="avocado.utils.disk module"></a>avocado.utils.disk module</h3><h3 id="avocado-utils-download-module"><a href="#avocado-utils-download-module" class="headerlink" title="avocado.utils.download module"></a>avocado.utils.download module</h3><h3 id="avocado-utils-filelock-module"><a href="#avocado-utils-filelock-module" class="headerlink" title="avocado.utils.filelock module"></a>avocado.utils.filelock module</h3><h3 id="avocado-utils-gdb-module"><a href="#avocado-utils-gdb-module" class="headerlink" title="avocado.utils.gdb module"></a>avocado.utils.gdb module</h3><h3 id="avocado-utils-genio-module"><a href="#avocado-utils-genio-module" class="headerlink" title="avocado.utils.genio module"></a>avocado.utils.genio module</h3><h3 id="avocado-utils-git-module"><a href="#avocado-utils-git-module" class="headerlink" title="avocado.utils.git module"></a>avocado.utils.git module</h3><h3 id="avocado-utils-disk-module-1"><a href="#avocado-utils-disk-module-1" class="headerlink" title="avocado.utils.disk module"></a>avocado.utils.disk module</h3><h3 id="avocado-utils-distro-module"><a href="#avocado-utils-distro-module" class="headerlink" title="avocado.utils.distro module"></a>avocado.utils.distro module</h3><h3 id="avocado-utils-download-module-1"><a href="#avocado-utils-download-module-1" class="headerlink" title="avocado.utils.download module"></a>avocado.utils.download module</h3><h3 id="avocado-utils-filelock-module-1"><a href="#avocado-utils-filelock-module-1" class="headerlink" title="avocado.utils.filelock module"></a>avocado.utils.filelock module</h3><h3 id="avocado-utils-gdb-module-1"><a href="#avocado-utils-gdb-module-1" class="headerlink" title="avocado.utils.gdb module"></a>avocado.utils.gdb module</h3><h3 id="avocado-utils-genio-module-1"><a href="#avocado-utils-genio-module-1" class="headerlink" title="avocado.utils.genio module"></a>avocado.utils.genio module</h3><h3 id="avocado-utils-git-module-1"><a href="#avocado-utils-git-module-1" class="headerlink" title="avocado.utils.git module"></a>avocado.utils.git module</h3><h3 id="avocado-utils-iso9660-module"><a href="#avocado-utils-iso9660-module" class="headerlink" title="avocado.utils.iso9660 module"></a>avocado.utils.iso9660 module</h3><h3 id="avocado-utils-kernel-module"><a href="#avocado-utils-kernel-module" class="headerlink" title="avocado.utils.kernel module"></a>avocado.utils.kernel module</h3><h3 id="avocado-utils-linux-modules-module"><a href="#avocado-utils-linux-modules-module" class="headerlink" title="avocado.utils.linux_modules module"></a>avocado.utils.linux_modules module</h3><h3 id="avocado-utils-lv-utils-module"><a href="#avocado-utils-lv-utils-module" class="headerlink" title="avocado.utils.lv_utils module"></a>avocado.utils.lv_utils module</h3><h3 id="avocado-utils-memory-module"><a href="#avocado-utils-memory-module" class="headerlink" title="avocado.utils.memory module"></a>avocado.utils.memory module</h3><h3 id="avocado-utils-multipath-module"><a href="#avocado-utils-multipath-module" class="headerlink" title="avocado.utils.multipath module"></a>avocado.utils.multipath module</h3><h3 id="avocado-utils-network-module"><a href="#avocado-utils-network-module" class="headerlink" title="avocado.utils.network module"></a>avocado.utils.network module</h3><h3 id="avocado-utils-output-module"><a href="#avocado-utils-output-module" class="headerlink" title="avocado.utils.output module"></a>avocado.utils.output module</h3><h3 id="avocado-utils-partition-module"><a href="#avocado-utils-partition-module" class="headerlink" title="avocado.utils.partition module"></a>avocado.utils.partition module</h3><h3 id="avocado-utils-path-module"><a href="#avocado-utils-path-module" class="headerlink" title="avocado.utils.path module"></a>avocado.utils.path module</h3><h3 id="avocado-utils-pci-module"><a href="#avocado-utils-pci-module" class="headerlink" title="avocado.utils.pci module"></a>avocado.utils.pci module</h3><h3 id="avocado-utils-process-module"><a href="#avocado-utils-process-module" class="headerlink" title="avocado.utils.process module"></a>avocado.utils.process module</h3><h3 id="avocado-utils-runtime-module"><a href="#avocado-utils-runtime-module" class="headerlink" title="avocado.utils.runtime module"></a>avocado.utils.runtime module</h3><h3 id="avocado-utils-script-module"><a href="#avocado-utils-script-module" class="headerlink" title="avocado.utils.script module"></a>avocado.utils.script module</h3><h3 id="avocado-utils-service-module"><a href="#avocado-utils-service-module" class="headerlink" title="avocado.utils.service module"></a>avocado.utils.service module</h3><h3 id="avocado-utils-software-manager-module"><a href="#avocado-utils-software-manager-module" class="headerlink" title="avocado.utils.software_manager module"></a>avocado.utils.software_manager module</h3><h3 id="avocado-utils-stacktrace-module"><a href="#avocado-utils-stacktrace-module" class="headerlink" title="avocado.utils.stacktrace module"></a>avocado.utils.stacktrace module</h3><h3 id="avocado-utils-vmimage-module"><a href="#avocado-utils-vmimage-module" class="headerlink" title="avocado.utils.vmimage module"></a>avocado.utils.vmimage module</h3><h3 id="avocado-utils-wait-module"><a href="#avocado-utils-wait-module" class="headerlink" title="avocado.utils.wait module"></a>avocado.utils.wait module</h3><h3 id="Module-contents"><a href="#Module-contents" class="headerlink" title="Module contents"></a>Module contents</h3><h2 id="内部-核心-API"><a href="#内部-核心-API" class="headerlink" title="内部(核心)API"></a><a href="https://avocado-framework.readthedocs.io/en/63.0/api/core/avocado.core.html" target="_blank" rel="noopener">内部(核心)API</a></h2><p>可能是Avocado 骇客感兴趣的内部API.</p>
<blockquote>
<p>译者:此节未翻译,更多内容请查看原文档</p>
</blockquote>
<h2 id="扩展-插件-API"><a href="#扩展-插件-API" class="headerlink" title="扩展(插件)API"></a><a href="https://avocado-framework.readthedocs.io/en/63.0/api/plugins/avocado.plugins.html" target="_blank" rel="noopener">扩展(插件)API</a></h2><p>扩展API可能是插件编写者兴趣所在.</p>
<blockquote>
<p>译者:此节未翻译,更多内容请查看原文档</p>
</blockquote>
<h2 id="可选插件API"><a href="#可选插件API" class="headerlink" title="可选插件API"></a><a href="https://avocado-framework.readthedocs.io/en/63.0/api/optional-plugins/index.html" target="_blank" rel="noopener">可选插件API</a></h2><p>下面的页面记录了可选的Avocado插件的私有API。</p>
<ul>
<li><a href="avocado_glib/avocado_glib.html">avocado_glib package</a></li>
<li><a href="avocado_runner_docker/avocado_runner_docker.html">avocado_runner_docker package</a></li>
<li><a href="avocado_resultsdb/avocado_resultsdb.html">avocado_resultsdb package</a></li>
<li><a href="avocado_varianter_yaml_to_mux/avocado_varianter_yaml_to_mux.html">avocado_varianter_yaml_to_mux package</a></li>
<li><a href="avocado_result_upload/avocado_result_upload.html">avocado_result_upload package</a></li>
<li><a href="avocado_runner_remote/avocado_runner_remote.html">avocado_runner_remote package</a></li>
<li><a href="avocado_robot/avocado_robot.html">avocado_robot package</a></li>
<li><a href="avocado_loader_yaml/avocado_loader_yaml.html">avocado_loader_yaml package</a></li>
<li><a href="avocado_varianter_pict/avocado_varianter_pict.html">avocado_varianter_pict package</a></li>
<li><a href="avocado_golang/avocado_golang.html">avocado_golang package</a></li>
</ul>
<h2 id="发行说明"><a href="#发行说明" class="headerlink" title="发行说明"></a><a href="https://avocado-framework.readthedocs.io/en/63.0/release_notes/index.html" target="_blank" rel="noopener">发行说明</a></h2><blockquote>
<p>译者:此节未翻译,更多内容请查看原文档</p>
</blockquote>
<h2 id="征求意见稿-RFCS"><a href="#征求意见稿-RFCS" class="headerlink" title="征求意见稿(RFCS)"></a><a href="https://avocado-framework.readthedocs.io/en/63.0/rfcs/index.html" target="_blank" rel="noopener">征求意见稿(RFCS)</a></h2><blockquote>
<p>译者:此节未翻译,更多内容请查看原文档</p>
</blockquote>
<h2 id="原文档"><a href="#原文档" class="headerlink" title="原文档"></a>原文档</h2><p><a href="https://avocado-framework.readthedocs.io/en/63.0/Introduction.html" target="_blank" rel="noopener">原文档</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/测试/" rel="tag"># 测试</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/07/12/前端/chrome从任何页面运行脚本snippets/" rel="next" title="chrome从任何页面运行脚本snippets">
                <i class="fa fa-chevron-left"></i> chrome从任何页面运行脚本snippets
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/07/25/python/2.python标准库/python正则表达式2/" rel="prev" title="深入理解正则表达式">
                深入理解正则表达式 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div id="gitalk-container"></div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/rem.png" alt="李云鹏">
            
              <p class="site-author-name" itemprop="name">李云鹏</p>
              <p class="site-description motion-element" itemprop="description">萍水相逢也是前世之缘</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">219</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#关于Avocado"><span class="nav-number">1.</span> <span class="nav-text">关于Avocado</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#入门"><span class="nav-number">2.</span> <span class="nav-text">入门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#安装Avocado"><span class="nav-number">2.1.</span> <span class="nav-text">安装Avocado</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用标准Python工具进行安装"><span class="nav-number">2.1.1.</span> <span class="nav-text">使用标准Python工具进行安装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#从包安装"><span class="nav-number">2.1.2.</span> <span class="nav-text">从包安装</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用Avocado"><span class="nav-number">2.2.</span> <span class="nav-text">使用Avocado</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#运行测试"><span class="nav-number">2.2.1.</span> <span class="nav-text">运行测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#列出测试"><span class="nav-number">2.2.2.</span> <span class="nav-text">列出测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#写一个简单的测试"><span class="nav-number">2.2.3.</span> <span class="nav-text">写一个简单的测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#运行更复杂的测试工作"><span class="nav-number">2.2.4.</span> <span class="nav-text">运行更复杂的测试工作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在第一次失败的测试中中断job-failfast"><span class="nav-number">2.2.5.</span> <span class="nav-text">在第一次失败的测试中中断job(failfast)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#忽略缺少的测试引用"><span class="nav-number">2.2.6.</span> <span class="nav-text">忽略缺少的测试引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用外部运行器运行测试"><span class="nav-number">2.2.7.</span> <span class="nav-text">使用外部运行器运行测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#但现在考虑以下示例："><span class="nav-number">2.2.8.</span> <span class="nav-text">但现在考虑以下示例：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调试测试"><span class="nav-number">2.3.</span> <span class="nav-text">调试测试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#显示测试输出"><span class="nav-number">2.3.1.</span> <span class="nav-text">显示测试输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#中断测试执行"><span class="nav-number">2.3.2.</span> <span class="nav-text">中断测试执行</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#书写Avocado测试"><span class="nav-number">3.</span> <span class="nav-text">书写Avocado测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本示例"><span class="nav-number">3.1.</span> <span class="nav-text">基本示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是Avocado测试"><span class="nav-number">3.1.1.</span> <span class="nav-text">什么是Avocado测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多个测试和命名约定"><span class="nav-number">3.1.2.</span> <span class="nav-text">多个测试和命名约定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#便利属性"><span class="nav-number">3.1.3.</span> <span class="nav-text">便利属性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#测试状态"><span class="nav-number">3.2.</span> <span class="nav-text">测试状态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#测试方法"><span class="nav-number">3.2.1.</span> <span class="nav-text">测试方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#将错误转化为失败"><span class="nav-number">3.2.2.</span> <span class="nav-text">将错误转化为失败</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#保存测试生成的-自定义-数据"><span class="nav-number">3.3.</span> <span class="nav-text">保存测试生成的(自定义)数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问测试数据文件"><span class="nav-number">3.4.</span> <span class="nav-text">访问测试数据文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问测试参数"><span class="nav-number">3.5.</span> <span class="nav-text">访问测试参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行多个测试变量"><span class="nav-number">3.6.</span> <span class="nav-text">运行多个测试变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高级日志记录功能"><span class="nav-number">3.7.</span> <span class="nav-text">高级日志记录功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unittest-TestCase继承"><span class="nav-number">3.8.</span> <span class="nav-text">unittest.TestCase继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#在其它单元测试下运行测试脚本"><span class="nav-number">3.8.1.</span> <span class="nav-text">在其它单元测试下运行测试脚本</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Setup和cleanup方法"><span class="nav-number">3.9.</span> <span class="nav-text">Setup和cleanup方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行第三方测试套件"><span class="nav-number">3.10.</span> <span class="nav-text">运行第三方测试套件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取资产文件"><span class="nav-number">3.11.</span> <span class="nav-text">获取资产文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#测试输出检查和输出记录模式"><span class="nav-number">3.12.</span> <span class="nav-text">测试输出检查和输出记录模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在本机Avocado模块中测试日志-stdout和stderr"><span class="nav-number">3.13.</span> <span class="nav-text">在本机Avocado模块中测试日志,stdout和stderr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设置测试超时"><span class="nav-number">3.14.</span> <span class="nav-text">设置测试超时</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#跳过测试"><span class="nav-number">3.15.</span> <span class="nav-text">跳过测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#取消测试"><span class="nav-number">3.16.</span> <span class="nav-text">取消测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docstring指令"><span class="nav-number">3.17.</span> <span class="nav-text">Docstring指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#显式启用或禁用测试"><span class="nav-number">3.17.1.</span> <span class="nav-text">显式启用或禁用测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#递归发现测试"><span class="nav-number">3.17.2.</span> <span class="nav-text">递归发现测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分类测试"><span class="nav-number">3.17.3.</span> <span class="nav-text">分类测试</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Python-unittest兼容性限制和警告"><span class="nav-number">3.18.</span> <span class="nav-text">Python unittest兼容性限制和警告</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#测试的环境变量"><span class="nav-number">3.19.</span> <span class="nav-text">测试的环境变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SIMPLE测试BASH扩展"><span class="nav-number">3.20.</span> <span class="nav-text">SIMPLE测试BASH扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简单的测试状态"><span class="nav-number">3.21.</span> <span class="nav-text">简单的测试状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本文小节"><span class="nav-number">3.22.</span> <span class="nav-text">本文小节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结果格式化"><span class="nav-number">4.</span> <span class="nav-text">结果格式化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#人类可读结果"><span class="nav-number">4.1.</span> <span class="nav-text">人类可读结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#机器可读结果"><span class="nav-number">4.2.</span> <span class="nav-text">机器可读结果</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#xunit"><span class="nav-number">4.2.1.</span> <span class="nav-text">xunit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JSON"><span class="nav-number">4.2.2.</span> <span class="nav-text">JSON</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TAP"><span class="nav-number">4.2.3.</span> <span class="nav-text">TAP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Silent-result"><span class="nav-number">4.2.4.</span> <span class="nav-text">Silent result</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一次获得多个结果"><span class="nav-number">4.3.</span> <span class="nav-text">一次获得多个结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#退出码"><span class="nav-number">4.4.</span> <span class="nav-text">退出码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现其他结果格式"><span class="nav-number">4.5.</span> <span class="nav-text">实现其他结果格式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置"><span class="nav-number">5.</span> <span class="nav-text">配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#配置文件解析顺序"><span class="nav-number">5.1.</span> <span class="nav-text">配置文件解析顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#插件配置文件"><span class="nav-number">5.2.</span> <span class="nav-text">插件配置文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解析顺序重述"><span class="nav-number">5.3.</span> <span class="nav-text">解析顺序重述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#测试中使用的值的优先顺序"><span class="nav-number">5.4.</span> <span class="nav-text">测试中使用的值的优先顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#配置插件"><span class="nav-number">5.5.</span> <span class="nav-text">配置插件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Avocado数据目录"><span class="nav-number">5.6.</span> <span class="nav-text">Avocado数据目录</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#测试发现"><span class="nav-number">6.</span> <span class="nav-text">测试发现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#测试loader的顺序"><span class="nav-number">6.1.</span> <span class="nav-text">测试loader的顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用参数运行简单测试"><span class="nav-number">6.2.</span> <span class="nav-text">使用参数运行简单测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过标签过滤测试"><span class="nav-number">6.3.</span> <span class="nav-text">通过标签过滤测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#测试引用-Test-References"><span class="nav-number">6.4.</span> <span class="nav-text">测试引用 Test References</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文件加载器"><span class="nav-number">6.4.1.</span> <span class="nav-text">文件加载器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#外部加载器"><span class="nav-number">6.4.2.</span> <span class="nav-text">外部加载器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#日志系统"><span class="nav-number">7.</span> <span class="nav-text">日志系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#调整UI"><span class="nav-number">7.1.</span> <span class="nav-text">调整UI</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存储自定义日志"><span class="nav-number">7.2.</span> <span class="nav-text">存储自定义日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分页器"><span class="nav-number">7.3.</span> <span class="nav-text">分页器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sysinfo收集"><span class="nav-number">8.</span> <span class="nav-text">sysinfo收集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#测试参数"><span class="nav-number">9.</span> <span class="nav-text">测试参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TreeNode"><span class="nav-number">9.1.</span> <span class="nav-text">TreeNode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AvocadoParams"><span class="nav-number">9.2.</span> <span class="nav-text">AvocadoParams</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参数路径-Parameter-Paths"><span class="nav-number">9.3.</span> <span class="nav-text">参数路径 Parameter Paths</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Variant"><span class="nav-number">9.4.</span> <span class="nav-text">Variant</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dumping-Loading-Variants"><span class="nav-number">9.5.</span> <span class="nav-text">Dumping/Loading Variants</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Varianter"><span class="nav-number">9.6.</span> <span class="nav-text">Varianter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Default-params"><span class="nav-number">9.7.</span> <span class="nav-text">Default params</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Varianter-plugins"><span class="nav-number">9.8.</span> <span class="nav-text">Varianter plugins</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Multiplexer"><span class="nav-number">9.9.</span> <span class="nav-text">Multiplexer</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Multiplexer-concept"><span class="nav-number">9.9.1.</span> <span class="nav-text">Multiplexer concept</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Multiplex-domains"><span class="nav-number">9.10.</span> <span class="nav-text">Multiplex domains</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MuxPlugin"><span class="nav-number">9.11.</span> <span class="nav-text">MuxPlugin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MuxTree"><span class="nav-number">9.12.</span> <span class="nav-text">MuxTree</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#工作重演"><span class="nav-number">10.</span> <span class="nav-text">工作重演</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#工作差异"><span class="nav-number">11.</span> <span class="nav-text">工作差异</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#远程运行测试"><span class="nav-number">12.</span> <span class="nav-text">远程运行测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Avocado子类"><span class="nav-number">13.</span> <span class="nav-text">Avocado子类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用GDB-Debugging"><span class="nav-number">14.</span> <span class="nav-text">使用GDB Debugging</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通过测试运行可执行包"><span class="nav-number">15.</span> <span class="nav-text">通过测试运行可执行包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#警示"><span class="nav-number">15.1.</span> <span class="nav-text">警示</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#插件系统"><span class="nav-number">16.</span> <span class="nav-text">插件系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Utilities"><span class="nav-number">17.</span> <span class="nav-text">Utilities</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可选插件"><span class="nav-number">18.</span> <span class="nav-text">可选插件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考指南"><span class="nav-number">19.</span> <span class="nav-text">参考指南</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#贡献与社区指南"><span class="nav-number">20.</span> <span class="nav-text">贡献与社区指南</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Avocado发展要点"><span class="nav-number">21.</span> <span class="nav-text">Avocado发展要点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#释放avocado"><span class="nav-number">22.</span> <span class="nav-text">释放avocado</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其它资源"><span class="nav-number">23.</span> <span class="nav-text">其它资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#测试API文档"><span class="nav-number">24.</span> <span class="nav-text">测试API文档</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-main"><span class="nav-number">24.1.</span> <span class="nav-text">avocado.main</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#class-avocado-Test-methodName-39-test-39-name-None-params-None-base-logdir-None-job-None-runner-queue-None"><span class="nav-number">24.2.</span> <span class="nav-text">class avocado.Test(methodName=&#39;test&#39;, name=None, params=None, base_logdir=None, job=None, runner_queue=None)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#basedir"><span class="nav-number">24.2.1.</span> <span class="nav-text">basedir</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cache-dirs"><span class="nav-number">24.2.2.</span> <span class="nav-text">cache_dirs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cancel-message-None"><span class="nav-number">24.2.3.</span> <span class="nav-text">cancel(message=None)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#error-message-None"><span class="nav-number">24.2.4.</span> <span class="nav-text">error(message=None)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fail-message-None"><span class="nav-number">24.2.5.</span> <span class="nav-text">fail(message=None)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fail-class"><span class="nav-number">24.2.6.</span> <span class="nav-text">fail_class</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fail-reason"><span class="nav-number">24.2.7.</span> <span class="nav-text">fail_reason</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fetch-asset-name-asset-hash-None-algorithm-None-locations-None-expire-None"><span class="nav-number">24.2.8.</span> <span class="nav-text">fetch_asset(name,asset_hash = None,algorithm = None,locations = None,expire = None)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#filename"><span class="nav-number">24.2.9.</span> <span class="nav-text">filename</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#get-state"><span class="nav-number">24.2.10.</span> <span class="nav-text">get_state()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#job"><span class="nav-number">24.2.11.</span> <span class="nav-text">job</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#log"><span class="nav-number">24.2.12.</span> <span class="nav-text">log</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#logdir"><span class="nav-number">24.2.13.</span> <span class="nav-text">logdir</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#logfile"><span class="nav-number">24.2.14.</span> <span class="nav-text">logfile</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#name"><span class="nav-number">24.2.15.</span> <span class="nav-text">name</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#outputdir"><span class="nav-number">24.2.16.</span> <span class="nav-text">outputdir</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#params"><span class="nav-number">24.2.17.</span> <span class="nav-text">params</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#report-state"><span class="nav-number">24.2.18.</span> <span class="nav-text">report_state()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#run-avocado"><span class="nav-number">24.2.19.</span> <span class="nav-text">run_avocado()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#runner-queue"><span class="nav-number">24.2.20.</span> <span class="nav-text">runner_queue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#running"><span class="nav-number">24.2.21.</span> <span class="nav-text">running</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#set-runner-queue-runner-queue"><span class="nav-number">24.2.22.</span> <span class="nav-text">set_runner_queue(runner_queue)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#status"><span class="nav-number">24.2.23.</span> <span class="nav-text">status</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#teststmpdir"><span class="nav-number">24.2.24.</span> <span class="nav-text">teststmpdir</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#time-elapsed-1"><span class="nav-number">24.2.25.</span> <span class="nav-text">time_elapsed = -1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#time-end-1"><span class="nav-number">24.2.26.</span> <span class="nav-text">time_end = -1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#time-start-1"><span class="nav-number">24.2.27.</span> <span class="nav-text">time_start = -1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#timeout-None"><span class="nav-number">24.2.28.</span> <span class="nav-text">timeout = None</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#traceback"><span class="nav-number">24.2.29.</span> <span class="nav-text">traceback</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#whiteboard"><span class="nav-number">24.2.30.</span> <span class="nav-text">whiteboard=</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#workdir"><span class="nav-number">24.2.31.</span> <span class="nav-text">workdir</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-fail-on-exceptions-None"><span class="nav-number">24.3.</span> <span class="nav-text">avocado.fail_on(exceptions=None)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-skip-message-None"><span class="nav-number">24.4.</span> <span class="nav-text">avocado.skip(message=None)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-skipIf-condition-message-None"><span class="nav-number">24.5.</span> <span class="nav-text">avocado.skipIf(condition, message=None)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-skipUnless-condition-message-None"><span class="nav-number">24.6.</span> <span class="nav-text">avocado.skipUnless(condition, message=None)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exception-avocado-TestError"><span class="nav-number">24.7.</span> <span class="nav-text">exception avocado.TestError</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exception-avocado-TestFail"><span class="nav-number">24.8.</span> <span class="nav-text">exception avocado.TestFail</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exception-avocado-TestCancel"><span class="nav-number">24.9.</span> <span class="nav-text">exception avocado.TestCancel</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Utilities-APIs"><span class="nav-number">25.</span> <span class="nav-text">Utilities APIs</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Subpackages"><span class="nav-number">25.1.</span> <span class="nav-text">Subpackages</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Submodules"><span class="nav-number">25.2.</span> <span class="nav-text">Submodules</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-archive-module"><span class="nav-number">25.3.</span> <span class="nav-text">avocado.utils.archive module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-asset-module"><span class="nav-number">25.4.</span> <span class="nav-text">avocado.utils.asset module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-astring-module"><span class="nav-number">25.5.</span> <span class="nav-text">avocado.utils.astring module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-aurl-module"><span class="nav-number">25.6.</span> <span class="nav-text">avocado.utils.aurl module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-build-module"><span class="nav-number">25.7.</span> <span class="nav-text">avocado.utils.build module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-cpu-module"><span class="nav-number">25.8.</span> <span class="nav-text">avocado.utils.cpu module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-crypto-module"><span class="nav-number">25.9.</span> <span class="nav-text">avocado.utils.crypto module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-data-factory-module"><span class="nav-number">25.10.</span> <span class="nav-text">avocado.utils.data_factory module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-data-structures-module"><span class="nav-number">25.11.</span> <span class="nav-text">avocado.utils.data_structures module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-debug-module"><span class="nav-number">25.12.</span> <span class="nav-text">avocado.utils.debug module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-disk-module"><span class="nav-number">25.13.</span> <span class="nav-text">avocado.utils.disk module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-download-module"><span class="nav-number">25.14.</span> <span class="nav-text">avocado.utils.download module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-filelock-module"><span class="nav-number">25.15.</span> <span class="nav-text">avocado.utils.filelock module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-gdb-module"><span class="nav-number">25.16.</span> <span class="nav-text">avocado.utils.gdb module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-genio-module"><span class="nav-number">25.17.</span> <span class="nav-text">avocado.utils.genio module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-git-module"><span class="nav-number">25.18.</span> <span class="nav-text">avocado.utils.git module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-disk-module-1"><span class="nav-number">25.19.</span> <span class="nav-text">avocado.utils.disk module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-distro-module"><span class="nav-number">25.20.</span> <span class="nav-text">avocado.utils.distro module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-download-module-1"><span class="nav-number">25.21.</span> <span class="nav-text">avocado.utils.download module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-filelock-module-1"><span class="nav-number">25.22.</span> <span class="nav-text">avocado.utils.filelock module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-gdb-module-1"><span class="nav-number">25.23.</span> <span class="nav-text">avocado.utils.gdb module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-genio-module-1"><span class="nav-number">25.24.</span> <span class="nav-text">avocado.utils.genio module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-git-module-1"><span class="nav-number">25.25.</span> <span class="nav-text">avocado.utils.git module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-iso9660-module"><span class="nav-number">25.26.</span> <span class="nav-text">avocado.utils.iso9660 module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-kernel-module"><span class="nav-number">25.27.</span> <span class="nav-text">avocado.utils.kernel module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-linux-modules-module"><span class="nav-number">25.28.</span> <span class="nav-text">avocado.utils.linux_modules module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-lv-utils-module"><span class="nav-number">25.29.</span> <span class="nav-text">avocado.utils.lv_utils module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-memory-module"><span class="nav-number">25.30.</span> <span class="nav-text">avocado.utils.memory module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-multipath-module"><span class="nav-number">25.31.</span> <span class="nav-text">avocado.utils.multipath module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-network-module"><span class="nav-number">25.32.</span> <span class="nav-text">avocado.utils.network module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-output-module"><span class="nav-number">25.33.</span> <span class="nav-text">avocado.utils.output module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-partition-module"><span class="nav-number">25.34.</span> <span class="nav-text">avocado.utils.partition module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-path-module"><span class="nav-number">25.35.</span> <span class="nav-text">avocado.utils.path module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-pci-module"><span class="nav-number">25.36.</span> <span class="nav-text">avocado.utils.pci module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-process-module"><span class="nav-number">25.37.</span> <span class="nav-text">avocado.utils.process module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-runtime-module"><span class="nav-number">25.38.</span> <span class="nav-text">avocado.utils.runtime module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-script-module"><span class="nav-number">25.39.</span> <span class="nav-text">avocado.utils.script module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-service-module"><span class="nav-number">25.40.</span> <span class="nav-text">avocado.utils.service module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-software-manager-module"><span class="nav-number">25.41.</span> <span class="nav-text">avocado.utils.software_manager module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-stacktrace-module"><span class="nav-number">25.42.</span> <span class="nav-text">avocado.utils.stacktrace module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-vmimage-module"><span class="nav-number">25.43.</span> <span class="nav-text">avocado.utils.vmimage module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#avocado-utils-wait-module"><span class="nav-number">25.44.</span> <span class="nav-text">avocado.utils.wait module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Module-contents"><span class="nav-number">25.45.</span> <span class="nav-text">Module contents</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内部-核心-API"><span class="nav-number">26.</span> <span class="nav-text">内部(核心)API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展-插件-API"><span class="nav-number">27.</span> <span class="nav-text">扩展(插件)API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可选插件API"><span class="nav-number">28.</span> <span class="nav-text">可选插件API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#发行说明"><span class="nav-number">29.</span> <span class="nav-text">发行说明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#征求意见稿-RFCS"><span class="nav-number">30.</span> <span class="nav-text">征求意见稿(RFCS)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原文档"><span class="nav-number">31.</span> <span class="nav-text">原文档</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李云鹏</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      本站访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      本站总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    //这两句是调用作者的css和js文件
    <script src="/js/src/md5.min.js"></script>
    <script type="text/javascript">
        var gitalk = new Gitalk({       //这里面的参数我们会在另一个文件中配置
            clientID:  '5a3c5360539711069cd5',
            clientSecret: '2c5c5bde68afec70aecc213b1d0e42bc929f3583',
            repo: 'gaianote.github.io',
            owner: 'gaianote',
            admin: 'gaianote',
            id: md5(location.pathname),
            distractionFreeMode: '',
          })
          gitalk.render('gitalk-container')
    </script>

  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
