<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="萍水相逢也是前世之缘">
<meta property="og:type" content="website">
<meta property="og:title" content="李云鹏的个人博客">
<meta property="og:url" content="http://gaianote.github.io/page/8/index.html">
<meta property="og:site_name" content="李云鹏的个人博客">
<meta property="og:description" content="萍水相逢也是前世之缘">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="李云鹏的个人博客">
<meta name="twitter:description" content="萍水相逢也是前世之缘">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://gaianote.github.io/page/8/">





  <title>李云鹏的个人博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">李云鹏的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gaianote.github.io/2019/03/23/linux/1.常用命令/使用dd命令快速生成大文件或者小文件的方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李云鹏">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/rem.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李云鹏的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/23/linux/1.常用命令/使用dd命令快速生成大文件或者小文件的方法/" itemprop="url">使用dd命令快速生成大文件或者小文件的方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-23T12:11:38+00:00">
                2019-03-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在程序的测试中有些场景需要大量的小文件或者几个比较大的文件，而在我们的文件系统里一时无法找到那么多或者那么大的文件，此时linux的dd命令就能快速的帮助你完成想要的文件。具体用法简单总结如下：</p>
<h2 id="dd命令可以轻易实现创建指定大小的文件，如"><a href="#dd命令可以轻易实现创建指定大小的文件，如" class="headerlink" title="dd命令可以轻易实现创建指定大小的文件，如"></a>dd命令可以轻易实现创建指定大小的文件，如</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero of=A bs=1M count=1000</span><br></pre></td></tr></table></figure>
<p>在当前目录下会生成一个1000M的test文件，文件内容为全0（因从/dev/zero中读取，/dev/zero为0源），但是这样为实际写入硬盘，文件产生速度取决于硬盘读写速度，如果欲产生超大文件，速度很慢。在某种场景下，我们只想让文件系统认为存在一个超大文件在此，但是并不实际写入硬盘</p>
<p>则可以</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero of=A bs=1M count=0 seek=1000</span><br></pre></td></tr></table></figure>
<p>此时创建的文件在文件系统中的显示大小为10000MB，但是并不实际占用block，因此创建速度与内存速度相当，seek的作用是跳过输出文件中指定大小的部分，这就达到了创建大文件，但是并不实际写入的目的。当然，因为不实际写入硬盘，所以你在容量只有10G的硬盘上创建100G的此类文件都是可以的。</p>
<h2 id="随机生成1百万个1K的文件"><a href="#随机生成1百万个1K的文件" class="headerlink" title="随机生成1百万个1K的文件"></a>随机生成1百万个1K的文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seq 1000000 | xargs -i dd <span class="keyword">if</span>=/dev/zero of=&#123;&#125;.dat bs=1024 count=1</span><br></pre></td></tr></table></figure>
<h2 id="当你不需要关心随机文件的内容，只需一个固定大小的文件"><a href="#当你不需要关心随机文件的内容，只需一个固定大小的文件" class="headerlink" title="当你不需要关心随机文件的内容，只需一个固定大小的文件"></a>当你不需要关心随机文件的内容，只需一个固定大小的文件</h2><p>Solaris、Mac OS X等Unix系统中mkfile指令，可以产生指定大小的文件，而Linux上则没有<br>例子：mkfile -n 160g test1<br>Linux可以用dd指令，/dev/zero是一个特别的文件描述符可以通过它返回null值<br>例子：dd if=/dev/zero of=test.file count=1024 bs=1024<br>产生count * bs字节的文件，1M<br>此方法生成随机文件的好处在于效率高（产生1G文件大概1s）,创建的文件大小精确到字节<br>坏处也有<br>使用null字符来填充文件内容，文件统计时没有行（wc -l test.file为0）</p>
<h2 id="当你不需要关心随机文件的内容，但期望测试文件能有统计的行"><a href="#当你不需要关心随机文件的内容，但期望测试文件能有统计的行" class="headerlink" title="当你不需要关心随机文件的内容，但期望测试文件能有统计的行"></a>当你不需要关心随机文件的内容，但期望测试文件能有统计的行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/urandom of=A bs=1M count=100</span><br></pre></td></tr></table></figure>
<p>将<code>/dev/zero</code> 改为<code>/dev/urandom</code>，<code>/dev/urandom</code>是linux下的随机数生成器</p>
<p>关于<code>/dev/urandom</code>跟<code>/dev/random</code>两者的区别就不在此详细讨论，大概就是，前者是不受系统interrupts的限制，即使没有足够的interrupt它也能通过随机数生成器产生足够的输出值；而后者如果用在dd上，它不能被ctrl+c或者kill -9中断，如果ds的值较大时，产生的随机值不足而长期占用CPU。虽然说<code>/dev/random</code>产生的随机数会更随机些，但与dd混用还是建议用<code>/dev/urandom</code>效率更高。</p>
<p>缺点跟<code>/dev/zero</code>比当然是效率会更低些了，生成个100Mb的文件需要10秒左右，而且文件并没有可读的内容，一般的情况基本上是满足了。</p>
<p>漏了说句，dd是linux与unix都支持的指令。</p>
<h2 id="当你关心文件的随机内容行数，而不关心内容是否有所重复"><a href="#当你关心文件的随机内容行数，而不关心内容是否有所重复" class="headerlink" title="当你关心文件的随机内容行数，而不关心内容是否有所重复"></a>当你关心文件的随机内容行数，而不关心内容是否有所重复</h2><p>这里的思路就是找一个参照文件（比如说2行），将文件重新定向到新的文件，再mv覆盖保存，外加一个for循环。（n为循环次数，产生的文件行为2^（n+1））</p>
<p>例子:假设先建立一个file.txt文件，里面含有Hello 和 World两行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in &#123;1..n&#125;; do cat file.txt file.txt &gt; file2.txt &amp;&amp; mv file2.txt file.txt; done</span><br></pre></td></tr></table></figure>
<p>由于是阶乘，n=20左右已经是200W行，效率会下降地比较厉害</p>
<h2 id="当你关心随机文件的内容，而不想出现重复内容行情况"><a href="#当你关心随机文件的内容，而不想出现重复内容行情况" class="headerlink" title="当你关心随机文件的内容，而不想出现重复内容行情况"></a>当你关心随机文件的内容，而不想出现重复内容行情况</h2><p>这种情况下系统的指令应该是不能满足了，或者可以通过操作系统的指令写一大串脚本也可以达到，但不建议这么做，因为可读性和维护性考虑，你应该要引入Ruby或者Python类的脚本语言帮忙了<br>但还是要借助些系统的东西来帮忙</p>
<p>思路：/usr/share/dict/words里面有记录一些单词，一共235886行，每行一个单词<br>可以从里面挑选一些作为文件的内容<br>加循环达到我们想要的随机文件要求</p>
<p>举例：ruby -e ‘a=STDIN.readlines;X.times do; b=[];Y.times do; b&lt;&lt;a[rand(a.size)].chomp end; puts b.join(“ “)’ &lt; /usr/share/dict/words &gt; file.txt</p>
<p>X为随机文件需要的行数，Y为从words中读取的单词，虽说组合成一句的命令，还是可以读懂的；从标准输入中重复读取Y个单词，写入到b列表中，然后再通过join空格连接内容写入到标准输出文件file.txt中</p>
<p>这样基本很少会有重复的行了，而且生成的效率与其他方法对比还是可以的，10秒生成100Mb文件。欢迎大家讨论。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gaianote.github.io/2019/03/22/linux/1.常用命令/Linux下查看PCI-E插槽信息的方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李云鹏">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/rem.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李云鹏的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/22/linux/1.常用命令/Linux下查看PCI-E插槽信息的方法/" itemprop="url">Linux下查看PCI-E插槽信息的方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-22T12:12:33+00:00">
                2019-03-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在 Linux 下要如何得知 PCI-E Bus 使用的是 Gen(Generation) 1 還是 Gen2 還是新一代的 Gen 3 雖然使用 #lspci 只要可以看到目前系統所有的裝置.但是好像看不到 PCI-E Bus 所採用的是哪一代的 PCI-E.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@benjr ~]<span class="comment"># lspci</span></span><br><span class="line">00:00.0 Class 0604: 16c3:abcd</span><br><span class="line">00:01.0 Class 0604: 16c3:abcd</span><br><span class="line">00:02.0 Class 0604: 16c3:abcd</span><br><span class="line">00:03.0 Class 0604: 16c3:abcd</span><br><span class="line">01:00.0 Class 0604: 10b5:8716</span><br><span class="line">0d:00.0 Class 0c04: 1077:2971</span><br><span class="line">0d:00.1 Class 0c04: 1077:2971</span><br><span class="line">0d:00.2 Class 0c04: 1077:2971</span><br><span class="line">0d:00.3 Class 0c04: 1077:2971</span><br></pre></td></tr></table></figure>
<p>如果有裝置是 unknown 的,需要更新 <code>/usr/share/hwdata/pci.ids</code> 請參考更新方式 <a href="http://benjr.tw/node/88" target="_blank" rel="noopener">http://benjr.tw/node/88</a></p>
<p>首先我們先來複習一下 PCI-E bus 的速度上限.</p>
<h3 id="PCI-Express-1-1"><a href="#PCI-Express-1-1" class="headerlink" title="PCI Express 1.1"></a>PCI Express 1.1</h3><p>使用兩對低電壓的差位訊號排線（low-voltage differential signaling pairs），分別各跑2.5GBit/s速度,下面的速度是以單對的速度而言. x1 有兩對 2.5 G x 2 = 5Gbps 的頻寬.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x1  2.5Gbps(20% overhead - PCI-e 在每八個位元的資料串上用十位元來加以編碼)   2Gbps (250 MB/sec)</span><br><span class="line">x4  10Gbps  8Gbps (1 GB/sec)</span><br><span class="line">x8  20Gbps  16Gbps (2GB/sec)</span><br><span class="line">x16 40Gbps 32Gbps (4GB/sec)</span><br></pre></td></tr></table></figure>
<h3 id="PCI-Express-2-0"><a href="#PCI-Express-2-0" class="headerlink" title="PCI Express 2.0"></a>PCI Express 2.0</h3><p>PCI-SIG 的 PCI Express 2.0規格，新版每條Lane的單向頻寬從2.5Gbps倍增到5Gbps.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x1  5Gbps(20% overhead-PCIe並且在每八個位元的資料串上用十位元來加以編碼)   4Gbps (500 MB/sec)</span><br><span class="line">(5G*0.8)Mb/8=500MB</span><br><span class="line">x4  20Gbps  16Gbps (2 GB/sec)</span><br><span class="line">x8  40Gbps  32Gbps (4 GB/sec)</span><br><span class="line">x16 80Gbps 64Gbps (8 GB/sec)</span><br></pre></td></tr></table></figure>
<p>我的系統上有一張 Qlogic Chipset 為 2432 的 4G Fiber Channel HBA,要如何得知目前系統的 PCI-E Bus 的速度呢!!首先要查出這張 HBA 的裝置名稱.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@benjr ~]<span class="comment"># lspci -n</span></span><br><span class="line">00:00.0 0600: 8086:29f0 (rev 01)</span><br><span class="line">00:01.0 0604: 8086:29f1 (rev 01)</span><br><span class="line">00:1a.0 0c03: 8086:2937 (rev 02)</span><br><span class="line">00:1a.1 0c03: 8086:2938 (rev 02)</span><br><span class="line">00:1a.2 0c03: 8086:2939 (rev 02)</span><br><span class="line">00:1a.7 0c03: 8086:293c (rev 02)</span><br><span class="line">00:1c.0 0604: 8086:2948 (rev 02)</span><br><span class="line">00:1c.1 0604: 8086:294a (rev 02)</span><br><span class="line">00:1c.2 0604: 8086:2940 (rev 02)</span><br><span class="line">00:1d.0 0c03: 8086:2934 (rev 02)</span><br><span class="line">00:1d.1 0c03: 8086:2935 (rev 02)</span><br><span class="line">00:1d.2 0c03: 8086:2936 (rev 02)</span><br><span class="line">00:1d.7 0c03: 8086:293a (rev 02)</span><br><span class="line">00:1e.0 0604: 8086:244e (rev 92)</span><br><span class="line">00:1f.0 0601: 8086:2916 (rev 02)</span><br><span class="line">00:1f.2 0106: 8086:2922 (rev 02)</span><br><span class="line">00:1f.3 0c05: 8086:2930 (rev 02)</span><br><span class="line">03:00.0 0200: 14e4:165a</span><br><span class="line">04:03.0 0300: 1002:515e (rev 02)</span><br><span class="line">09:00.0 0c04: 1077:2432 (rev 03)</span><br><span class="line">09:00.1 0c04: 1077:2432 (rev 03)</span><br><span class="line">0c:00.0 0100: 1000:0056 (rev 02)</span><br></pre></td></tr></table></figure>
<p>可以看到目前 Qlogic 2432 的 PCI 名稱以及裝置名稱為 09:00.0 0c04: 1077:2432 (rev 03) 先來看看這些數字所代表的意義.<br>前面的 3 個數字 “09:00.0” 是各代表什麼意思.</p>
<p>在 PCI 的裝置使用三個編號用來當作識別值,個別為:</p>
<ol>
<li>匯流排(bus number)</li>
<li>裝置(device number)</li>
<li>功能(function number)</li>
</ol>
<p>所以剛剛的 09:00.0 就是 bus number = 09 ,device number = 00 function = 0 .</p>
<p>這3個編號會組合成一個 16-bits 的識別碼,</p>
<p>匯流排(bus number) 8bits 2^8 至多可連接 256 個匯流排(0 to ff),<br>裝置(device number) 5bits 2^5 至多可接 32 種裝置(0 to 1f) 以及<br>功能(function number) 3bits 2^3 至多每種裝置可有 8 項功能(0 to 7)</p>
<p>關於更多 #lspci 的資訊請參考 <a href="http://benjr.tw/node/543" target="_blank" rel="noopener">http://benjr.tw/node/543</a></p>
<p>不過在 Linux 使用 Class ID + Vendor ID + Device ID  來代表裝置,如剛剛的  0c04: 1077:2432 所代表裝置名稱為 (Class ID = 0c04 ,Vendor ID = 1077,Device ID =2432) .</p>
<ul>
<li>0c04 : class 0c04 表示是 “Fiber Channel controller”</li>
<li>1077 : vendor ID 1077 製造廠商 “Qlogic Corp”</li>
<li>2432 : device ID 2432 產品名稱 “ISP2432-based 4Gb Fiber Channel to PCI Express HBA”</li>
</ul>
<p>你問我怎麼知道 ID 與名稱是怎麼對應的很簡單直接參考 /usr/share/hwdata/pci.ids 檔案即可.</p>
<h3 id="获取PCI-Express速度"><a href="#获取PCI-Express速度" class="headerlink" title="获取PCI-Express速度"></a>获取PCI-Express速度</h3><p>接下來透過指令 #lspci -n -d 1077:2432 -vvv |grep -i width 就可以得知 PCI-Express 的速度了.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@benjr ~]<span class="comment"># /usr/sbin/lspci -d 1077:2971 -vv grep -i width</span></span><br><span class="line"></span><br><span class="line">LnkCap: Port <span class="comment">#0, Speed 2.5GT/s, Width x4, ASPM L0s, Latency L0 &lt;4us, L1 unlimited</span></span><br><span class="line">LnkSta: Speed 2.5GT/s, Width x1, TrErr- Train- SlotClk+ DLActive- BWMgmt- ABWMgmt-</span><br><span class="line">LnkCap: Port <span class="comment">#0, Speed 2.5GT/s, Width x4, ASPM L0s, Latency L0 &lt;4us, L1 unlimited</span></span><br><span class="line">LnkSta: Speed 2.5GT/s, Width x1, TrErr- Train- SlotClk+ DLActive- BWMgmt- ABWMgmt-</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>LnkSta :</strong> 目前系統所提供的速度 PCI-Express 1.0 ( 2.5G ) ,如果是 PCI-Express 2.0 那速度是 5G</li>
<li><strong>LnkCap :</strong> 裝置目前所採用的速度.</li>
</ul>
<p>LnkSta 和 LnkCap 這兩個速度有可能不一樣 ,系統所提供的是 PCI Express 是 2.0 但裝置還是使用 1.0 的.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gaianote.github.io/2019/03/19/linux/2.shell基本語法/4.shell传递参数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李云鹏">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/rem.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李云鹏的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/19/linux/2.shell基本語法/4.shell传递参数/" itemprop="url">shell传递参数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-19T08:35:20+00:00">
                2019-03-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推…</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Shell 传递参数实例！"</span>;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"第一个参数为：<span class="variable">$1</span>"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"参数个数为：<span class="variable">$#</span>"</span>;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"传递的参数作为一个字符串显示：$*"</span>;</span><br></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x test.sh </span><br><span class="line">$ ./test.sh 1 2 3</span><br><span class="line">Shell 传递参数实例！</span><br><span class="line">第一个参数为：1</span><br><span class="line">参数个数为：3</span><br><span class="line">传递的参数作为一个字符串显示：1 2 3</span><br></pre></td></tr></table></figure>
<p>常见变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$#</span> 传递到脚本的参数个数</span><br><span class="line">$* 以一个单字符串显示所有向脚本传递的参数。</span><br><span class="line">$$ 脚本运行的当前进程ID号</span><br><span class="line">$! 后台运行的最后一个进程的ID号</span><br><span class="line"><span class="variable">$@</span> 与$*相同，但是使用时加引号，并在引号中返回每个参数。</span><br><span class="line">$- 显示Shell使用的当前选项，与<span class="built_in">set</span>命令功能相同。</span><br><span class="line">$? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>$*</code>与 <code>$@</code>区别：<br> 相同点：都是引用所有参数。<br> 不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 “ * “ 等价于 “1 2 3”（传递了一个参数），而 “@” 等价于 “1” “2” “3”（传递了三个参数）。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gaianote.github.io/2019/03/05/linux/1.常用命令/Linux 技巧：让进程在后台可靠运行的几种方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李云鹏">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/rem.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李云鹏的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/05/linux/1.常用命令/Linux 技巧：让进程在后台可靠运行的几种方法/" itemprop="url">Linux 技巧：让进程在后台可靠运行的几种方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-05T12:18:35+00:00">
                2019-03-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>如果只是临时有一个命令需要长时间运行，使用 <code>nohub</code>，<strong><code>setsid</code></strong>，<code>&amp;</code></li>
<li>如果我们未加任何处理就已经提交了命令,使用 <code>disown</code></li>
<li>但是如果有大量这种命令需要在稳定的后台里运行，使用 <code>screen</code></li>
</ul>
<p>推荐使用<code>setsid</code>进行后台程序启动</p>
<h2 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h2><p>nohup 无疑是我们首先想到的办法。顾名思义，nohup 的用途就是让提交的命令忽略 hangup 信号。让我们先来看一下 nohup 的帮助信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">NOHUP(1)                        User Commands                        NOHUP(1)</span><br><span class="line"> </span><br><span class="line">NAME</span><br><span class="line">       nohup - run a command immune to hangups, with output to a non-tty</span><br><span class="line"> </span><br><span class="line">SYNOPSIS</span><br><span class="line">       nohup COMMAND [ARG]...</span><br><span class="line">       nohup OPTION</span><br><span class="line"> </span><br><span class="line">DESCRIPTION</span><br><span class="line">       Run COMMAND, ignoring hangup signals.</span><br><span class="line"> </span><br><span class="line">       --help display this help and exit</span><br><span class="line"> </span><br><span class="line">       --version</span><br><span class="line">              output version information and exit</span><br></pre></td></tr></table></figure>
<p>可见，nohup 的使用是十分方便的，只需在要处理的命令前加上 nohup 即可，标准输出和标准错误缺省会被重定向到 nohup.out 文件中。一般我们可在结尾加上”&amp;”来将命令同时放入后台运行，也可用”&gt;filename 2&gt;&amp;1”来更改缺省的重定向文件名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@pvcent107 ~]<span class="comment"># nohup ping www.ibm.com &amp;</span></span><br><span class="line">[1] 3059</span><br><span class="line">nohup: appending output to `nohup.out<span class="string">'</span></span><br><span class="line"><span class="string">[root@pvcent107 ~]# ps -ef |grep 3059</span></span><br><span class="line"><span class="string">root      3059   984  0 21:06 pts/3    00:00:00 ping www.ibm.com</span></span><br><span class="line"><span class="string">root      3067   984  0 21:06 pts/3    00:00:00 grep 3059</span></span><br><span class="line"><span class="string">[root@pvcent107 ~]#</span></span><br></pre></td></tr></table></figure>
<h2 id="setsid"><a href="#setsid" class="headerlink" title="setsid"></a>setsid</h2><p>nohup 无疑能通过忽略 HUP 信号来使我们的进程避免中途被中断，但如果我们换个角度思考，如果我们的进程不属于接受 HUP 信号的终端的子进程，那么自然也就不会受到 HUP 信号的影响了。setsid 就能帮助我们做到这一点。让我们先来看一下 setsid 的帮助信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SETSID(8)                 Linux Programmer’s Manual                 SETSID(8)</span><br><span class="line"> </span><br><span class="line">NAME</span><br><span class="line">       setsid - run a program in a new session</span><br><span class="line"> </span><br><span class="line">SYNOPSIS</span><br><span class="line">       setsid program [ arg ... ]</span><br><span class="line"> </span><br><span class="line">DESCRIPTION</span><br><span class="line">       setsid runs a program in a new session.</span><br></pre></td></tr></table></figure>
<p>可见 setsid 的使用也是非常方便的，也只需在要处理的命令前加上 setsid 即可。</p>
<p>setsid 示例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@pvcent107 ~]<span class="comment"># setsid ping www.ibm.com</span></span><br><span class="line">[root@pvcent107 ~]<span class="comment"># ps -ef |grep www.ibm.com</span></span><br><span class="line">root     31094     1  0 07:28 ?        00:00:00 ping www.ibm.com</span><br><span class="line">root     31102 29217  0 07:29 pts/4    00:00:00 grep www.ibm.com</span><br></pre></td></tr></table></figure>
<p>值得注意的是，上例中我们的进程 ID(PID)为31094，而它的父 ID（PPID）为1（即为 init 进程 ID），并不是当前终端的进程 ID。请将此例与nohup 例中的父 ID 做比较。</p>
<h2 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h2><p>这里还有一个关于 subshell 的小技巧。我们知道，将一个或多个命名包含在“()”中就能让这些命令在子 shell 中运行中，从而扩展出很多有趣的功能，我们现在要讨论的就是其中之一。</p>
<p>当我们将”&amp;”也放入“()”内之后，我们就会发现所提交的作业并不在作业列表中，也就是说，是无法通过jobs来查看的。让我们来看看为什么这样就能躲过 HUP 信号的影响吧。</p>
<p>subshell 示例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@pvcent107 ~]<span class="comment"># (ping www.ibm.com &amp;)</span></span><br><span class="line">[root@pvcent107 ~]<span class="comment"># ps -ef |grep www.ibm.com</span></span><br><span class="line">root     16270     1  0 14:13 pts/4    00:00:00 ping www.ibm.com</span><br><span class="line">root     16278 15362  0 14:13 pts/4    00:00:00 grep www.ibm.com</span><br><span class="line">[root@pvcent107 ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>从上例中可以看出，新提交的进程的父 ID（PPID）为1（init 进程的 PID），并不是当前终端的进程 ID。因此并不属于当前终端的子进程，从而也就不会受到当前终端的 HUP 信号的影响了。</p>
<h2 id="开始使用Screen"><a href="#开始使用Screen" class="headerlink" title="开始使用Screen"></a>开始使用Screen</h2><p>简单来说，Screen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。Screen中有会话的概念，用户可以在一个screen会话中创建多个screen窗口，在每一个screen窗口中就像操作一个真实的telnet/SSH连接窗口那样。</p>
<p>常用的命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -S sessionname</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -r sessionname</span><br></pre></td></tr></table></figure>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/index.html" target="_blank" rel="noopener">Linux 技巧：让进程在后台可靠运行的几种方法</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gaianote.github.io/2019/03/05/docker/11.docker访问宿主主机串行设备/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李云鹏">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/rem.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李云鹏的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/05/docker/11.docker访问宿主主机串行设备/" itemprop="url">docker访问宿主主机串行设备</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-05T12:05:55+00:00">
                2019-03-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-读取宿主主机设备的方案"><a href="#1-读取宿主主机设备的方案" class="headerlink" title="1. 读取宿主主机设备的方案"></a>1. 读取宿主主机设备的方案</h2><ol>
<li>使用<code>--device</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -t -i --device=/dev/ttyUSB0 ubuntu bash</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用<code>--privileged</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -t -i --privileged ubuntu bash</span><br></pre></td></tr></table></figure>
<h2 id="2-特权模式"><a href="#2-特权模式" class="headerlink" title="2. 特权模式"></a>2. 特权模式</h2><p>默认情况下，Docker的容器是没有特权的，例如不能在容器中再启动一个容器。这是因为默认情况下容器是不能访问任何其它设备的。但是通过<code>--privileged</code>，容器就拥有了访问任何其它设备的权限。</p>
<p>当操作者执行时，Docker将拥有访问主机所有设备的权限，同时Docker也会在apparmor或者selinux做一些设置，使容器可以容易的访问那些运行在容器外部的设备。</p>
<p>同时，你也可以限制容器只能访问一些指定的设备。下面的命令将允许容器只访问一些特定设备：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --device=/dev/snd:/dev/snd ...</span><br></pre></td></tr></table></figure>
<ol>
<li>使用<code>--privileged</code>参数，可以访问宿主主机的所有设备</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --privileged ztest </span><br><span class="line"></span><br><span class="line">➜  serial git:(master) ls /dev </span><br><span class="line">tty43  tty52  tty61  ttyUSB1 ttyUSB2 ttyUSB3 ttyUSB4 ...</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>不使用<code>--privileged</code>参数，无法访问宿主主机设备<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@host192 ~]<span class="comment"># docker run -it ztest</span></span><br><span class="line">➜  /workspace ls /dev</span><br><span class="line">console  core  fd  full  mqueue  null  ptmx  pts  random  shm  stderr  stdin  stdout  tty  ...</span><br></pre></td></tr></table></figure>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gaianote.github.io/2019/03/03/docker/10.在docker容器内使用docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李云鹏">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/rem.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李云鹏的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/03/docker/10.在docker容器内使用docker/" itemprop="url">在docker容器内使用docker</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-03T08:02:22+00:00">
                2019-03-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在容器内调用docker的一种方案是，共享宿主主机的docker给docker容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -it \</span><br><span class="line">   -v /var/run/docker.sock:/var/run/docker.sock \	</span><br><span class="line">   -v /usr/bin/docker:/usr/bin/docker \</span><br><span class="line">   jenkins</span><br></pre></td></tr></table></figure>
<p>进入容器后，可以正常使用docker命令，并且是对宿主主机的docker环境进行操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  ➜  ~ docker images</span><br><span class="line">REPOSITORY                   TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">jenkins                      latest              bb82f5385818        About an hour ago   1.9GB</span><br><span class="line">ztest                        latest              d024d1c7d455        5 days ago          628MB</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gaianote.github.io/2019/02/26/docker/7.Docker-compose的使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李云鹏">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/rem.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李云鹏的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/26/docker/7.Docker-compose的使用/" itemprop="url">Docker Compose的使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-26T15:05:35+00:00">
                2019-02-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-Docker-Compose概述"><a href="#1-Docker-Compose概述" class="headerlink" title="1. Docker Compose概述"></a>1. Docker Compose概述</h2><p>Compose是一个用于定义和运行多容器Docker应用程序的工具。使用Compose，您可以使用YAML文件来配置应用程序的服务。然后，使用单个命令，您可以从配置中创建并启动所有服务。要了解有关Compose所有功能的更多信息，请参阅<a href="https://docs.docker.com/compose/overview/#features" target="_blank" rel="noopener">功能列表</a>。</p>
<p>Compose适用于所有环境：生产，登台，开发，测试以及CI工作流程。您可以在<a href="https://docs.docker.com/compose/overview/#common-use-cases" target="_blank" rel="noopener">常见用例中</a>了解有关每个案例的更多信息。</p>
<p>使用Compose基本上是一个三步过程：</p>
<ol>
<li>定义您的应用程序环境，<code>Dockerfile</code>以便可以在任何地方进行复制。</li>
<li>定义构成应用程序的服务，<code>docker-compose.yml</code> 以便它们可以在隔离的环境中一起运行。</li>
<li>Run <code>docker-compose up</code>和Compose启动并运行整个应用程序。</li>
</ol>
<p>一个 <code>docker-compose.yml</code>看起来像这样：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  web:</span></span><br><span class="line"><span class="attr">    build:</span> <span class="string">.</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"5000:5000"</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">.:/code</span></span><br><span class="line"><span class="attr">    - logvolume01:</span><span class="string">/var/log</span></span><br><span class="line"><span class="attr">    links:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="attr">  logvolume01:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>有关“撰写”文件的详细信息，请参阅“ <a href="https://docs.docker.com/compose/compose-file/" target="_blank" rel="noopener">撰写文件参考”</a>。</p>
<p>Compose具有管理应用程序整个生命周期的命令：</p>
<ul>
<li>启动，停止和重建服务</li>
<li>查看正在运行的服务的状态</li>
<li>流式传输运行服务的日志输出</li>
<li>在服务上运行一次性命令</li>
</ul>
<h2 id="2-安装Compose"><a href="#2-安装Compose" class="headerlink" title="2. 安装Compose"></a>2. 安装Compose</h2><p>在Linux系统上系统上安装compose</p>
<ol>
<li><p>运行此命令以下载Docker Compose的当前稳定版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L <span class="string">"https://github.com/docker/compose/releases/download/1.24.0/docker-compose-<span class="variable">$(uname -s)</span>-<span class="variable">$(uname -m)</span>"</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure>
</li>
<li><p>对二进制文件应用可执行权限：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在其它系统或者更详细的安装说明，请查看<a href="https://docs.docker.com/compose/install" target="_blank" rel="noopener">官方文档</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gaianote.github.io/2019/02/25/docker/6.Dockerfile的使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李云鹏">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/rem.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李云鹏的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/25/docker/6.Dockerfile的使用/" itemprop="url">Dockerfile的使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-25T09:05:42+00:00">
                2019-02-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-概览"><a href="#1-概览" class="headerlink" title="1. 概览"></a>1. 概览</h2><p>我们新建一个文件并将其命名为Dockerfile，键入以下内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM node:slim</span><br><span class="line">RUN mkdir /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">COPY ./package.json /app</span><br><span class="line">RUN [ <span class="string">"npm"</span>, <span class="string">"install"</span> ]</span><br><span class="line">COPY . /app/</span><br><span class="line">CMD [ <span class="string">"npm"</span>, <span class="string">"start"</span> ]</span><br></pre></td></tr></table></figure></p>
<p>然后再Dockerfile的同级目录输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t mynode .</span><br></pre></td></tr></table></figure>
<p>这样，我们就构建完成了一个名为mynode的docke镜像</p>
<h2 id="2-docker-build-语法解析"><a href="#2-docker-build-语法解析" class="headerlink" title="2. docker build 语法解析"></a>2. <code>docker build</code> 语法解析</h2><ol>
<li>我们构建一个镜像，通常在自己编写号的Dockerfile的同级目录，执行以下命令：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t runoob/ubuntu:v1 .</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>-t</code> 表示要构建的镜像的Tag</p>
</li>
<li><p><code>.</code>  表示上下文目录</p>
</li>
</ul>
<ol start="2">
<li>也可以使用URL <strong>github.com/creack/docker-firefox</strong> 的 Dockerfile 构建镜像。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build github.com/creack/docker-firefox</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>也可以通过 -f Dockerfile 指定DOkcerfile文件的位置构建镜像：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -f /path/to/a/Dockerfile .</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>在 Docker 守护进程执行 Dockerfile 中的指令前，首先会对 Dockerfile 进行语法检查，有语法错误时会返回：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t <span class="built_in">test</span>/myapp .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Error response from daemon: Unknown instruction: RUNCMD</span><br></pre></td></tr></table></figure>
<h2 id="3-Dockerfile语法解析"><a href="#3-Dockerfile语法解析" class="headerlink" title="3. Dockerfile语法解析"></a>3. Dockerfile语法解析</h2><h3 id="1-FROM-指定基础镜像"><a href="#1-FROM-指定基础镜像" class="headerlink" title="1. FROM 指定基础镜像"></a>1. FROM 指定基础镜像</h3><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 nginx 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 FROM 就是指定基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。</p>
<p>在 Docker Store 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 nginx、redis、mongo、mysql、httpd、php、tomcat 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 node、openjdk、python、ruby、golang 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。</p>
<p>如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 ubuntu、debian、centos、fedora、alpine 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。</p>
<p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch</span><br></pre></td></tr></table></figure>
<p>如果你以 scratch 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p>
<p>不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，比如 swarm、coreos/etcd。对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 FROM scratch 会让镜像体积更加小巧。使用 Go 语言 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p>
<h3 id="2-RUN-执行命令"><a href="#2-RUN-执行命令" class="headerlink" title="2. RUN 执行命令"></a>2. RUN 执行命令</h3><p>RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种：</p>
<ul>
<li><strong>shell 格式</strong>：RUN &lt;命令&gt;，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 RUN 指令就是这种格式。</li>
<li><strong>exec 格式</strong>：RUN [“可执行文件”, “参数1”, “参数2”]，这更像是函数调用中的格式。</li>
</ul>
<p>既然 RUN 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:jessie</span><br><span class="line"></span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y gcc libc6-dev make</span><br><span class="line">RUN wget -O redis.tar.gz <span class="string">"http://download.redis.io/releases/redis-3.2.5.tar.gz"</span></span><br><span class="line">RUN mkdir -p /usr/src/redis</span><br><span class="line">RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span><br><span class="line">RUN make -C /usr/src/redis</span><br><span class="line">RUN make -C /usr/src/redis install</span><br></pre></td></tr></table></figure>
<p>之前说过，Dockerfile 中每一个指令都会建立一层，RUN 也不例外。每一个 RUN 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，commit 这一层的修改，构成新的镜像。</p>
<p>而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。</p>
<p>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</p>
<p>上面的 Dockerfile 正确的写法应该是这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:jessie</span><br><span class="line"></span><br><span class="line">RUN buildDeps=<span class="string">'gcc libc6-dev make'</span> \</span><br><span class="line">    &amp;&amp; apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y <span class="variable">$buildDeps</span> \</span><br><span class="line">    &amp;&amp; wget -O redis.tar.gz <span class="string">"http://download.redis.io/releases/redis-3.2.5.tar.gz"</span> \</span><br><span class="line">    &amp;&amp; mkdir -p /usr/src/redis \</span><br><span class="line">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis install \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</span><br><span class="line">    &amp;&amp; rm redis.tar.gz \</span><br><span class="line">    &amp;&amp; rm -r /usr/src/redis \</span><br><span class="line">    &amp;&amp; apt-get purge -y --auto-remove <span class="variable">$buildDeps</span></span><br></pre></td></tr></table></figure>
<p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 RUN 对一一对应不同的命令，而是仅仅使用一个 RUN 指令，并使用 &amp;&amp; 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p>
<p>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 \ 的命令换行方式，以及行首 # 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p>
<p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p>
<p>很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</p>
<h3 id="3-COPY-复制文件"><a href="#3-COPY-复制文件" class="headerlink" title="3. COPY 复制文件"></a>3. COPY 复制文件</h3><p>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</span><br></pre></td></tr></table></figure>
<p>COPY 指令将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY package.json /usr/src/app/ <span class="comment"># 上下文目录:package.json =&gt;  新镜像:/usr/src/app/</span></span><br></pre></td></tr></table></figure>
<p>如果&lt;目标路径&gt; 位置文件夹不存在，COPY命令会自动创建该文件夹，无需手动创建</p>
<h3 id="4-CMD-容器启动命令"><a href="#4-CMD-容器启动命令" class="headerlink" title="4. CMD 容器启动命令"></a>4. CMD 容器启动命令</h3><p>CMD 指令的格式和 RUN 相似，也是两种格式：</p>
<ul>
<li>shell 格式：CMD &lt;命令&gt;</li>
<li>exec 格式：CMD [“可执行文件”, “参数1”, “参数2”…]</li>
<li>参数列表格式：CMD [“参数1”, “参数2”…]。在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数。</li>
</ul>
<p>之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<strong>CMD 指令就是用于指定默认的容器主进程的启动命令的</strong>。</p>
<p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，ubuntu 镜像默认的 CMD 是 /bin/bash，如果我们直接 docker run -it ubuntu 的话，会直接进入 bash。我们也可以在运行时指定运行别的命令，如 docker run -it ubuntu cat /etc/os-release。这就是用 cat /etc/os-release 命令替换了默认的 /bin/bash 命令了，输出了系统版本信息。</p>
<p>在指令格式上，<strong>一般推荐使用 exec 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 “</strong>，而不要使用单引号。</p>
<p>如果使用 shell 格式的话，实际的命令会被包装为 <code>sh -c</code> 的参数的形式进行执行。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD <span class="built_in">echo</span> <span class="variable">$HOME</span></span><br></pre></td></tr></table></figure>
<p>在实际执行中，会将其变更为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [ <span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"echo <span class="variable">$HOME</span>"</span> ]</span><br></pre></td></tr></table></figure>
<p>这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。</p>
<p>提到 CMD 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。</p>
<p>Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 upstart/systemd 去启动后台服务，容器内没有后台服务的概念。</p>
<p>一些初学者将 CMD 写为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD service nginx start</span><br></pre></td></tr></table></figure>
<p>然后发现容器执行后就立即退出了。甚至在容器内去使用 systemctl 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。</p>
<p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p>
<p>而使用 service nginx start 命令，则是希望 upstart 来以后台守护进程形式启动 nginx 服务。而刚才说了 CMD service nginx start 会被理解为 CMD [ “sh”, “-c”, “service nginx start”]，因此主进程实际上是 sh。那么当 service nginx start 命令结束后，sh 也就结束了，sh 作为主进程退出了，自然就会令容器退出。</p>
<p>正确的做法是直接执行 nginx 可执行文件，并且要求以前台形式运行。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [<span class="string">"nginx"</span>, <span class="string">"-g"</span>, <span class="string">"daemon off;"</span>]</span><br></pre></td></tr></table></figure>
<h3 id="5-ENTRYPOINT-入口点"><a href="#5-ENTRYPOINT-入口点" class="headerlink" title="5. ENTRYPOINT 入口点"></a>5. ENTRYPOINT 入口点</h3><p>ENTRYPOINT 的格式和 RUN 指令格式一样，分为 exec 格式和 shell 格式。</p>
<p>ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。ENTRYPOINT 在运行时也可以替代，不过比 CMD 要略显繁琐，需要通过 docker run 的参数 –entrypoint 来指定。</p>
<p>当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令，换句话说实际执行时，将变为：</p>
<p><entrypoint> “<cmd>“</cmd></entrypoint></p>
<p>那么有了 CMD 后，为什么还要有 ENTRYPOINT 呢？这种 <entrypoint> “<cmd>“ 有什么好处么？让我们来看几个场景。</cmd></entrypoint></p>
<h4 id="场景一：让镜像变成像命令一样使用"><a href="#场景一：让镜像变成像命令一样使用" class="headerlink" title="场景一：让镜像变成像命令一样使用"></a>场景一：让镜像变成像命令一样使用</h4><p>假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 CMD 来实现：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:18.04</span><br><span class="line">RUN apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y curl \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line">CMD [ <span class="string">"curl"</span>, <span class="string">"-s"</span>, <span class="string">"https://ip.cn"</span> ]</span><br></pre></td></tr></table></figure>
<p>假如我们使用 docker build -t myip . 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip</span><br></pre></td></tr></table></figure>
<p>但是之前我们说过，跟在镜像名后面的是 command，运行时会替换 CMD 的默认值。无法实现增加参数的功能：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip -i <span class="comment"># 此时相当于 CMD [ "-i" ]</span></span><br></pre></td></tr></table></figure>
<p>那么如果我们希望加入 -i 这参数，我们就必须重新完整的输入这个命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip curl -s https://ip.cn -i</span><br></pre></td></tr></table></figure>
<p>这显然不是很好的解决方案，而使用 ENTRYPOINT 就可以解决这个问题。现在我们重新用 ENTRYPOINT 来实现这个镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:18.04</span><br><span class="line">RUN apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y curl \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line">ENTRYPOINT [ <span class="string">"curl"</span>, <span class="string">"-s"</span>, <span class="string">"https://ip.cn"</span> ]</span><br></pre></td></tr></table></figure>
<p>这次我们再来尝试直接使用 docker run myip -i：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip</span><br></pre></td></tr></table></figure>
<p>当前 IP：61.148.226.66 来自：北京市 联通</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip -i</span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.8.0</span><br><span class="line">Date: Tue, 22 Nov 2016 05:12:40 GMT</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Powered-By: PHP/5.6.24-1~dotdeb+7.1</span><br><span class="line">X-Cache: MISS from cache-2</span><br><span class="line">X-Cache-Lookup: MISS from cache-2:80</span><br><span class="line">X-Cache: MISS from proxy-2_6</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Via: 1.1 cache-2:80, 1.1 proxy-2_6:8006</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>
<p>当前 IP：61.148.226.66 来自：北京市 联通<br>可以看到，这次成功了。这是因为当存在 ENTRYPOINT 后，CMD 的内容将会作为参数传给 ENTRYPOINT，而这里 -i 就是新的 CMD，因此会作为参数传给 curl，从而达到了我们预期的效果。</p>
<h4 id="场景二：应用运行前的准备工作"><a href="#场景二：应用运行前的准备工作" class="headerlink" title="场景二：应用运行前的准备工作"></a>场景二：应用运行前的准备工作</h4><p>启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。</p>
<p>比如 mysql 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。</p>
<p>此外，可能希望避免使用 root 用户去启动服务，从而提高安全性，而在启动服务前还需要以 root 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 root 身份执行，方便调试等。</p>
<p>这些准备工作是和容器 CMD 无关的，无论 CMD 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 ENTRYPOINT 中去执行，而这个脚本会将接到的参数（也就是 <cmd>）作为命令，在脚本最后执行。比如官方镜像 redis 中就是这么做的：</cmd></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM alpine:3.4</span><br><span class="line">...</span><br><span class="line">RUN addgroup -S redis &amp;&amp; adduser -S -G redis redis</span><br><span class="line">...</span><br><span class="line">ENTRYPOINT [<span class="string">"docker-entrypoint.sh"</span>] <span class="comment"># =&gt; 这个脚本用于使用root权限命令</span></span><br><span class="line"></span><br><span class="line">EXPOSE 6379</span><br><span class="line">CMD [ <span class="string">"redis-server"</span> ]</span><br></pre></td></tr></table></figure>
<p>该脚本的内容就是根据 CMD 的内容来判断，如果是不然传入参数，默认命令就是 <code>CMD [ &quot;redis-server&quot; ]</code> ，则切换到 redis 用户身份启动服务器，如果添加参数，则将参数传入入口文件，使用 root 身份执行。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it redis <span class="comment"># 启动redis</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it redis id <span class="comment"># 调试redis</span></span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br></pre></td></tr></table></figure>
<h3 id="6-EXPOSE-声明端口"><a href="#6-EXPOSE-声明端口" class="headerlink" title="6. EXPOSE 声明端口"></a>6. EXPOSE 声明端口</h3><p>格式为 EXPOSE &lt;端口1&gt; [&lt;端口2&gt;…]。</p>
<p>EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。</p>
<p>要将 EXPOSE 和在运行时使用 -p &lt;宿主端口&gt;:&lt;容器端口&gt; 区分开来。-p，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p>
<h3 id="7-ENV-设置环境变量"><a href="#7-ENV-设置环境变量" class="headerlink" title="7. ENV 设置环境变量"></a>7. ENV 设置环境变量</h3><p>格式有两种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</span><br></pre></td></tr></table></figure>
<p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 RUN，还是运行时的应用，都可以直接使用这里定义的环境变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV VERSION=1.0 DEBUG=on \</span><br><span class="line">    NAME=&quot;Happy Feet&quot;</span><br></pre></td></tr></table></figure>
<p>这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。</p>
<p>定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 node 镜像 Dockerfile 中，就有类似这样的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ENV NODE_VERSION 7.2.0</span><br><span class="line"></span><br><span class="line">RUN curl -SLO &quot;https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz&quot; \</span><br><span class="line">  &amp;&amp; curl -SLO &quot;https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc&quot; \</span><br><span class="line">  &amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \</span><br><span class="line">  &amp;&amp; grep &quot; node-v$NODE_VERSION-linux-x64.tar.xz\$&quot; SHASUMS256.txt | sha256sum -c - \</span><br><span class="line">  &amp;&amp; tar -xJf &quot;node-v$NODE_VERSION-linux-x64.tar.xz&quot; -C /usr/local --strip-components=1 \</span><br><span class="line">  &amp;&amp; rm &quot;node-v$NODE_VERSION-linux-x64.tar.xz&quot; SHASUMS256.txt.asc SHASUMS256.txt \</span><br><span class="line">  &amp;&amp; ln -s /usr/local/bin/node /usr/local/bin/nodejs</span><br></pre></td></tr></table></figure>
<p>在这里先定义了环境变量 NODE_VERSION，其后的 RUN 这层里，多次使用 $NODE_VERSION 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 7.2.0 即可，Dockerfile 构建维护变得更轻松了。</p>
<p>下列指令可以支持环境变量展开： ADD、COPY、ENV、EXPOSE、LABEL、USER、WORKDIR、VOLUME、STOPSIGNAL、ONBUILD。</p>
<p>可以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份 Dockerfile 制作更多的镜像，只需使用不同的环境变量即可。</p>
<h3 id="8-VOLUME-定义匿名卷"><a href="#8-VOLUME-定义匿名卷" class="headerlink" title="8. VOLUME 定义匿名卷"></a>8. VOLUME 定义匿名卷</h3><p>格式为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [<span class="string">"&lt;路径1&gt;"</span>, <span class="string">"&lt;路径2&gt;"</span>...]</span><br><span class="line">VOLUME &lt;路径&gt;</span><br></pre></td></tr></table></figure>
<p>之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，后面的章节我们会进一步介绍 Docker 卷的概念。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME /data</span><br></pre></td></tr></table></figure>
<p>这里的 <code>/data</code> 目录就会在运行时自动挂载为匿名卷，任何向 <code>/data</code> 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -v mydata:/data xxxx</span><br></pre></td></tr></table></figure>
<p>在这行命令中，就使用了 mydata 这个命名卷挂载到了 <code>/data</code> 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置。</p>
<h3 id="9-WORKDIR-指定工作目录"><a href="#9-WORKDIR-指定工作目录" class="headerlink" title="9. WORKDIR 指定工作目录"></a>9. WORKDIR 指定工作目录</h3><p>格式: <code>WORKDIR &lt;工作目录路径&gt;</code></p>
<p>使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录,这个目录是新镜像构建时的工作目录，与上下文目录无关），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。</p>
<p>示例：</p>
<p>项目文件结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--</span><br><span class="line">|-lib</span><br><span class="line">|-requirements.txt</span><br><span class="line">|-main.py</span><br><span class="line">|-Dockerfile</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM python:3.7</span><br><span class="line">WORKDIR /app <span class="comment"># 指定新镜像的工作目录为/app</span></span><br><span class="line">COPY . /app/ <span class="comment"># 将上下文目录（也就是你的项目所在目录）的所有文件复制到镜像的/app/文件夹下</span></span><br><span class="line">RUN [<span class="string">"pip"</span>,<span class="string">"install"</span>,<span class="string">"-r"</span>,<span class="string">"requirements.txt"</span>] <span class="comment"># 此处，如果之前没指定WORKDIR，默认工作目录为新镜像的 /，显然无法找到requirements.txt</span></span><br><span class="line">CMD [<span class="string">"python"</span>,<span class="string">"main.py"</span>] <span class="comment"># 此处同理</span></span><br></pre></td></tr></table></figure>
<p>之前提到一些初学者常犯的错误是把 Dockerfile 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：</p>
<p><strong>错误示例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN <span class="built_in">cd</span> /app</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">"hello"</span> &gt; world.txt</span><br></pre></td></tr></table></figure>
<p>如果将这个 Dockerfile 进行构建镜像运行后，会发现找不到 /app/world.txt 文件，或者其内容不是 hello。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 Dockerfile 中，这两行 RUN 命令的执行环境根本不同，是两个完全不同的容器。这就是对 Dockerfile 构建分层存储的概念不了解所导致的错误。</p>
<p>之前说过每一个 RUN 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 RUN cd /app 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p>
<p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 WORKDIR 指令。</p>
<p><strong>正确示例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /app</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">"hello"</span> &gt; world.txt</span><br></pre></td></tr></table></figure>
<h3 id="10-USER-指定当前用户"><a href="#10-USER-指定当前用户" class="headerlink" title="10. USER 指定当前用户"></a>10. USER 指定当前用户</h3><p>格式：<code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></p>
<p>USER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。WORKDIR 是改变工作目录，USER 则是改变之后层的执行 RUN, CMD 以及 ENTRYPOINT 这类命令的身份。</p>
<p>当然，和 WORKDIR 一样，USER 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis</span><br><span class="line">USER redis</span><br><span class="line">RUN [ &quot;redis-server&quot; ]</span><br></pre></td></tr></table></figure>
<p>如果以 root 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，<strong>不要使用 su 或者 sudo</strong>，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 <code>gosu</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立 redis 用户，并使用 gosu 换另一个用户执行命令</span></span><br><span class="line">RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis</span><br><span class="line"><span class="comment"># 下载 gosu</span></span><br><span class="line">RUN wget -O /usr/<span class="built_in">local</span>/bin/gosu <span class="string">"https://github.com/tianon/gosu/releases/download/1.7/gosu-amd64"</span> \</span><br><span class="line">    &amp;&amp; chmod +x /usr/<span class="built_in">local</span>/bin/gosu \</span><br><span class="line">    &amp;&amp; gosu nobody <span class="literal">true</span></span><br><span class="line"><span class="comment"># 设置 CMD，并以另外的用户执行</span></span><br><span class="line">CMD [ <span class="string">"exec"</span>, <span class="string">"gosu"</span>, <span class="string">"redis"</span>, <span class="string">"redis-server"</span> ]</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 所以，如果你不是要运行shell脚本，就一定不要以shell的形式写入CMD，比如 CMD npm start =&gt; sh -c “npm start”</p>
</blockquote>
<h3 id="11-ONBUILD-为他人做嫁衣裳"><a href="#11-ONBUILD-为他人做嫁衣裳" class="headerlink" title="11. ONBUILD 为他人做嫁衣裳"></a>11. ONBUILD 为他人做嫁衣裳</h3><p>格式：<code>ONBUILD &lt;其它指令&gt;</code></p>
<p>ONBUILD 是一个特殊的指令，它后面跟的是其它指令，比如 RUN, COPY 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p>
<p>Dockerfile 中的其它指令都是为了定制当前镜像而准备的，唯有 ONBUILD 是为了帮助别人定制自己而准备的。</p>
<p>假设我们要制作 Node.js 所写的应用的镜像。我们都知道 Node.js 使用 npm 进行包管理，所有依赖、配置、启动信息等会放到 package.json 文件里。在拿到程序代码后，需要先进行 npm install 才可以获得所有需要的依赖。然后就可以通过 npm start 来启动应用。因此，一般来说会这样写 Dockerfile:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM node:slim</span><br><span class="line">RUN mkdir /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">COPY ./package.json /app</span><br><span class="line">RUN [ <span class="string">"npm"</span>, <span class="string">"install"</span> ]</span><br><span class="line">COPY . /app/</span><br><span class="line">CMD [ <span class="string">"npm"</span>, <span class="string">"start"</span> ]</span><br></pre></td></tr></table></figure>
<p>把这个 Dockerfile 放到 Node.js 项目的根目录，构建好镜像后，就可以直接拿来启动容器运行。<strong>但是如果我们还有第二个 Node.js 项目也差不多呢？好吧，那就再把这个 Dockerfile 复制到第二个项目里。</strong>那如果有第三个项目呢？再复制么？文件的副本越多，版本控制就越困难，让我们继续看这样的场景维护的问题。</p>
<p>如果第一个 Node.js 项目在开发过程中，发现这个 Dockerfile 里存在问题，比如敲错字了、或者需要安装额外的包，然后开发人员修复了这个 Dockerfile，再次构建，问题解决。第一个项目没问题了，但是第二个项目呢？虽然最初 Dockerfile 是复制、粘贴自第一个项目的，但是并不会因为第一个项目修复了他们的 Dockerfile，而第二个项目的 Dockerfile 就会被自动修复。</p>
<p>那么我们可不可以做一个基础镜像，然后各个项目使用这个基础镜像呢？这样基础镜像更新，各个项目不用同步 Dockerfile 的变化，重新构建后就继承了基础镜像的更新？好吧，可以，让我们看看这样的结果。那么上面的这个 Dockerfile 就会变为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM node:slim</span><br><span class="line">RUN mkdir /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">CMD [ &quot;npm&quot;, &quot;start&quot; ]</span><br></pre></td></tr></table></figure>
<p>这里我们把项目相关的构建指令拿出来，放到子项目里去。假设这个基础镜像的名字为 my-node 的话，各个项目内的自己的 Dockerfile 就变为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM my-node</span><br><span class="line">COPY ./package.json /app</span><br><span class="line">RUN [ &quot;npm&quot;, &quot;install&quot; ]</span><br><span class="line">COPY . /app/</span><br></pre></td></tr></table></figure>
<p>基础镜像变化后，各个项目都用这个 Dockerfile 重新构建镜像，会继承基础镜像的更新。</p>
<p>那么，问题解决了么？没有。准确说，只解决了一半。如果这个 Dockerfile 里面有些东西需要调整呢？比如 npm install 都需要加一些参数，那怎么办？这一行 RUN 是不可能放入基础镜像的，因为涉及到了当前项目的 ./package.json，难道又要一个个修改么？所以说，这样制作基础镜像，只解决了原来的 Dockerfile 的前4条指令的变化问题，而后面三条指令的变化则完全没办法处理。</p>
<p>ONBUILD 可以解决这个问题。让我们用 ONBUILD 重新写一下基础镜像的 Dockerfile:</p>
<p><strong>标准示例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM node:slim</span><br><span class="line">RUN mkdir /app</span><br><span class="line">WORKDIR /app <span class="comment"># 改变工作目录为/app</span></span><br><span class="line">ONBUILD COPY ./package.json /app <span class="comment"># 将源镜像 /app/package.json 复制到新镜像/app 路径下</span></span><br><span class="line">ONBUILD RUN [ <span class="string">"npm"</span>, <span class="string">"install"</span> ]</span><br><span class="line">ONBUILD COPY . /app/</span><br><span class="line">CMD [ <span class="string">"npm"</span>, <span class="string">"start"</span> ]</span><br></pre></td></tr></table></figure>
<p>这次我们回到原始的 Dockerfile，但是这次将项目相关的指令加上 ONBUILD，这样在构建基础镜像的时候，这三行并不会被执行。然后各个项目的 Dockerfile 就变成了简单地：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM my-node</span><br></pre></td></tr></table></figure>
<p>是的，只有这么一行。当在各个项目目录中，用这个只有一行的 Dockerfile 构建镜像时，之前基础镜像的那三行 ONBUILD 就会开始执行，成功的将当前项目的代码复制进镜像、并且针对本项目执行 npm install，生成应用镜像。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gaianote.github.io/2019/02/17/linux/如何去掉Linux终端输出的颜色/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李云鹏">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/rem.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李云鹏的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/17/linux/如何去掉Linux终端输出的颜色/" itemprop="url">如何去掉Linux终端输出的颜色</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-17T03:45:02+00:00">
                2019-02-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h2><p>一般我们都会输出一些带颜色的日志或者标准输出,但现在我们想获取的这部分正好是有颜色的,就出现问题了.</p>
<p>例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#grep 2.6.9_5-9-0-0 kernel.list |awk &apos;&#123;print $2&#125;&apos; | xargs -i ssh &#123;&#125;</span><br><span class="line">Pseudo-terminal will not be allocated because stdin is not a terminal.</span><br><span class="line">ssh: \033[34mbj-xxx.db: Name or service not known</span><br><span class="line">xargs: ssh: exited with status 255; aborting</span><br></pre></td></tr></table></figure>
<p>这里面的bj-xxx.db是需要处理的host,但是因为 kernel.list里面是有颜色的,所以ssh的时候报错,提示”\033[34m”+”真实的host”出错.</p>
<p>该如何去掉这些颜色字符呢?</p>
<h2 id="2-回答"><a href="#2-回答" class="headerlink" title="2.回答"></a>2.回答</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep --color=never</span><br></pre></td></tr></table></figure>
<p>如果是源数据里包含颜色转义符，用<code>sed</code>可以去掉：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -r <span class="string">"s/\x1B\[([0-9]&#123;1,2&#125;(;[0-9]&#123;1,2&#125;)?)?[m|K]//g"</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gaianote.github.io/2019/02/12/docker/5.docker持久化存储/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李云鹏">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/rem.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李云鹏的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/12/docker/5.docker持久化存储/" itemprop="url">docker持久化存储</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-12T15:05:37+00:00">
                2019-02-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-管理Docker中的数据"><a href="#1-管理Docker中的数据" class="headerlink" title="1. 管理Docker中的数据"></a>1. 管理Docker中的数据</h2><p>默认情况下，在容器内创建的所有文件都存储在可写容器层中。这意味着：</p>
<ul>
<li>当该容器不再存在时，数据不会持久存在，并且如果另一个进程需要数据，则可能很难从容器中获取数据。</li>
<li>容器的可写层紧密耦合到运行容器的主机。您无法轻松地将数据移动到其他位置。</li>
<li>写入容器的可写层需要 <a href="https://docs.docker.com/storage/storagedriver/" target="_blank" rel="noopener">存储驱动程序</a>来管理文件系统。存储驱动程序使用Linux内核提供联合文件系统。与使用直接写入主机文件系统的<em>数据卷</em>相比，这种额外的抽象降低了性能 。</li>
</ul>
<p>Docker有两个容器选项可以在主机中存储文件，因此即使在容器停止之后文件仍然存在：<em>卷</em>和 <em>绑定挂载</em>。如果你在Linux上运行Docker，你也可以使用<em>tmpfs mount</em>。</p>
<p>继续阅读有关这两种持久数据方式的更多信息。</p>
<h2 id="2-选择正确的Mount类型"><a href="#2-选择正确的Mount类型" class="headerlink" title="2. 选择正确的Mount类型"></a>2. 选择正确的Mount类型</h2><p>无论您选择使用哪种类型的安装，数据在容器内看起来都是相同的。它作为目录或容器文件系统中的单个文件公开。</p>
<p>可视化卷，绑定装载和<code>tmpfs</code> 装载之间差异的简单方法是考虑数据在Docker宿主主机上的位置。</p>
<p><img src="/images/types-of-mounts.png" alt="img"></p>
<h3 id="1-Volume"><a href="#1-Volume" class="headerlink" title="1. Volume"></a><strong>1. Volume</strong></h3><p><strong>存储在由Docker（/var/lib/docker/volumes/）管理的主机文件系统的一部分中。非Docker进程不应修改文件系统的这一部分。卷是在Docker中保留数据的最佳方式。</strong></p>
<ul>
<li>对于容器内非空目录的处理：第一次创建卷时 ，会将容器内的非空目录内容复制到docker-volume中</li>
</ul>
<h3 id="2-Mount-Points"><a href="#2-Mount-Points" class="headerlink" title="2. Mount Points"></a><strong>2. Mount Points</strong></h3><p>可以存储在主机系统的<em>任何位置</em>。它们甚至可能是重要的系统文件或目录。Docker主机或Docker容器上的非Docker进程可以随时修改它们。</p>
<ul>
<li>对于容器内非空目录的处理：如果容器非空目录挂载到宿主主机，容器内该目录就会隐藏，如果时/usr/bin等目录，则该容器就无法启动，所以，<strong>通常不应该使用Mount Points挂载容器的非空目录到宿主主机</strong></li>
</ul>
<h3 id="3-tmpfs挂载"><a href="#3-tmpfs挂载" class="headerlink" title="3. tmpfs挂载"></a><strong>3. tmpfs挂载</strong></h3><p>仅存储在主机系统的内存中，永远不会写入主机系统的文件系统。</p>
<h2 id="3-Docker-Volume"><a href="#3-Docker-Volume" class="headerlink" title="3. Docker Volume"></a>3. Docker Volume</h2><p><strong>Docker Volume</strong> 是保存<code>Docker</code>容器生成和使用的数据的首选机制。虽然绑定挂载依赖于主机的目录结构，但卷完全由<code>Docker</code>管理。卷绑定安装有几个优点：</p>
<ul>
<li>与绑定装载相比，卷更易于备份或迁移。</li>
<li>您可以使用Docker CLI命令或Docker API管理卷。</li>
<li>卷适用于Linux和Windows容器。</li>
<li>可以在多个容器之间更安全地共享卷。</li>
<li>卷驱动程序允许您在远程主机或云提供程序上存储卷，加密卷的内容或添加其他功能。</li>
<li>新卷的内容可以由容器预先填充。</li>
</ul>
<p><img src="/images/types-of-mounts-volume.png" alt="img"></p>
<p>此外，卷通常是比容器的可写层中的持久数据更好的选择，因为使用卷不会增加使用它的容器的大小，并且卷的内容存在于给定容器的生命周期之外。</p>
<h3 id="1-创建和管理volume"><a href="#1-创建和管理volume" class="headerlink" title="1. 创建和管理volume"></a>1. 创建和管理volume</h3><p><strong>1. 创建存储卷</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create $volume_name</span><br></pre></td></tr></table></figure>
<p><strong>2. 列出已有存储卷</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume ls</span><br><span class="line"></span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               1aa54b00b05aaf521f93586afcae5c9f6a5e44eb6a84c0ab99222435f75b28f5</span><br><span class="line">local               9cf0504c3ac9b408837aa456e13c450b7b9a212f450910ccbee3cefde165027a</span><br></pre></td></tr></table></figure>
<h3 id="2-删除存储卷"><a href="#2-删除存储卷" class="headerlink" title="2. 删除存储卷"></a>2. 删除存储卷</h3><p><strong>1. 删除卷</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume rm volume_name</span><br></pre></td></tr></table></figure>
<p><strong>2. 删除所有未使用的卷并释放空间</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume prune</span><br></pre></td></tr></table></figure>
<h3 id="3-检查卷："><a href="#3-检查卷：" class="headerlink" title="3. 检查卷："></a>3. 检查卷：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume inspect my-vol</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;my-vol&quot;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="4-使用docker卷"><a href="#4-使用docker卷" class="headerlink" title="4. 使用docker卷"></a>4. 使用docker卷</h3><p>我们还可以使用-v或–volume标志将Docker卷附加到容器。但是，我们不是像使用绑定挂载那样将路径放在主机上的目录中，而是简单地放置卷名。</p>
<p>用法：-v 后面跟随  卷名 : docker容器路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-v volume_name:/docker_path</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name adonis \</span><br><span class="line">    -v volume_name:/docker_path \</span><br><span class="line">    ztest</span><br></pre></td></tr></table></figure>
<h2 id="2-使用绑定挂载"><a href="#2-使用绑定挂载" class="headerlink" title="2. 使用绑定挂载"></a>2. 使用绑定挂载</h2><p>自Docker早期以来，Bind Mounts一直存在。与<a href="https://docs.docker.com/storage/volumes/" target="_blank" rel="noopener">卷</a>相比，绑定装载具有有限的功能。使用绑定装入时，<em>主机</em>上的文件或目录将装入容器中。文件或目录由其在主机上的完整路径或相对路径引用。相反，当您使用卷时，会在主机上的Docker存储目录中创建一个新目录，Docker会管理该目录的内容。</p>
<p>该文件或目录不需要已存在于Docker主机上。如果它尚不存在，则按需创建。绑定安装非常高效，但它们依赖于具有特定目录结构的主机文件系统。<strong>如果您正在开发新的Docker应用程序，请考虑使用<a href="https://docs.docker.com/storage/volumes/" target="_blank" rel="noopener">命名卷</a>。</strong>您无法使用Docker CLI命令直接管理Bind Mount。</p>
<p><img src="/images/types-of-mounts-bind.png" alt="img"></p>
<h3 id="1-选择-v或–mount标志"><a href="#1-选择-v或–mount标志" class="headerlink" title="1. 选择-v或–mount标志"></a>1. 选择-v或–mount标志</h3><p>最初，<code>-v</code>或<code>--volume</code>标志用于独立容器，<code>--mount</code>标志用于群组服务。但是，从Docker 17.06开始，您还可以使用<code>--mount</code>独立容器。一般来说， <code>--mount</code>更明确和冗长。最大的区别在于-v 语法将所有选项组合在一个字段中，而<code>--mount</code>语法将它们分开。以下是每个标志的语法比较。</p>
<blockquote>
<p>提示：新用户应使用–mount语法。有经验的用户可能更熟悉-v或–volume语法，但鼓励使用–mount，因为研究表明它更容易使用。</p>
</blockquote>
<h4 id="1-–volume"><a href="#1-–volume" class="headerlink" title="1. –volume"></a>1. –volume</h4><p><code>-v</code>或<code>--volume</code>：由三个字段组成，用冒号字符（<code>:</code>）分隔。字段必须按正确的顺序排列，并且每个字段的含义不是很明显。</p>
<p>对于Bind Mounts，第一个字段是主机上文件或目录的路径。<br>第二个字段是文件或目录在容器中安装的路径。<br>第三个字段是可选的，并且是用逗号分隔的选项，诸如列表ro，consistent，delegated，cached，z，和Z。这些选项将在下面讨论。</p>
<h4 id="2-–mount"><a href="#2-–mount" class="headerlink" title="2.  –mount"></a>2.  –mount</h4><p><code>--mount</code>：由多个键值对组成，以逗号分隔，每个键<code>&lt;key&gt;=&lt;value&gt;</code>组由一个元组组成。该<code>--mount</code>语法比更详细的<code>-v</code>或<code>--volume</code>，但按键的顺序并不显著，并且标志的价值更容易理解。</p>
<p>mount的<code>type</code>，其可以是bind，volume，或tmpfs。本主题讨论bind mounts，因此类型始终是bind。<br>mount的<code>source</code>。对于bind mounts,这是Docker宿主主机上的文件或目录的路径。可以指定为source或 src。<br><code>destination</code>文件或目录安装在容器中的路径作为其值。可以指定为<code>destination</code>，<code>dst</code>或<code>target</code>。<br><code>readonly</code>选项（如果存在）导致bind mounts以只读方式装入容器中。<br><code>bind-propagation</code> 选项（如果存在）会更改 绑定传播。可以是一个 <code>rprivate</code> ，<code>private</code>，<code>rshared</code>，<code>shared</code>，<code>rslave</code>，<code>slave</code>。<br><code>consistency</code>选项，如果存在，可以是一种consistent，delegated或cached。此设置仅适用于Docker Desktop for Mac，在所有其他平台上均被忽略。</p>
<p>该–mount标志不支持z或Z修改selinux标签的选项。<br>下面的示例显示了可能的语法–mount和-v语法，并 –mount首先给出。</p>
<h4 id="3-v和–mount行为之间的差异"><a href="#3-v和–mount行为之间的差异" class="headerlink" title="3. -v和–mount行为之间的差异"></a>3. -v和–mount行为之间的差异</h4><p>因为<code>-v</code>和<code>--volume</code> flags一直是Docker的一部分，所以它们的行为无法改变。这意味着在<code>-v</code>和<code>--mount</code>之间存在一种不同的行为。</p>
<ul>
<li><p>如果使用<code>-v</code>或<code>--volume</code>绑定装载Docker主机上尚不存在的文件或目录，请<code>-v</code>为您创建端点。它始终作为目录创建。</p>
</li>
<li><p>如果您使用<code>--mount</code>绑定Docker宿主主机上尚不存在的文件或目录，Docker也不会自动为您创建它，但会产生一个错误。</p>
</li>
</ul>
<h3 id="2-使用绑定装载启动容器"><a href="#2-使用绑定装载启动容器" class="headerlink" title="2. 使用绑定装载启动容器"></a>2. 使用绑定装载启动容器</h3><p>考虑一个你有一个目录的情况<code>source</code>，当你构建源代码时，工件被保存到另一个目录中<code>source/target/</code>。您希望工件可用于容器<code>/app/</code>，并且您希望每次在开发主机上构建源时容器都可以访问新构建。使用以下命令将<code>target/</code> 目录绑定到容器中<code>/app/</code>。从<code>source</code>目录中运行该命令 。该<code>$(pwd)</code>子命令将扩展到Linux或者MacOS主机的当前工作目录。</p>
<p>所述<code>--mount</code>和<code>-v</code>以下实施例产生相同的结果。除非<code>devtest</code>在运行第一个容器后删除容器，否则不能同时运行它们。</p>
<ul>
<li><code>--mount</code></li>
<li><code>-v</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">  -it \</span><br><span class="line">  --name devtest \</span><br><span class="line">  --mount type=bind,source=&quot;$(pwd)&quot;/target,target=/app \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure>
<p>使用<code>docker inspect devtest</code>验证绑定安装正确创建。寻找<code>Mounts</code>部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Type&quot;: &quot;bind&quot;,</span><br><span class="line">        &quot;Source&quot;: &quot;/tmp/source/target&quot;,</span><br><span class="line">        &quot;Destination&quot;: &quot;/app&quot;,</span><br><span class="line">        &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">        &quot;RW&quot;: true,</span><br><span class="line">        &quot;Propagation&quot;: &quot;rprivate&quot;</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure>
<p>这表明mount是一个<code>bind</code>mount，它显示了正确的源和目标，它表明mount是读写的，并且传播设置为<code>rprivate</code>。</p>
<p>停止容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container stop devtest</span><br><span class="line"></span><br><span class="line">$ docker container rm devtest</span><br></pre></td></tr></table></figure>
<h3 id="3-配置绑定传播"><a href="#3-配置绑定传播" class="headerlink" title="3. 配置绑定传播"></a>3. 配置绑定传播</h3><p>对于bind mounts和volumes，绑定传播默认为<code>rprivate</code>。它仅可用于绑定装入，并且仅适用于Linux主机。绑定传播是一个高级主题，许多用户永远不需要配置它。<strong>绑定传播是指在给定的绑定装载或命名卷（比如宿主主机）中创建的装载是否可以传播到该装载的副本（比如Docker）</strong>。</p>
<table>
<thead>
<tr>
<th style="text-align:left">传播设置</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>shared</code></td>
<td style="text-align:left">原始挂载的子挂载将暴露给副本挂载，副挂载的子挂载也会传播到原始挂载。</td>
</tr>
<tr>
<td style="text-align:left"><code>slave</code></td>
<td style="text-align:left">类似于共享挂载，但只在一个方向上。如果原始挂载程序公开子挂载，则副本挂载程序可以看到它。而副本挂载的子挂载不会传播到原始挂载</td>
</tr>
<tr>
<td style="text-align:left"><code>private</code></td>
<td style="text-align:left">挂载是私人的。其中的子挂载不会暴露给副本挂载，副挂载的子挂载也不会暴露给原始挂载。</td>
</tr>
<tr>
<td style="text-align:left"><code>rshared</code></td>
<td style="text-align:left">与共享相同，但传播也扩展到嵌套在任何原始或副本挂载点中的挂载点。</td>
</tr>
<tr>
<td style="text-align:left"><code>rslave</code></td>
<td style="text-align:left">与从属相同，但传播也延伸到嵌套在任何原始或副本挂载点内的挂载点。</td>
</tr>
<tr>
<td style="text-align:left"><code>rprivate</code></td>
<td style="text-align:left">默认。与private相同，意味着原始或副本装入点中任何位置的挂载点都不会沿任一方向传播。</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -v /foo:/bar:slave</span><br></pre></td></tr></table></figure>
<h3 id="4-挂载到容器上的非空目录中"><a href="#4-挂载到容器上的非空目录中" class="headerlink" title="4. 挂载到容器上的非空目录中"></a>4. 挂载到容器上的非空目录中</h3><p><strong>如果将bind-mount绑定到容器上的非空目录中，则绑定装置会隐藏目录的现有内容。</strong>这可能是有益的，例如当您想要在不构建新图像的情况下测试新版本的应用程序时。但是，它也可能令人惊讶，并且此行为与<a href="https://docs.docker.com/storage/volumes/" target="_blank" rel="noopener">docker卷的</a>行为不同。</p>
<p>此示例设计为极端，将容器<code>/usr/</code>目录的内容替换<code>/tmp/</code>为主机上的目录, 在大多数情况下，这会导致容器无法运行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">  -it \</span><br><span class="line">  --name broken-container \</span><br><span class="line">  --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/tmp,target=/usr \</span><br><span class="line">  nginx:latest</span><br><span class="line"></span><br><span class="line">docker: Error response from daemon: oci runtime error: container_linux.go:262:</span><br><span class="line">starting container process caused <span class="string">"exec: \"nginx\": executable file not found in <span class="variable">$PATH</span>"</span>.</span><br></pre></td></tr></table></figure>
<p>容器已创建但无法启动。去掉它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container rm broken-container</span><br></pre></td></tr></table></figure>
<h2 id="5-NFS"><a href="#5-NFS" class="headerlink" title="5. NFS"></a>5. NFS</h2><pre><code>docker volume create \
    --driver local \
    --opt type=nfs \
    --opt o=addr=192.168.71.104,rw  \
    --opt device=:/tytest/workspace \
    tytest
  docker run -it -v tytest:/workspace --privileged 192.168.71.104:5000/tytest
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/rem.png" alt="李云鹏">
            
              <p class="site-author-name" itemprop="name">李云鹏</p>
              <p class="site-description motion-element" itemprop="description">萍水相逢也是前世之缘</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">219</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李云鹏</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      本站访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      本站总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
