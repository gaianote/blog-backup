---
title: 使用dd命令快速生成大文件或者小文件的方法
date: 2019-03-23 12:11:38
tags: linux
---


在程序的测试中有些场景需要大量的小文件或者几个比较大的文件，而在我们的文件系统里一时无法找到那么多或者那么大的文件，此时linux的dd命令就能快速的帮助你完成想要的文件。具体用法简单总结如下：

## dd命令可以轻易实现创建指定大小的文件，如

```bash
dd if=/dev/zero of=A bs=1M count=1000
```

在当前目录下会生成一个1000M的test文件，文件内容为全0（因从/dev/zero中读取，/dev/zero为0源），但是这样为实际写入硬盘，文件产生速度取决于硬盘读写速度，如果欲产生超大文件，速度很慢。在某种场景下，我们只想让文件系统认为存在一个超大文件在此，但是并不实际写入硬盘

则可以

```bash
dd if=/dev/zero of=A bs=1M count=0 seek=1000
```

此时创建的文件在文件系统中的显示大小为10000MB，但是并不实际占用block，因此创建速度与内存速度相当，seek的作用是跳过输出文件中指定大小的部分，这就达到了创建大文件，但是并不实际写入的目的。当然，因为不实际写入硬盘，所以你在容量只有10G的硬盘上创建100G的此类文件都是可以的。



## 随机生成1百万个1K的文件

```bash
seq 1000000 | xargs -i dd if=/dev/zero of={}.dat bs=1024 count=1 
```

## 当你不需要关心随机文件的内容，只需一个固定大小的文件
Solaris、Mac OS X等Unix系统中mkfile指令，可以产生指定大小的文件，而Linux上则没有
例子：mkfile -n 160g test1
Linux可以用dd指令，/dev/zero是一个特别的文件描述符可以通过它返回null值
例子：dd if=/dev/zero of=test.file count=1024 bs=1024
产生count * bs字节的文件，1M
此方法生成随机文件的好处在于效率高（产生1G文件大概1s）,创建的文件大小精确到字节
坏处也有
使用null字符来填充文件内容，文件统计时没有行（wc -l test.file为0）

## 当你不需要关心随机文件的内容，但期望测试文件能有统计的行

```bash
dd if=/dev/urandom of=A bs=1M count=100
```

将`/dev/zero` 改为`/dev/urandom`，`/dev/urandom`是linux下的随机数生成器

关于`/dev/urandom`跟`/dev/random`两者的区别就不在此详细讨论，大概就是，前者是不受系统interrupts的限制，即使没有足够的interrupt它也能通过随机数生成器产生足够的输出值；而后者如果用在dd上，它不能被ctrl+c或者kill -9中断，如果ds的值较大时，产生的随机值不足而长期占用CPU。虽然说`/dev/random`产生的随机数会更随机些，但与dd混用还是建议用`/dev/urandom`效率更高。

缺点跟`/dev/zero`比当然是效率会更低些了，生成个100Mb的文件需要10秒左右，而且文件并没有可读的内容，一般的情况基本上是满足了。

漏了说句，dd是linux与unix都支持的指令。

## 当你关心文件的随机内容行数，而不关心内容是否有所重复

这里的思路就是找一个参照文件（比如说2行），将文件重新定向到新的文件，再mv覆盖保存，外加一个for循环。（n为循环次数，产生的文件行为2^（n+1））

例子:假设先建立一个file.txt文件，里面含有Hello 和 World两行

```
for i in {1..n}; do cat file.txt file.txt > file2.txt && mv file2.txt file.txt; done
```

由于是阶乘，n=20左右已经是200W行，效率会下降地比较厉害

## 当你关心随机文件的内容，而不想出现重复内容行情况

这种情况下系统的指令应该是不能满足了，或者可以通过操作系统的指令写一大串脚本也可以达到，但不建议这么做，因为可读性和维护性考虑，你应该要引入Ruby或者Python类的脚本语言帮忙了
但还是要借助些系统的东西来帮忙

思路：/usr/share/dict/words里面有记录一些单词，一共235886行，每行一个单词
可以从里面挑选一些作为文件的内容
加循环达到我们想要的随机文件要求

举例：ruby -e 'a=STDIN.readlines;X.times do; b=[];Y.times do; b<<a[rand(a.size)].chomp end; puts b.join(" ")' < /usr/share/dict/words > file.txt

X为随机文件需要的行数，Y为从words中读取的单词，虽说组合成一句的命令，还是可以读懂的；从标准输入中重复读取Y个单词，写入到b列表中，然后再通过join空格连接内容写入到标准输出文件file.txt中

这样基本很少会有重复的行了，而且生成的效率与其他方法对比还是可以的，10秒生成100Mb文件。欢迎大家讨论。
